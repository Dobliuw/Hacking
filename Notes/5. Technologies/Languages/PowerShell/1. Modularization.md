# Modularization (psm1/psd1)

Es **PowerShell**, modularizar significa empaquetar funciones y recursos en módulos para reutilizarlas, versionarlas y cargarlas con control. Los estándar es usar un *script module* (`.psm1`) y un *manifest* (`.pds1`). El `.psm1`contiene el código; el `.psd1` describe metadatos qué se exporta.

----
# Modules

Un **módulo** es una unidad de carga que puede contener funciones, cmdlets, alias, variables, tipos, formatos y recursos DSC. Se carga explícitamente con `Import-Module`o implícitamente por *auto-import* cuando se invoca un comando que pertenece a un módulo presente en el `PSModulePath`. 

Tipos habituales:

- **Script module**: archivo `.psm1` con código PowerShell.
- **Binary module**: ensamblado `.dll`con cmdlets .NET.
- **Manifest**: archivo `.psd1` (*Hashtable* (*Dictionary* en otros lenguajes de programación)) que describe metadatos, dependencias y qué se exporta.

----
# Disk  layout & Discovery

PowerShell busca módulos en las rutas listadas en `$env:PSModulePath`. La  convención de empaquetado básica es:

```python
<PSModulePath>\ModuleName\
	ModuleName.psm1            # Script module (Entrypoint)
	ModuleName.psd1            # Manifest (Metadata)
	Public\                    # Functions to export
	Private\                   # Internal Helpers (No export)
	en-US\ModuleName-help.xml  # Optional: Help
	*.ps1xml                   # Optional: Types/Formats
```

La carpeta debe llamarse *exactamente igual* que el módulo; el `psm1` y el `psd1` normalmente comparten ese nombre.

-----
# Load and Initialization

- `Import-Module {NameModule}`localiza la carpeta en `$PSModulePath`, lee el *manifest* (Si es que existe) y carga el `RootModule` (Normalmente el `.psm1`).
- `Auto-Import` (*PowerShell 3+*): Si se llama a una función exportada, el motor importa el módulo automáticamente.
- `using module {NameModule}`(*PowerShell 5+*): Fuerza cargar en tiempo de análisis (Útil cuando el script usa clases o necesita el módulo disponible antes de ejecutar).
- El código del `.psm1` *se ejecuta al importar*: Se debe limitar a definir funciones, inicializar estado interno y registrar tipos/formatos; evita efectos secundarios no solicitados.

----
# Exporting

- Si el módulo esta en `$PSModulePath`:

```powershell
Import-Module ModuleName
# Verify the correct import
Get-Command -Module ModuleName
```

- Importar por ruta (`psd1` o `psm1`):

```powershell
# Recommended (If are Manifest)
Import-Module "$HOME\dev\ModuleName\ModuleName.psd1"
```

- Ejemplo de estructura: 

```cpp
dobliuw_folder/
	getScore.ps1
	module/
		DobliuwModule.psm1
		DobliuwModule.psd1
		Public/
			FirstScript.ps1
			SecondScript.ps1
		Private/
			Helpers.ps1
```

- Ejemplo de `DobliuwModule.psm1`:

```powershell
# Load internal helpers
. "$PSScriptRoot\Private\Helpers.ps1"

# Load public functions
. "$PSScriptRoot\Public\FirstScript.ps1"
. "$PSScriptRoot\Public\SecondScript.ps1"

# Export ONLY public API (OPTIONAL IN RELATION WITH THE MANIFEST .psd1)
Export-ModuleMember -Function FunctionRandomStoredInFirstScript, FunctionTwo, AnotherFunctionStoredInSecondScript
```

> [!info] Exporting functions with `Export-ModuleMember`
> En caso de exportar las funciones que querramos utilizar en este punto, a la hora de realizar (O en caso de ya tenerlo realizado) el Manifest `.psd1` **no mezclar dos fuentes de export** como lo son la función `Export-ModuleMember` ey el array `FunctionsToExport = @(....)`. 
>
> La idea en este punto es elegir uno de estos enfoques y ser consistente. Si elegimos utiliar la función en lugar del array del Manifest, este puede ser eliminado o puesto como: `@('*')`.
 
- Ejemplo de `DobliuwModule.psd1`:

```powershell
@{
	RootModule             = 'DobliuwModule.psm1'
	ModuleVersion          = '1.0.0'
	GUID                   = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
	Author                 = 'Dobliuw'
	Description            = 'This is just an example inside my personal artycles'
	PowerShellVersion      = '5.1'
	FunctionsToExport      = @('FunctionRandomStoredInFirstScript', 'FunctionTwo', 'AnotherFunctionStoredInSecondScript')
	CmdletsToExport        = @()
	VariablesToExport      = @()
	AliasesToExport        = @()
}
```

Una vez esta estructura, desde dentro de el archivo `.ps1` (Ejemplo `getScore.ps1`):

```powershell
# Import by route
Import-Module "$PSScriptRoot\module\DobliuwModule.psd1" -Force

# Invoke functions exported
$last = FunctionRandomStoredInFirstScript -Username $dobliuwName
```

> [!info] Importing module
> Si de momento no tenemos el Manifest (`.psd1`) podríamos importar el `.psm1` en lugar de este último.