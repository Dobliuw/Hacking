# Assembly

El **lenguaje ensamblador** (**Assembly language**) es un lenguaje de programación de bajo nivel que está muy cerca del lenguaje máquina, el cual es comprendido directamente por la CPU. A diferencia de los lenguajes de alto nivel como C o Python, el ensamblador proporciona control directo sobre el hardware y es específico para cada arquitectura de CPU.

Sus componentes principales se dividen en:

- **Registers**: Pequeñas unidades de almacenamiento dentro de la CPU utilizadas para realizar operaciones. Ejemplos de registros en la arquitectura x86 son `EAX`, `EBX`, `ECX` y `EDX`. Explicación de que son los registros y el uso de estos en [[0. CPU & Assembly Basics#Registers]]. 
- **Instructions**: Comandos que le dicen a la CPU qué operaciones realizar. Las instrucciones pueden ser de varios tipos, incluyendo aritméticas, de movimiento de datos, de control de flujo, entre otras.
- **Directives**: Las directivas son comandos que proporcionan información al ensamblador pero no se traducen directamente a instrucciones de máquina. Ejemplos incliyen `.data` para definiciar una sección de datos y `.text` para definir una sección de código.
- **Labels**: Las etiquetas son identificadores que se utilizan para marcar posiciones en el código, permitiendo saltos y llamadas a funciones.

---
# Life Cycle of Assembly Code

El *ciclo de vida de un programa codeado en lenguaje ensamblador* se separa en algunos puntos claves: 

1. **Source Code**
El código fuente es el programa escrito por el programador en un lenguaje de alto nivel (C, C++, Python, etc.) o en ensamblador. Este es el punto de partida.

2. **Assembly**
Continuamos con el ensamblado, momento en el que si el código fuente está en ensamblador, se utiliza un *ensamblador* (Como `as` en GNU) para convertir el código en *lenguaje máquina*. Este proceso genera un *archivo objeto* (`.o`).

```bash
as -o program.o program.s
```

- *Machine language*
El lenguaje máquian es el conjunto de instrucciones que la CPU puede ejecutar directamente. Estas instrucciones están codificadas en binario y son específicas para cada arquitectura de la CPU. El lenguaje máquina es el nivel más bajo de abstracción y consiste en secuencias de bits que representan operaciones y datos. Ejemplo: `10110000 01100001`

- *Object language*
El térmi "*lenguaje objeto*" generalmente se refiere al código objeto o archivos objeto (`.o`). Los archivos objeto son el resultado del ensamblado del código fuente (En ensamblado o en un lenaguaje de alto nivel) y contiene código máquina, pero también incluyen metadatos adicionales necesarios para la **vinculación**, como símbolos y tables de reubicación.

3. **Compilation**
Para lenguajes de alto nivel, se usa un compilador (Como `gcc` para C) que realiza dos tareas:
- *Traducción a Ensamblador*: Convierte el código fuente a código ensamblador.
- *Ensamblado Automático*: Convierte el código ensamblador a código objeto.

```bash
gcc -c program.c -o program.o
```

La flag `-c` indica que solo se quiere compilar y ensamblar, no *enlazar*. 

4. **Linking**
El proceso final, la vinculación o el enlace, toma uno o más archivos objeto y los combina en un único ejecutable, se utiliza un enlazador (`ld` en GNU) el cual resuelve las referencias a funciones y variables externas.

```bash
ld -o final_executable program.o
gcc program.o -o final_executable
```

---
# Assembly Instructions

Como mencionamos anteriormente las *Assembly Instructions* son comandos que le indican a la CPU qué operaciones realizar. Las instrucciones pueden ser de varios tipos, incluyendo aritméticas, de movimiento de datos, de control de flujo, entre otras.

De igual manera, resulta fundamental entender que son los *registros* y *direcciones de memoria*, conceptos claves utilizados en esta sección explicados en [[0. CPU & Assembly Basics]]. 

Para resumir y tener en cuenta:

- **Registers**: Los registros son ubicaciones de almacenamiento rápido dentro de la CPU. Ejemplos de registros en x86 son *eax*, *ebx*, *ecx*, *esi*, *edi*, *ebp*, *esp* etc.
- **Memory Addresses**: Las direcciones de memoria se especifican usando corchetes (`[]`). Pueden ser direcciones absolutas o relativas a otros registros.
- **Constants**: Las constantes son valores inmediatos que se especifican directamente en la instrucción.
- **Operand Size**: Es importante que los tamaños de los operandos coincidan. Por ejemplo, no podremos mover un valor de 32 bits a un registro de 16 bits sin convertir el tamaño adecuadamente.
- **Efective Directions**: Las instrucciones de movimiento que involucran memoria pueden usar una dirección efectiva que incluye desplazamientos y registros base/índice. Ejemplo:

```asm
mov eax, [ebx + ecx*4 + 8]
```

#### Data Movement Instructions

Las instrucciones de movimiento de datos permiten transferir datos entre registros, memoria y constantes. Estas instrucciones son fundamentales para la manipulación de datos y el control de flujo en programas de bajo nivel. 

- ## **mov** 

La instrucción `mov` es fundamental en el lenguaje ensamblador, utilizada ara mover datos entre registros, entre registros y memoria, o entre un registro y un valor inmediato. Si bien los movimientos de registro a registro son factibles, no se admiten movimientos directos de memoria a memoria, dado que cuando son necesaria transferencias de memoria, el contenido de la memoria de origen debe cargarse incialmente en un registro, que luego puede almacenarse en la dirección de la memoria de destino.

*Syntax*
```asm
mov {destination}, {source}
```

*Examples*
```asm
mov ebx, eax      ; mov {reg}, {reg}     ; move the value stored in a register to another
mov eax, [ebx]    ; mov {reg}, {mem}     ; move the value of a memory address to a register
mov [var], eax    ; mov {mem}, {reg}     ; move the value of a register to a memory address
mov eax, 5        ; mov {reg}, {const}   ; move a constant to a register
mov [var2], 10    ; mov {mem}, {const}   ; move a constant to a memory address
```

En los ejemplos brindados arriba, se pueden apreciar todos los tipos de operaciones que se pueden realizar con la instrucción `mov`, dandonos la capacidad de mover *registros con registros*, *registros con direcciones de memoria*, *direcciones de memoria con registros*, *registros con constantes* y *direcciones de memoria con constantes*. 

Es importante tener en cuenta que los movimiento de *dirección de memoria con dirección de memoria* **no estan soportados**.

- ## **push**

La instrucción `push` se utiliza para colocar su operando en la parte superior de la pila (*stack*) en memoria. Como hemos mencionado, la pila es una estructura de datos qeu funciona en modo *LIFO* (*Last In, First Out*). En la arquitectura x86, la pila crece hacia direcciones de memoria más bajas.

- **ESP Decrement**: `ESP` es el registro del punter de la pila (*Stack Pointer*). antes de colocar el operando en la pila, ESP se decrementa por 4, ya que en la arquitectura x86 el tamaño de una palabra es de 4 bytes (32 bits). Esto es necesario porque la pila en x86 crece hacia abajo, lo que signiffica que las nuevas entradas se colocan en direcciones de memoria más bajas.
- **Operand Colocation**: Despúes de decrementar ESP, el operando se coloca en la dirección de memoria apuntada por ESP.

*Syntax*
```asm
push {source}
```

*Examples*
```asm
push eax      ; push {reg32}      ; push the value stored in eax to the stack
push [var]    ; push {mem}        ; push the value of a memory address to the stack
push 0x10     ; push {const32b}   ; push a constant of 32 bits to the stack
```

En el contexto de la arquitectura x86, una ubicación de 32 bits se refiere a una dirección de memoria que puede contener 32 bits (4 bytes) de datos. Las operaciones que involucran registros, direcciones de memoria y constantes suelen trabajar con bloques de datos de 32 bits. 

Los registros de 32 bits en la arquitectura x86 son *eax*, *ebx*, *ecx*, *edx*, *esi*, *edi*, *ebp* y *esp*. Por otro lado también se podría envíar un valor inmediato que ocupa 32 bits, ejemplo *0x12345678*.

Los siguientes gráficos intentan ayudarnos a entender de una manera más gráfica el desplazamiento de la pila (*Stack*) y del ESP (*Stack Pointer*), dado que como mencionamos, la pila a medida de que se envía (*push*) datos, se decrementa 4 bytes (32 bits) y el ESP cambia su valor a la dirección de la pila decrementada.

Ejemplo:

1. `ESP` (*Stack Pointer*) apunta a la dirección de memoria **0x7FFFFFFF**:

![[push_instruction_low_level_example_1.png]]

2. Nuestro programa ejecuta la instrucción `push eax`, donde `eax` almacena el valor de **0x12345678**, lo que dará como resultado el decremento en 4 bytes de la pila y por ende del valor del `ESP`, pasando de valer *0x7FFFFFFF* a valer *0x7FFFFFFB*:

![[0. Images/push_instruction_low_level_example_2.png]]

3. Nuestro programa ejecuta la instrucción `push [0x2000]`, donde la dirección de memoria `0x00002000` almacena el valor **0x87654321**, lo que dará como resultado el decremento en 4 bytes de la pila y por ende del valor del `ESP`, pasando de valer *0x7FFFFFFB* a valer *0x7FFFFFF7*:

![[push_instruction_low_level_example_3.png]]

4. Nuestro programa ejecuta la instrucción `push 0x30`, lo que dará  como resultado el decremente en 4 bytes de la pila y por ende del valor del `ESP`, pasando de valer *0x7FFFFFF7* a valer *0x7FFFFFF3*:

![[push_instruction_low_level_example_4.png]]

Con este ejemplo podemos entender cómo el stack se expande desde la dirección inicial hacia direcciones menores con cada operación `push` y como el valor del `ESP` va mutando apuntando a la dirección de memoria del inicio de la pila.  

- ## **pop** 

La instrucción `pop` se utiliza para eliminar un valor de la parte superior de la pila y almacenar ese valor en un registro o en una ubicación de memoria. El proceso implica dos pasos principales: 

- **Operand Storage**: Alamacenar el valor hayado en la dirección de memoria apuntada por `ESP`. 
- **ESP Increment**: Incrementear en 4 bytes (32 bits) el valor de `ESP`. 

*Syntax*
```asm
pop {destination}
```

*Examples*
```asm
pop eax      ; pop {reg32}    ; pop off the last pushed value at the stack to a register
pop [var]    ; pop {mem}      ; pop off the last pushed value at the stack to a memory address
```

Los siguientes gráficos intentan ayudarnos a entender de una manera más gráfica el desplazamiento de la pila (*Stack*) y del ESP (*Stack Pointer*), dado que como mencionamos, la pila a medida de que se sacan (*pop*) datos, se incrementa 4 bytes (32 bits) y el ESP cambia su valor a la dirección de la pila incrementada. 


1. `ESP` (*Stack Pointer*) apunta a la dirección de memoria **0x7FFFFFF3**:

![[pop_instruction_low_level_example_1.png]]


2. Nuestro programa ejecuta la instrucción `pop ebx`, donde en`ebx` se almacenará el último valor envíado (*push*) a la pila, lo que dará como resultado el incremento en 4 bytes de la pila y por ende del valor del `ESP`, pasando de valer  *0x7FFFFFF3* a valer *0x7FFFFFF7*:

![[pop_instruction_low_level_example_2.png]]

3. Nuestro programa ejecuta la instrucción `pop ecx`, donde en `ecx` se almacenará el último valor envíado (*push*) a la pila (**0x87654321**), lo que dará como resultado el incremento en 4 bytes de la pila y por ende del valor de `ESP`, pasando de valer *0x7FFFFFF7* a valer *0x7FFFFFFB*:

![[pop_instruction_low_level_example_3.png]]

4. Por último, nuestro programa ejecuta la instrucción `pop edx`, donde en `edx` se almacenará el último valor envíad (*push*) a la pila (**0x12345678**), lo que dará como resultado el incremento en 4 bytes de la pila y por ende del valro de `ESP`, pasando de valer *0x7FFFFFFB* a valer *0x7FFFFFFF*:

![[pop_instruction_low_level_example_4.png]]

Con este ejemplo podemos entender cómo el stack se achica desde la dirección inicial hacia direcciones mayores con cada operación `pop` y como el valor del `ESP` va mutando apuntando a la dirección de memoria del inicio de la pila.  

---
# Final Example

1. **Source code**: Archivo `hello.s`: 
```assembly
section .data
	msg db 'Hello, World!', 0

section .text
	global _start

_start:
	; Write the message to stdout
	mov eax, 4         ; sys_write = 4 
	mov ebx, 1         ; file descriptor (stdout = 1)
	mov ecx, msg       ; message to write
	mov edx, 13        ; message length
	int 0x80           ; call kernel

	; Exit the program
	mov eax, 1         ; sys_exit = 1
	xor ebx, ebx       ; exit code 0
	int 0x80           ; call kernel
```

2. **Assembly**: Ensamblamos el código en lenguaje ensamblador a archivo objeto:

```bash
as -o hello.o hello.s
```

3. **Linking**: Enlazamos el o los archivo/s objeto/s:

```bash
ld -o hello_world hello.o
```

----
Referencias y recomendaciones:
- https://elswix.github.io/articles/2/assembly-instructions-intel-x86.html
- https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
