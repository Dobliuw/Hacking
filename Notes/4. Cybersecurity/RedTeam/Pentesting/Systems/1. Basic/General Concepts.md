# Byte y Bits: 

Cuando nos referimos a *bits*, estamos hablando de la únidad más básica de información en un sistema informático, pudiendo representar un *0* o un *1*. Por otro lado, un *byte* corresponde a una agrupación de *8 bits*.
# Binary System

El sistema binario es un sistema de numeración en base 2, lo que significa que cada dígito puede ser solo 0 o 1. Es el sistema utilizado por las computadoras para representar todos los datos internamente, colores, números, letras, pixeles, etc. Cada posición en un número binario representa una potencia de 2, similar a cómo cada posición en un número deciaml representa una potencia de 10.

En un número binario, cada dígito (*bit*) tiene un peso específico basado en su posición. Empezando desde la derecha, el primer bit tiene un peso de *2 ^ 0* = **1**,  el siguiente bit tiene un peso de *2 ^ 1* = **2**, el siguitente *2 ^ 2* = **4** y así sucesivamente. Es decir que para un conjunto de 4 bits (Suele denominarse *nibble*) los pesos son *1*, *2*, *4* y *8* de derecha a izquierda.

Entonces, con un nibble (4 bits) podemos representar un total de *2^4* = **16** posibilidades, que van desde el 0 al 15. A continuación veremos una tabla la cual nos ayudará a visualizar de una mejor manera esto, es importante tener en cuenta que para entender esta tabla hay que poder contar en números binarios y para eso hay que entender como...

Para contar en binario, comenzamos de derecha a izquierda. Siempre que encontramos un 0, lo convertimos en 1. Si encontramos un 1, lo convertimos en 0 y llevamos el 1 a la posición siguiente a la izquierda. Si esa posición también es 1, repetimos el proceso.

|  8  |  4  |  2  |  1  |     | Decimal value |
| :-: | :-: | :-: | :-: | :-: | :-----------: |
|  0  |  0  |  0  |  0  |  =  |       0       |
|  0  |  0  |  0  |  1  |  =  |       1       |
|  0  |  0  |  1  |  0  |  =  |       2       |
|  0  |  0  |  1  |  1  |  =  |       3       |
|  0  |  1  |  0  |  0  |  =  |       4       |
|  0  |  1  |  0  |  1  |  =  |       5       |
|  0  |  1  |  1  |  0  |  =  |       6       |
|  0  |  1  |  1  |  1  |  =  |       7       |
|  1  |  0  |  0  |  0  |  =  |       8       |
|  1  |  0  |  0  |  1  |  =  |       9       |
|  1  |  0  |  1  |  0  |  =  |      10       |
|  1  |  0  |  1  |  1  |  =  |      11       |
|  1  |  1  |  0  |  0  |  =  |      12       |
|  1  |  1  |  0  |  1  |  =  |      13       |
|  1  |  1  |  1  |  0  |  =  |      14       |
|  1  |  1  |  1  |  1  |  =  |      15       |
De manera matemática, podríamos entender que se múltiplica el 1 o el 0 correspondiente al lugar del peso para posteriormente sumarse entre si, siendo el número binario *1010* por ejemplo:

$$
1*8+0*4+1*2+0*1 = 8+0+2+0 =  10
$$

De una manera más gráfica:

![[understanding_matematic_method_binary_system.png]]

# Hexadecimal System: 

Habiendo entendido el sistema binario, podemos ver que se vuelve complejo manejar y representar números binarios larogs. Para simplificar esto, se creo y desde entonces utilizá el *sistema hexadecimal*.

El *sistema hexadecimal* es un sistema de numeración en base 16. Utiliza 16 símbolos, los cuales son números del *0 al 9* y letras de la* A a la F*. Este sistema es ampliamente utilizando debido a su eficiencia y facilidad para representar números binarios.

En el sistema hexadecimal, cada dígito representa *4 bits*. Por lo tanto, podemos usar un solo dígito hexadecimal para representar un nibble completo:

|  8  |  4  |  2  |  1  |     | Hexadecimal value |
| :-: | :-: | :-: | :-: | :-: | :---------------: |
|  0  |  0  |  0  |  0  |  =  |         0         |
|  0  |  0  |  0  |  1  |  =  |         1         |
|  0  |  0  |  1  |  0  |  =  |         2         |
|  0  |  0  |  1  |  1  |  =  |         3         |
|  0  |  1  |  0  |  0  |  =  |         4         |
|  0  |  1  |  0  |  1  |  =  |         5         |
|  0  |  1  |  1  |  0  |  =  |         6         |
|  0  |  1  |  1  |  1  |  =  |         7         |
|  1  |  0  |  0  |  0  |  =  |         8         |
|  1  |  0  |  0  |  1  |  =  |         9         |
|  1  |  0  |  1  |  0  |  =  |         A         |
|  1  |  0  |  1  |  1  |  =  |         B         |
|  1  |  1  |  0  |  0  |  =  |         C         |
|  1  |  1  |  0  |  1  |  =  |         D         |
|  1  |  1  |  1  |  0  |  =  |         E         |
|  1  |  1  |  1  |  1  |  =  |         F         |
De esta manera, si tuviéramos 1 byte (8 bits), representando las 256 posibilidades existentes (2^8), sería más fácil manejar las representaciones en el sistema hexadecimal. en lugar de tener un binario de 8 dígitos (*11111111* par *255*), tendríamos dos caracteres, *FF*.

| 128 | 64  | 32  | 16  |    8     |  4  |  2  |  1  |     | Decimal |
| :-: | :-: | :-: | :-: | :------: | :-: | :-: | :-: | :-: | :-----: |
|  0  |  0  |  0  |  0  |    0     |  0  |  0  |  0  |  =  |    0    |
|     |     |     |     | ........ |     |     |     |     |         |
|  1  |  1  |  1  |  1  |    1     |  1  |  1  |  1  |  =  |   255   |
Pero en cambio, si hariamos uso del sistema hexadecimal, podriamos separar los neddles (4 bits), dejandonos como resultado simplemente 2 caracteres para la representación de las 256 posibilidades existentes con 4 bits, por lo que en lugar de tener un binario de 8 digitos (*11111111* para *255*), tendríamos dos caracteres, como *FF*. 

| Decimal Number |     | Hexadecimal |
| :------------: | :-: | :---------: |
|       0        |  =  |      0      |
|       1        |  =  |      1      |
|       2        |  =  |      2      |
|       3        |  =  |      3      |
|       4        |  =  |      4      |
|       5        |  =  |      5      |
|       6        |  =  |      6      |
|       7        |  =  |      7      |
|       8        |  =  |      8      |
|       9        |  =  |      9      |
|       10       |  =  |      A      |
|       11       |  =  |      B      |
|       12       |  =  |      C      |
|       13       |  =  |      D      |
|       14       |  =  |      E      |
|       15       |  =  |      F      |
|       16       |  =  |     10      |
|       17       |  =  |     11      |
|     .....      |     |    .....    |
|       74       |  =  |     4A      |
|     .....      |     |    .....    |
|      145       |  =  |     91      |
|     .....      |     |    .....    |
|      248       |  =  |     F8      |
|      249       |  =  |     F9      |
|      250       |  =  |     FA      |
|      251       |  =  |     FB      |
|      252       |  =  |     FC      |
|      253       |  =  |     FD      |
|      254       |  =  |     FE      |
|      255       |  =  |     FF      |
Con tener en la mente la sucesión, es decir que va del 0 al 9 y luego de la A a la F, simplemente cuando lleguemos a la F, volveremos a empezar la sucesión incrementando el primer caracter de izquierda a derecha, tambien siguiendo la sucesión, lo que nos dejará el rango del 00 al FF. 

---
# *OSI* Model (Open Systems Interconnection): 

El modelo OSI es una estructura de *siete capas* que se utiliza para describir el proceso de comunicación entre dispositivos. Cada capa proporciona serevicios y funciones especificas.

- 1. **CAPA FÍSICA**: 
Es la capa más baja, esta se encarga de la transmisión de datos a través del medio físio de la red, como cables de cobre o fibra óptica.

- 2. **CAPA DE ENLACE DE DATOS**: 
Esta capa se encarga de la transferencia confiable de datos entre dispositivos en la misma red. También proporciona funciones para la detección y corrección de errores en los datos transmitidos.

- 3. **CAPA DE RED**: 
La capa de red se ocupa del enrutamiento de paquetes de datos a través de múltiples redes. Esta capa utiliza direcciones lógicas, como direcciones IP, para identificar dispositivos y rutas de red.

- 4. **CAPA DE TRANSPORTE**: 
La capa de transporte se encarga de la entrega confiable de datos enre dispositivos finales, proporcionando servicios como el control de flujo y la corrección de errores. 

- 5. **CAPA DE SESIÓN**:
Esta capa se encarga de establecer y mantener las sesiones de comunicación entre dispositivos. También proporciona servicios de gestión de sesiones, como la autenticación y la autorización. 

- 6. **CAPA DE PRESENTACIÓN**: 
La capa de presentación se encarga de la representación de datos, proporcionando funciones como la codificación de datos, la compresión y el cifrado.

- 7. **CAPA DE APLICACIÓN**: 
La capa de aplicación proporciona servicios para aplicaciones de usuario finales, como correo electrónico, navegadores web y transferencia de archivos. 

