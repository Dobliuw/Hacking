Podemos obtener algunos setups preconfigurados en [la página oficial de hyprland wiki](https://wiki.hyprland.org/Getting-Started/Preconfigured-setups/) y así mismo visitar el recurso de [lista de recursos para Wayland](https://github.com/rcalixte/awesome-wayland) donde encontraremos de todo, herramientas, librerías para screelocking,  notifcaciones, barras, prompts, etc.
# Install Dependencies and Hyprland

Lo primero que debemos realizar a la hora de comenzar con la instalación de nuestro entorno de **Hyprland** es llevar a cabo la instalación de este (Sea manual desde el repositorio oficla o de los paquetes disponibles para Arch) junto a sus correspondientes dependencias, terminal y aplicaciones básicas.

```bash
# Update
sudo pacman -Syu
# Dependencies
sudo pacman -S git base-devel cmake meson ninja wayland wayland-protocols \
  xdg-desktop-portal xdg-desktop-portal-hyprland \
  seatd wlroots qt5-wayland qt6-wayland \
  vulkan-icd-loader vulkan-tools \
  pipewire wireplumber egl-wayland \
  pipewire wireplumber \
  libinput libliftoff libdisplay-info \
  ffmpeg qt5-base qt6-base

# Hyprland
sudo pacman -S hyprland
# Manual compilation
git clone https://github.com/hyprwm/Hyprland
cd Hyprland
make all
sudo make install

# Terminal and basic apps
sudo pacman -S kitty waybar wofi dunst grim slurp \
   xdg-utils xdg-users-dirs
```

- `xdg-desktop-portal-hyprland` se usa para soporte de portales (pantalla compartida, etc.).
- `pipewire` y `wireplumber` activos reemplazan a PulseAudio.
- `kitty`: terminal moderna compatible con GPU.
- `waybar`: barra de estado similar a Polybar.
- `wofi`: lanzador (tipo Rofi para Wayland).
- `dunst`: notificador.
- `grim` + `slurp`: capturas de pantalla.

# Basic enviroment configuration

El archivo `~/.config/hypr/hyprland.conf` será editado para la mayoría de configuraciones que deseemos llevar a cabo.

```bash
mkdir -p ~/.config/hypr
# Once installed hyprland the file /usr/share/hypr/hyprland.conf will be added by default
cp /usr/share/hypr/hyprland.conf ~/.config/hypr/hyprland.conf
```
###### PipeWire and PulseAudio

Para validar que servidor de audio estamos utilizando para saber si instalar `PieWire` podríamos hacer uso del comando:

```bash
ps aux | grep -E "pulseaudio|pipewire"
```

En caso de ver en la salida "*pulseaudio*" deberíamos llevar a cabo la instalación y configuración para activar para el respectivo usuario los servicios del servidor de audio `PipeWire` (Que **Hyprland** hace uso).

```bash
sudo pacman -S pipewire pipewire-audio pipewire-pulse wireplumber
systemctl --user enable --now pipewire pipewire-pulse wireplumber
```
###### Startx

`startx` es un script utilizado parai nciiar entornos gráficos manualmentes desde una consola TTY. Es una capa por encima de `xinit` y tradicionalmente es el encargado de lanzar entoronos gráficos como **X11**.

Ahora en el caso de **Hyprland** no es necesario utilizarlo, para saber si tenemos este binario podríamos lanzar un `which` y en caso de ver una ruta lo tendríamos instalado. En caso de hacer uso de `startx` deberíamos tener en el archivo `~/.xinitrc` la siguiente línea:

```bash
exec Hyprland
```
###### Systemd-logind

Este es un componente de `systemd` que maneja sesiones de usuario, dispositivos (Como teclados, mouse), permisos para acceder a TTYs, etc.

**Hyprland** necesita que el compositor tenga acceso al dispositivo gráfico, lo cual puede ser gestionado por:

- `systemd-logind`: Por defecto en la mayoría de distros modernas.
- `seatd`: Alternativa más livian, útil en entornos minimalistas o sin systemd.

Para saver si hacemos uso de `systemd-longd` podemos hacerlo mediante uno de los siguientes comandos:

```bash
# stdout will be active sessions list
loginctl
# Validate if the service is active
systemctl status systemd-logind
```

> [!warning] NVIDIA Special Considerations
> En caso de hacer uso de una placa de video de NVIDIA, necesitaremos habilitar algunas opciones en el archivo de configuración `~/.config/hypr/hyprland.conf` según lo indicado en la **Hyprland Wiki** en la sección disclaimer sobre [Nvidia con Hyprland](https://wiki.hyprland.org/Nvidia/):
> 
> - env = LIBVA_DRIVER_NAME,nvidia
> - env = XDG_SESSION_TYPE,wayland
> - env = GBM_BACKEND,nvidia-drm
> - env = \_\_GLX_VENDOR_LIBRARY_NAME,nvidia
> - env = WLR_NO_HARDWARE_CURSORS,1
>   
>La línea a continuación es crítica:
>  - exec-once = nvidia-settings --load-config-only
>    
> Adicional a esto, deberíamos ejecutar los siguientes comandos:
> ```bash
>   sudo echo "options nvidia-drm modeset=1" > /etc/modprobe.d/nvidia.conf
>   ```
>   
>   Y por último agregar los valores `nvidia`, `nvidia_modeset`, `nvidia_uvm`, `nvidia-drm` al *HOOK* **MODULES=()** en el archivo de configuración `/etc/mkinitcpio.conf`. Finalmente ejecutar el comando:
>   
>   ```bash
>   sudo mkinitcpio -P
>   ```

----
# Where are you?

Cuando iniciamos nuestra PC y nos aparece un login y luego accedemos a un entorno gráfico, probablemente podríamos estar utilizando un **Display Manager** como lo son `GDM`, `SDDM`, `LigthDM` o alguno similar (En caso de estar haciendo uso de un entorno gráfico como **X11**). Este componente se encarga de iniciar el entorno gráfico gestionar sesiones (Como *Plasma*, *GNOME*, *XFCE*, etc.).

Para verificar que **Display Manager** estamos utilizando podríamos ejecutar el siguiente comando: 

```bash
systemctl status display-manager
```

Esto podría mostrarnos algo como:

```bash
● gdm.service - GNOME Display Manager
● sddm.service - Simple Desktop Display Manager
```

Esto es clave, porque si queremos hacer uso de **Hyprland** *sin Display Manager* (Modo minimalista), lo iniciaremos desde *TTY*. Pero si queremos mantener el *DM* necesitaremos configurar Hyprland como opción válida de sesión gráfica.

----
# Launching Hyprland

###### Without Display Managerr

En caso de querer tener un entorno minimalista sin *Display Manager*, como se menciono anteriormente, se iniciará desde una *TTY*. En este punto lo que deberemos realizar será:

- Cerrar sesiones gráficas.
- Entrar a una TTY (`Ctrl+Alt+F2`).
- Iniciar sesión con usuario deseado.
- Ejecutar:

```bash
Hyprland
```

> Este comando lanzará **Hyprland** *si todo está bien configurado* y tenemos acceso a **Wayland** desde ese contexto.

> [!important] Make *Hyprland* works
> Para que **Hyprland** funcione, es fundamental que `seatd`o `systemd-logind` nos de acceso a `/dev/dri` y otros dispositiovs gráficos. Como se menciono más arriba en este mismo árticulo, si el comando `loginctl` nos devuelve sesiones activas, debería estar bien.
###### With Display Manager

En caso de querer seguir teniendo un *Display Manager* para poder seguir teniendo la opción de un escritorio tradicional deberemos crear un archivo `.desktop` en `/usr/share/wayland-sessions/hyprland.desktop` si no existe, por ejemplo: 

```bash
sudo nano /usr/share/wayland-sessions/hyprland.desktop
```

- Contenido de archivo **hyprland.desktop**:

```ini
Name=Hyprland
Comment=Dynamic tiling Wayland compositor that doesn't suck
Exec=Hyprland
Type=Application
X-GDM-Session-Type=wayland
DesktopNames=Hyprland
```

Luego deberemos cerrar sesion y desde la pantalla de login seleccionaremos como sesión **Hyprland (Wayland)** y luego iniciamos sesión normalmente.

> Si esto funciona, estaremos corriendo **Hyprland** desde nuestro *Display Manager*, lo cual puede ser útil mientras terminamos de configurar todo.

> [!info] Is *Hyprland* running?
> Una vez dentro de la sesión, para saber si *Hyprland* esta corriendo podríamos hacer uso de los siguientes comandos:
> ```bash
> echo $XDG_SESSION_TYPE
> # This should return "wayland"
> 
> echo $XDG_CURRENT_DESKTOP
> # This should return "Hyprland"
> 
> loginctl show-session $(loginctl | grep $(whoami) | awk '{print $1}') -p Type
> # Confirm that the session is "wayland" type
> ```
> 
> Otro comando que podríamos porbar para saber los *monitores conectados* en *Hyprland* es:
> 
> ```bash
> hyprctl monitors
> ```

----
# Hyprland Sintax

El archvo `~/.config/hypr/hyprland.conf` *tiene su propia sintexis declarativa* para configurar *bindings de teclas*, *comporatientos del sistema* de ventanas y demás. En comparación al entorno llevado a cabo con `bspwm` y `sxhkd` ([[Hacking Enviroment (bspwm, sxhkd)]]) `Hyprland` centraliza todo en un único archivo lo cual ofrece ventajas como mayor cohesión y menor dispersión de configuración, lo cual requiere acostrumbrarse a su sintais particular, que es *propietaria del compositor*.
###### Keybind declaration

En **Hyprland**, los *keybindings* se declaran con la siguiente estructura:

```ini
bind = MOD,KEY,COMMAND
```

Donde:

- `MOD`: Pyuede ser `SUPER`, `CTRL`, `ALT`, etc.
- `KEY`: Tecla a bindear, como podría ser `Q`, `Return`, `1`, etc.
- `COMMAND`: Lo que deseemos ejecutar, ya sea comando del sistema o comando interno de *Hyprland*.
###### Keyboard layout configuration

Para configurar en **Hyprland** la distribución de teclado, deberemos establecerlo al estilo *json* en el archivo de configuración:

```json
input {
	kb_layout = latam
}
```

> [!important] Reload the *Hyprland* enviroment
> Un comando que deberemos tener en cuenta en todo el proceso, será el comando `hyprctl` el cual nos permitirá realizar distintos controles a partes de *Hyprland* desde la CLI o script.
> Por lo que tras realizar modificaciones en el archivo de configuración podremos recargar el entorno con el comando `hyprctl reload`.

En caso de que ustedes dispongan de más de un monitor como es mi caso, verán que tras iniciar como se explico previamente, sea sin *Display Manager* o con, probablemente las resoluciones, fps's y posiciones en el eje X e Y estarán erroneas, por lo que para comenzar a configurar todo de una manera más comoda opino que el siguiente paso sería configurar los monitores.

- Formato:
```ini
monitor={name},{resolution}@{herzios},{postion_X}x{position_Y},{scale}
```

Para detectar la actual configuración de los monitores, las posiciones, los nombres, los herzios, la escala y demás utilizaremos el comando `hyprctl monitors`.

Una vez identificados los mismos, en el archivo main de configuración (`~/.config/hypr/hyprland.conf`) agregaremos las lineas necesarias configurando esto. Por ejemplo mi configuración de monitores según mi setup el cual tiene el siguiente formato:

![[Pasted image 20250513205435.png]]

Por lo que luego de probar bastantes alternativas, termine hayando la configuración perfecta para mi setup, se los comparto a modo de ejemplo:

- Lineas en `~/.config/hypr/hyprland.conf`:
```ini
# Left monitor Vertical 60hz
monitor=HDMI-A-1,1920x1080@60,0x-520,1,transform,1

# Main monitor 280hz
monitor=DP-2,1920x1080@280.14,1080x0,1

# Rigth monitor 144hz
monitor=DP-1,1920x1080@144,3000x0,1
```

###### Screenshots

En caso de quere configurar la mejor manera para sacar screenshots en múltiples monitores con *Hyprland* podríamos hacer uso de la herramienta [grimblast](https://aur.archlinux.org/packages/grimblast-git) la cual no esta en los repositorios oficiales de Arch (`extra`, `core`, `community`), por lo tanto `pacman` no logrará encontrar el paquete. En su defecto necesitaremos utilizar un **AUR Helper** (Como podría ser `yay`, `paru`) para intentar instalar paquetes del **AUR** (**Arch User Repository**).

- Instalar `yay` (De los *AUR Helper* más utilizados).
```bash
sudo pacman -S --needed base-devel git
git clone https://aur.archlinux.org/yay.git
cd yay
makepkg -si
```

Una vez que dispongamos de nuestro AUR Helper podremos instalar `grimblast`:

```bash
yay -S grimblast-git
```

Una vez instalado el paquete, podríamos modificar el archivo de configuración de Hyprland para agregar un *keybind* similar al siguiente (En mi caso acostumbro por Windows a utilizar `Alt + ImpPnt` para sacar screeshots con herramientas como `flameshot`o `lightshot`).

```ini
bind = ALT, PRINT, exec, grimblast copy area 
```

Esto podría no darnos resultados, en mi experiencia por la falta de la herramienta [wl-clipboard](https://github.com/bugaevc/wl-clipboard/tree/master). Por lo que procederemos a instalar la misma: 

```bash
# Clone
git clone https://github.com/bugaevc/wl-clipboard.git
cd wl-clipboard
# Build
meson setup build
cd build
ninja
# Install 
sudo meson install
```

- Alternativa: [wlsnarf](https://codeberg.org/notchoc/wlsnarf) :
```bash
git clone https://codeberg.org/notchoc/wlsnarf.git
cd wlsnarf
make
sudo make install
```

inotify-tools

###### Wallpaper

Para utilizar wallpapers animados con una solución funcional en *wayland* utilizaremos la herramienta [swww](https://github.com/LGFae/swww) la cual nos permite utilizar un demonio que corre en tiempo de ejecución.

- Dependencias:
```bash
sudo pacman -S lz4 wlroots rust
```

- Instalación:
```bash
git clone https://github.com/LGFae/swww
cd swww
cargo build --release
sudo cp /target/release/{swww,swww-daemon} /usr/bin
```

Esto nos dejara los binarios `swww` (El cual nos servirá para indicar las imagenes que nos interese) y `swww-daemon` (Demonio que deberá correr para poder utilizar las imagenes como fondo). Finalmente para setear nuestro fonde de pantalla, descargaremos cualquier imagen gif de internet (En caso de querer un fondo animado) y agregaremos las siguientes lineas en el archivo de configuración:

- Agregar linea al `~/.config/hypr/hyprland.conf` para correr cada vez que iniciemos a nuestro entorno el demonio de `swww`:

```bash 
exec-once = swww-daemon &>/dev/null & disown
```
###### Status bar

En mi caso haré uso del proyecto [Waybar](https://github.com/Alexays/Waybar) para llevar a cabo la instalación de la barra en el setup. La configuración utiliza el formato de archivo **JSONC** y se encuentra como `config` o `config.jsonc`.

- Crear directorio de configración:
```bash
mkdir ~/.config/waybar
wget https://raw.githubusercontent.com/Alexays/Waybar/refs/heads/master/resources/config.jsonc -o ~/.config/waybar/config.jsonc
```

- Instalar [Waybar](https://github.com/Alexays/Waybar/):
```bash
sudo pacman -S waybar
```

Una vez instalada la herramienta, podríamos agregar al archivo de configuración la línea: 

```bash
exec-once = waybar &>/dev/null & disown
```

En mi caso haré uso del [proyecto de mechabar](https://github.com/sejjy/mechabar)  para copiar las configuraciones de **waybar** al directorio de configuración (`~/.config/waybar/`).

- Copiar configuración:
```bash
# Dependencies
sudo pacman -S bluez-utils brightnessctl pipewire pipewire-pulse ttf-jetbrains-mono-nerd wireplumber pacman-contrib
# Configuration of the bar
git clone https://github.com/sejjy/mechabar.git
cd mechabar
mkdir -p ~/.config/waybar
cp config.jsonc style.css theme.css ~/.config/waybar
mkdir -p ~/.config/waybar/themes
cp -r themes/* ~/.config/waybar/themes
mkdir -p ~/.config/rofi
cp rofi/* ~/.config/rofi
```
###### Prompt

```bash
sudo pacman -S starship
starship preset tokyo-night -o ~/.config/starship.toml
```

 ###### Image viewer

```bash
sudo pacman -S swayimg
```

```bash
swayimg {path/to/image}
```
###### Launcher

Como **Launcher** y "menú buscador", en lugar de hacer uso de proyectos como *Rofi* haremos uso de su sucesor adaptado para entornos *Wayland*, [Wofi](https://github.com/SimplyCEO/wofi), un programa de menús inspirado en rofi para compositores de wlroots como Sway. Esta diseñado para ser altamente perosnalizable y flexible gracias a estilos *CSS* y un modo *dmenu* que permite una programación ilimitada.

En mi caso utilizaré el siguiente archivo `.css` para ubicar en la sección de `~/.config/wofi`: 

###### Audio Visualizer 

Un visualizador de audio como cava para agregar boludeces la verdad es [Cava](https://github.com/karlstav/cava). 

```bash
sudo pacman -S base-devel fftw alsa-lib iniparser pulseaudio pkgconf
```

En mi caso utilizaré el [proyecto de dotfiles kitties](https://github.com/Pipshag/dotfiles_kitties/)  para copiar las configuraciones de **cava** al directorio a crear *cava*:

```bash
mkdir ~/.config/cava
cp ./dotfiles_kitties/.config/cava/* ~/.config/cava
```

----
