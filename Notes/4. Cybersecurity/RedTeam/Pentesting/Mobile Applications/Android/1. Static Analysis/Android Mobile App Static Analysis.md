# Static Analysis

Como vimos en el apartado de [[Mobile Application Penetration Testing Process]], el análizis estático consiste en analizar la aplicación sin ejecutar la misma, únicamente análisis de código para poder detectar fallas o vulnerabilidades potenciales.

----
# Pulling an APK from Google Play Store

Para descargar aplicaciones desde Google Play Store y obtener el apk directamente desde está fuente, podríamos hacer uso del comando `adb shell` en nuestra [[Android Lab]] para obtener acceso a un dispositivo emulado, una vez en la terminal que nos permite manejar desde CLI este dispositivo, podríamos tener en mente los sigueintes comandos tras la instalación de nuestra aplicación, por ejemplo podría ser **Android Injured**.

```bash
adb shell
pm list packages
pm path {package_name}

adb pull {path} {name_to_save_apk}
``` 

----
# Pushing an APK from our System

En caso de necesitar subir un APK de una aplicación que no esta en la Play Store a nuestro emulador, podríamos hacerlo utilizando `adb` sin necesidad de tener acceso a `adb root`.

Desde una `cmd.exe` podríamos validar los dispositivos que estan siendo emulados con el comando:

```powershell
adb devices
```

En caso de tener más de un dispositivo emulado, con el parametro `-s` podríamos especificar el dispositivo que queremos utilizar, en caso de únicamente tener uno, esto no será necesario.

```powershell
# Push file.apk to /data/local/tmp on emulator-5554
adb -s emulator-5554 push C:\Path\To\Our\File.apk /data/local/tmp
# Push file.apk to /data/local/tmp on our device
adb push C:\Path\To\Our\File.apk /data/local/tmp
```

Una vez subido el archivo APK a la ruta `/data/local/tmp`, simplemente faltaría instalar este.

```powershell
# Install the File.apk
adb shell pm install /data/local/tmp/File.apk
```
###### Failure \[INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries,.......\]

En caso de obtener un error similar a este, esto indica que el APK que estamos intentando instalar contiene bibliotecas nativas que no son compatibles con la arquitectura del emulador Android en el que estamos tratando de instalar la misma.

Para verificar la Arquitectura del Emulador podríamos ejecutar el comando:

```powershell
adb shell getprop ro.product.cpu.abi
```

Este comando, nos dirá cuál es la arquietcuta del CPU del emulador (Podría ser **x86**, **armeabi-v7a**, **arm64-v8a**, etc.).

De igual manera, para verificar la Arquitectura del APK podríamos utilizar herramientas como `aapt` (Que vieene con Android SDK) la cual nos permitirá verificar las arquitecturas soportadas por el APK.

```powershell
aapt dump badging C:\Path\To\Our\File.apk
```

La solución a esto, en caso de que realmente no sean compatibles por las arquitecturas es, o descargar una versión compatible del APK, o emular un dispositivo con una arquitectura soportada por el APK.

----
# APK Decompiling

Haciendo uso de la herramienta `Jadx` instalada, podríamos hacer uso de la GUI (`jadx-gui`) para visualizar la estructura de directorios de un apk, o con el comando `jadx {C:\path\to\file.apk}` intentar descompilar el apk y tener una estructura de directorios con todo lo que contenía el apk.

Visualización de jadx-gui tras la ejecución del comando `jadx-gui {C:\path\to\file.apk}`: 

![[jadx_gui_example.png]]

También podríamos hacer uso de la herramienta `Apktool` la cual intenta realizar esta misma tarea de descompilar el *.apk* con el comando `apktool d {C:\path\to\file.apk}`

```bash
# Try decompile apk using jadx
jadx C:\Users\dobliuw\AndroidStudio\project\base.apk
# Try decompile apk using apktool
apktool d C:\Users\dobliuw\AndroidStudio\project\base.apk
```

Si bien ambas herramientas se uitilizan para lo mismo, hay algunas diferencias que podemos tener en cuenta a la hora de elegir cual usar y en que contexto hacerlo:

**jadx**
 - La principal característica de `jadx` es que descompila directamente los archivos DEX en código *Java* legible. Esto facilita la lectura y comprensión del código fuente de una aplicación.
 - A su vez, proporciona una interfaz gráfica (`jadx-gui`) que permite explorar el c´dogio fuente de la aplicación de manera más intuitiva.
 - Es ideal para quellos que buscan analizar la lógica del código fuente de una aplicación Android y comprender cómo funciona a nivel de Java. Es más útil cuando el objetivo es entedner el comportamiento de la aplicación o buscar vulnerabilidades de seguridad a nivel más alto.

**apktool**
- Cuando descompilamos un APK con `apktool`, obtenemos archivos *Smali*, que son más bajos en nivel que Java y representan instrucciones de bytecode.
- A su vez, nos permite modificar lso recursos de la aplicación (Como XML, imágenes, etc.) y volver a empaquetar (Recompilar) el APK con los cambios realizados.
- Es excelente para trabajar con los recursos de una aplicación, como archivos de condiguración XML, imágenes y otros recursos empaquetados dentro de APK, así como particularmente útil cuando necesitamos modificar partes del APK que no son partes directamente el código fuente Java, como los recursos y configuraciones de la aplicación. Es usado comúnmente en la ingeniería inversa para personalizar aplicaciones y análisis de malware.

De igual manera podríamos hacer uso de herramientas como `dex2jar` o `smali2java` para convertir los archivos *smali* a *java*.

- [dex2jar](https://github.com/pxb1988/dex2jar): Es una herramienta que convierte archivos DEX (Contenidos en un APK) a archivos JAr. Este es un paso intermedio que puede ser útil en el proceso de conversión de Smali a Java. Una vez que tengamos el archivo JAR, podríamos hacer uso de un descompilador de java para obtener el código fuente.
```bash
dex2jar {file.dex}
```

- [smali2java](https://github.com/AlexeySoshin/smali2java): Herramienta específica para convertir código Smali a Java. Aunque no es perfecta y no siempre produce un código Java limpio y funcional, puede ser útil como un primer paso para la conversión.
```bash
smali2java -path_to_smali={smali_directoriy}
```

----
# [AndroidManifest.xml](https://developer.android.com/guide/topics/manifest/manifest-intro)

El archivo `AndroidManifest.xml` es un componente esencial de cualquier aplicación Android. Define la estructura básica y las características de la aplicación. Este archivo se encuentra dentro del paquete APK (Android Package) y contiene información crucial que el sistema operativo Android necesita para ejecutar la aplicación correctamente.

Este describe los elementos fundamentales de la aplicación Android. Actúa como un contrato entre la aplicación y el sistema operativo Android, proporcionando información sobre la aplicación, sus componpentes y sus permisos necesarios.

Este archivo dispone de varias secciones claves:

**Package information**:
-  Define el nombre del paquete de la aplicación y la versión (**package,** **versionCode** y **versionName**).

**Application components**:
- *Activity*: Define las actividades (pantallas) de la aplicación. Cada actividad se declara con el elemento `<activity>`.
- *Service*: Declara los servicios que la aplicación utiliza. Los servicios son componentes que pueden ejecutarse en segundo plano.
- *Broadcast Receiver*: Declara los receptores de difusión, que permiten a la aplicación responder a mensajes del sistema o de otras aplicaciones.
- *Content Provider*: Declara los proveedores de contenido, que gestionan el acceso a un  conjunto estructurado de datos. Si los proveedores de contenido son exportados, esto podría suponer un gran riesgo dado que podría exponer datos a cualquier usuario o aplicación en el dispositivo.

**Permissions**:
- Específica los permisos que la aplicación necesita para funcionar correctamente, como el acceso a la red, ubicación, cámara, etc, usando el elemenot `<uses-permissions>`.

**Hardware and Software features**:
- Declara los requsiitos de hardware y software de la aplicación mediante elementos como `<user-feature>` y `<uses-sdk>`.

**Intents and Filters**:
- Define las intenciones (`<intent-filters>`) que permiten que la aplicación responda a diferentes tipos de acciones y datos. Los filtros de intenciones se utilizan dentro de componentes como actividades y receptores de difusión.

**Metadata**:
- Proporciona información adicional sobre la aplicación que puede ser utilizada por el sisetma o por otras aplicaciones mediante el elemento `<meta-data>`.

*Ejemplo* básico de `AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"
    android:versionCode="1"
    android:versionName="1.0">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <service android:name=".MyService" />
        
        <receiver android:name=".MyBroadcastReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
```

En este ejemplo podemos visualizar que:

- La **Raíz** (`<manifest>`) define el paqeute y las versiones de la aplicación.
- Los **Permisos** (`<user-permission>`) decalra permisos para acceso a Internet y ubicación precisa.
- La **Aplicación** (`<application>`) contiene elementos como el icono, la etiqueta y el tema de la aplicación.
- La **Actividad** (`<activity>`) declara una actividad llamada `MainActivity` como un filtro de intención que la define como la actividad principal (*launcher*).
- El **Servicio** (`<service>`) declara un servicio llamado `MyService`.
- El **Receptor de difusión** (`<receiver>`) declara un receptor de difusión que responde a la acción `BOOT_COMPLETED`. 

Sin el archivo `AndroidManifest.xml`, el sistema operativo Android no sabría qué componentes existen en la aplicación no cóomo interactuar con ellos, a su vez, garantiza que la aplicación solicitará los permisos necesarios para funcionar correctamente, manteniendo la seguridad y privacidad del usuario, así como también definirá cómo deberá ejectuarse la aplicación, incluyendo confiraciones de temas, filtros de intenciones y metadatos específicos. Además especificará las versiones de SDK (Software Development Kit) comptaibles y las características de hardware/software necesarias, asegurando que la aplicación se ejecute en dispositivos compatibles.

----
# Common Application Strings

En el pentesting de aplicaciones móviles, las cadenas de texto comunes pueden sernos de gran ayuda para identificar vulnerabilidades y entender el comportamiento de la aplicación. Algunas veces podemos encontrar strings hardcodeadas en el recurso `resources/strings.xml` o también en el recurso `xml.xml`.
###### Tokens and Credentials
Buscar de manera recursiva en la estructura del APK por **contraseñas** y **API keys** con palabras claves como *password*, *passwd*, *pwd*, *api_key*, *api_secret*, *token*, *auth_token*, *creds*, *credentials*, etc.
Para buscar **tokens de sesión** podríamos buscar palabras como *session_id*, *sessión_token*, etc.

###### Environments and Configurations
Para buscar **URLs de desarrollo** y **producción** o **URLs de Firebase** : *dev_url*, *prod_url*, *staging_url*, *base_url*, *dev_uri*, *firebase*, etc.
Para buscar **Configuraciones de base de datos**: *db_user*, *db_pass*, *db_pwd*, *db_password*, *db_host*, *db_name*, etc.

###### Security Information
Para **Certificados** y **Claves Criptográficas** por palabras como *certificate*, *private_key*, *public_key*, *ca_cert*, *pem*, etc.
Para **Configuraciones de cifrado**: *encryption_key*, *cipher*, *crypto*, etc.

###### User Information and Personal Data
Para **Detalles de Usuario**: *username*, *email*, *user_id*, *phone*, *address*, etc.
Para **Datos personales**: *ssn*, *dob*, *credit_card*, *cc_number*, etc.

###### Errors and Logs
Para **Mensajes de Error** y **Depuración**: *error_message*, *debug*, *log*, *exception*, *stack_trace*, etc.
Para **Rutas de archivos** y **sistema**: *file_path*, *dir_path*, *tmp_path*, *temp_file*, etc.

###### API and Services
Para **Endpoints de API**: *api_endpiont*, *api_url*, *api_uri*, *service_url*, etc.
Para **Headers de Autenticación**: *Authorization*, *Bearer*, *Basic*, etc.

###### Network Configuration and Security
Para **Configuraciones de Proxy**: *proxy_host*, *proxy_port*, *proxy_user*, *proxy_pass*, etc.
Para **Configuraciones de Red**: *network_config*, *ip_address*, *port*, etc.

###### Application configuration
Para **Configuraciones Generales**: *config*, *settings*, *preferences*, etc.
Para **Opciones de Desarrollor**: *debug_mode*, *verbose*, *trace*, etc.

###### Autentication Flows
Para **OAuth y OpenID**: *oauth*, *openid*, *client_id*, *client_secret*, *redirect_uri*, etc.
Para **Tokens JWT**: *jwt*, *jwt_token*, *jwt_secret*, etc.

###### Others
Para la búsqueda de posibles **palabras claves sensibles** podríamos hacer uso de palabras como *secret*, *key*, *private*. *confidential*. *internal_use_only*, etc.

```bash
# Find for password or pwd or passwd or.... in recursive mode 
grep -rE "password|pwd|passwd|api|..." ./
# Find the string password in a strings of a file
strings {file} | grep "password"
# Find for IPv4 address using regex
grep -rE "((0-9){1,3}\.)(0-9){1,3}" ./
# Find for IPv6 address using regex
grep -rE "([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}" ./
# Find for URLs using regex
grep -rE "https?://[a-zA-Z0-9./?=_-]*" ./
# Find for EMAILS using regex
grep -rE "[a-zA-Z0-9_%+-]+@[a-z]+\.[a-zA-Z]{2,}" ./
# Find for credit card numbers using regex
grep -rE "([0-9]{4}[- ]?){3}[0-9]{4}" ./
# Find for MAC addresses using regex
grep -rE "([0-9a-zA-Z]{2}:){5}[0-9a-zA-Z]{2}" ./
``` 

Tener en cuenta ciertas funcionalidades de grep como las enumeradas abajo nos puede ayudar a personalizar mucho más nuestra búsqueda pudiendo visualizar conexto, líneas exactas del hallazgo, únicamente los archivos, etc:

- `-C {number}`: Mostrara {numbers} líneas de contexto antes y después de las coincidencias.
- `-n`: Numerar las líneas en las que se encuentra las coincidencias.
- `-i`: Ignorar mayúscualas y minúsculas.
- `-l`: Mostrar solo nombes de archivos con las coincidencias.

----
# Exported activities

En el contexto de desarrollo de aplicaciones Android, una **Activity** es uno de los componentes más fundamentales. Representa una sola pantalla con una interfaz de usuario (UI) en una aplicación. Las actividades permiten a los usuarios interactuar con la aplicacióin, proporcionando una ventana a través de la cual se puede realizar acciones y ver información.

En Android, una **exported activity** es una actividad (*Activity*) qee está configurada para ser accesible por otras aplicaciones, además de la aplicación en la que está definida. Esto se controla mediante el atributo `exported` en el archivo `AndroidManifest.xml`. En este archivo, las actividades se defiene dentro de la etiqueta `<application>`. Cada actividad puede incluir el atributo `android:exported`, que puede tener los valores **true** o **false**.

- `android:exported="true"`: La actividad es accesible por otras aplicaciones. Esto significa que otras aplicaciones pueden lanzar esta actividad utilizando un **Intent**.
- `android:exported="false"`: La actividad es privada a la aplicación y no puede ser lanzada por otras aplicaciones.

- Ejemplo:

En este caso estaremos utilizando el repositorio de [Android Injured](https://github.com/B3nac/InjuredAndroid) para poder practicar y llevar a cabo distintos tipos de vulnerabilidades, en este caso haremos uso de la segunda flag la cual abusa de una actividad exportada.

```powershell
type AndroidManifest.xml | findstr /R "<activity.*android:exported=\"true\""
```

Esto filtraría por aquellas actividades encontradas en el `AndroidManifest.xml` que esten exportadas, una vez localizada alguna de nuestro interes, para ejmplo práctico usaremos `<activity android:exported="true" android:name="b3nac.injuredandroid.b25lActivity"/>`, podríamos ejecutar esta actividad con el comando:

```powershell
# From a shell in our device start an activity from AM (Activity Manager)
adb shell am start b3nanc.injuredandroid/.b25lActivity
```

Con el ejemplo de la actividad `b3nanc.injuredandroid.b25lActivity`, es importante tener en cuenta que la sintaxís para ejecución de la actividad sería `{package_name}/{activity_class}`, en este caso, **b3nanc.injuredandroid** es el nombre del paquete de la aplicación, y **.b25lActivity** es el nombre de la actividad que se quiere iniciar. La barra (*/*) separa estos dos componentes.

Otros usos comunes del *Activity Manager* (`am`), son enviar un broadcast a todas las aplicaciones registradas para recibirlo, es decir la distribución de un mensaje a todos los componentes de aplicaciones que se han regristrado par recibir ese tipo específico de mensaje, así como también iniciar un servicio específico o detener el mismo.

```powershell
# Send a broadcast to all applications
am broadcast -a android.intent.action.BOOT_COMPLETED
# Start a service
am startservice -n com.example.myapp/.MyService
# Stop a service
am stopservice -n com.example.myapp/.MyService
```

----
# AWS Storage Buckets

Muchas veces en los buckets se suelen almacenar datos sensibles y configuraciones curcuales. Las aplicaciones móviles a menudo almacenan recursos como imágenes, videos y archivos de configuración en AWS S3, y si no están adecuadamente protegidos, pueden ser vulnerables a ataques como acceso no autorizado y filtraciones de datos. Explorar estas debilidades permite identifcar y obtener potenciales vías para la obtención de recursos sensibles que puedan ayudarnos en nuestro pentesting a aplicaciónes móviles.

Por lo mencionado, es más que interesante hacer búsqueda en archivos como `AndroidManifest.xml` u otros como propios archivos `.java` de strings hardcoded de *AWS IDs* y *AWS Secrets* en estos archivos, tanto el ID como el Secret son pedidos que nos realizara herramientas como `aws` para la configuración de un **profile** que nos permita comunicarnos con el *bucket* de Amazon.

Podemos hacer uso de herramientas como [Cloud Enum](https://github.com/initstring/cloud_enum) la cual realizaría enumeración de distintos tipos de servicios en la nube como recursos de Amazon (Buckets, WorkMail, WorkDocs, etc.) así como también recursos de Microsoft Azure (VMs, Hosted DBs, Storage Accounts, etc.) y plataformas de Google Cloud (GCP Buckets, Firebase Realtime DBs, etc.).

```bash
# Download the tool
git clone https://github.com/initstring/cloud_enum
cd cloud_enum
# Install all dependencies
pip3 install -r requeriments.txt
# Execute the scanning 
python3 cloud_enum.py -k {dns}
```

A su vez, como mencionamos antes, con la herramienta `aws` se podrá realizar la configuración de perfiles (Basandonos en un AWS ID y AWS Secret) los cuales en caso de haber encontrado nos permitiría comunicarnos con, por ejemplo, un bucket previamente enumerado con la herramienta `cloud_enum` o mismo en caso de que la URL del Bucket también pueda haber sido localizada en alguna parte del código de nuestra herramienta.

```bash
# Install aws command line interface
sudo apt-get install awscli
# Configure a profile with a specific name
aws profile configure --profile {profile_name}
```

Una vez ejecutado el comando anterior, se nos consultaran las configuraciones deseadas para el determinado perfile que estamos intentando crear, siendo estas cuatro, primero el **WAS Access Key ID**, luego el **AWS Secret Access Key**, posteriormente el **region name** y **output format**. Una vez realizada esta configuración se nos creara el perfil con estas configuraciones bajo el nombre especificado.

Una vez en este punto podríamos hacer consultas al Bucket S3 desde la terminal con este perfile configurado:

```bash
# List a bucket contento using a specific profile 
aws s3 ls s3://{dns} --profile {profile_name}
```

Recurso: [AWS CLI Documentation]([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/))

---
# Firebase Databases

*Firebase* es una plataforma en la nube para el desarrollo de aplicaciones web y móviles. Una de las herramientas más destacadas y esenciales de Direbase son las bases de datos  en tiempo real (Realtime Database). Estas se alojan en la nube, son NoSQL y almacenan los datos como JSON. 
Que firebase permita alojar y disponer de los datos e información de la aplicación en tiempo real, mateniéndolos actualizados aunque el usuario no realice ninguna acción, significa que firebase envía automáticamente eventos a las aplicaciones cuando los datos cmabian, almacenando los datos nuevos en el disco. AUnque no hubiera conexión por parte de un usuario, sus datos estarían disponibles para el resto y los cambios realizados se sincronizarían una vez restablecida la conexión.

De igual manera que pasa con **AWS Storage Buckets**, pasa con **Firebase**, por lo que se vuelve más que interesante hacer búsquedas en código o archivos `.xml` en endpoints relacionados a las bases de datos de Firebase. Muchas veces, existen bases de datos enteras y endpoints específicos los cuales no contienen protección.

Existen herramientas como [Firebase Enum]([ttps://github.com/Sambal0x/firebaseEnum](https://github.com/Sambal0x/firebaseEnum)) las cuales nos pueden permitir realizar reconocimiento de posibles endpoints en bases de datos de Firebase, de igual manera, puede ser que hayamos dado con una URL de una base de datos de Firebase junto con sirectorios y haciendo uso de `curl` o un navegador, podríamos dirgirnos a la misma.

```bash
curl -s -X GET https://{firebase_database_url}/{endpoints_paths}/.json
```

----
# MobSF (Automated Tool)

[MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF) es una herramienta que se puede encontrar en github la cual nos permite realizar este proceso de análisis estatico (Así también como el de [[Android Mobile App Dynamic Analysis]] ) de manera automatizada y con una GUI la cual nos brinda herramientas y secciones muy poderosas e interesantes. Esta herramienta puede ser utilizada para la búsqueda de posibles actividades sospechosas en posibles APK que son malware.

MobSF trae consigo la posibilidad de generar un reporte técnico de manera automatica, para lo cual necesitaremos de [wkhtmltopdf](https://wkhtmltopdf.org/downloads.html).
