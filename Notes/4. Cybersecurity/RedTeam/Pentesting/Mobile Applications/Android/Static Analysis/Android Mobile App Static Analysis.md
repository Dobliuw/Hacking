# Static Analysis

Como vimos en el apartado de [[Mobile Application Penetration Testing Process]], el análizis estático consiste en analizar la aplicación sin ejecutar la misma, únicamente análisis de código para poder detectar fallas o vulnerabilidades potenciales.

----
# Pulling an APK from Google Play Store

Para descargar aplicaciones desde Google Play Store y obtener el apk directamente desde está fuente, podríamos hacer uso del comando `adb shell` en nuestra [[Android Lab]] para obtener acceso a un dispositivo emulado, una vez en la terminal que nos permite manejar desde CLI este dispositivo, podríamos tener en mente los sigueintes comandos tras la instalación de nuestra aplicación, por ejemplo podría ser **Android Injured**.

```bash
adb shell
pm list packages
pm path {package_name}

adb pull {path} {name_to_save_apk}
``` 

----
# APK Decompiling

Haciendo uso de la herramienta `Jadx` instalada, podríamos hacer uso de la GUI (`jadx-gui`) para visualizar la estructura de directorios de un apk, o con el comando `jadx {C:\path\to\file.apk}` intentar descompilar el apk y tener una estructura de directorios con todo lo que contenía el apk.

Visualización de jadx-gui tras la ejecución del comando `jadx-gui {C:\path\to\file.apk}`: 

![[jadx_gui_example.png]]

También podríamos hacer uso de la herramienta `Apktool` la cual intenta realizar esta misma tarea de descompilar el *.apk* con el comando `apktool d {C:\path\to\file.apk}`

```bash
# Try decompile apk using jadx
jadx C:\Users\dobliuw\AndroidStudio\project\base.apk
# Try decompile apk using apktool
apktool d C:\Users\dobliuw\AndroidStudio\project\base.apk
```

Si bien ambas herramientas se uitilizan para lo mismo, hay algunas diferencias que podemos tener en cuenta a la hora de elegir cual usar y en que contexto hacerlo:

**jadx**
 - La principal característica de `jadx` es que descompila directamente los archivos DEX en código *Java* legible. Esto facilita la lectura y comprensión del código fuente de una aplicación.
 - A su vez, proporciona una interfaz gráfica (`jadx-gui`) que permite explorar el c´dogio fuente de la aplicación de manera más intuitiva.
 - Es ideal para quellos que buscan analizar la lógica del código fuente de una aplicación Android y comprender cómo funciona a nivel de Java. Es más útil cuando el objetivo es entedner el comportamiento de la aplicación o buscar vulnerabilidades de seguridad a nivel más alto.

**apktool**
- Cuando descompilamos un APK con `apktool`, obtenemos archivos *Smali*, que son más bajos en nivel que Java y representan instrucciones de bytecode.
- A su vez, nos permite modificar lso recursos de la aplicación (Como XML, imágenes, etc.) y volver a empaquetar (Recompilar) el APK con los cambios realizados.
- Es excelente para trabajar con los recursos de una aplicación, como archivos de condiguración XML, imágenes y otros recursos empaquetados dentro de APK, así como particularmente útil cuando necesitamos modificar partes del APK que no son partes directamente el código fuente Java, como los recursos y configuraciones de la aplicación. Es usado comúnmente en la ingeniería inversa para personalizar aplicaciones y análisis de malware.

De igual manera podríamos hacer uso de herramientas como `dex2jar` o `smali2java` para convertir los archivos *smali* a *java*.

- [dex2jar](https://github.com/pxb1988/dex2jar): Es una herramienta que convierte archivos DEX (Contenidos en un APK) a archivos JAr. Este es un paso intermedio que puede ser útil en el proceso de conversión de Smali a Java. Una vez que tengamos el archivo JAR, podríamos hacer uso de un descompilador de java para obtener el código fuente.
```bash
dex2jar {file.dex}
```

- [smali2java](https://github.com/AlexeySoshin/smali2java): Herramienta específica para convertir código Smali a Java. Aunque no es perfecta y no siempre produce un código Java limpio y funcional, puede ser útil como un primer paso para la conversión.
```bash
smali2java -path_to_smali={smali_directoriy}
```

----
# [AndroidManifest.xml](https://developer.android.com/guide/topics/manifest/manifest-intro)

El archivo `AndroidManifest.xml` es un componente esencial de cualquier aplicación Android. Define la estructura básica y las características de la aplicación. Este archivo se encuentra dentro del paquete APK (Android Package) y contiene información crucial que el sistema operativo Android necesita para ejecutar la aplicación correctamente.

Este describe los elementos fundamentales de la aplicación Android. Actúa como un contrato entre la aplicación y el sistema operativo Android, proporcionando información sobre la aplicación, sus componpentes y sus permisos necesarios.

Este archivo dispone de varias secciones claves:

**Package information**:
-  Define el nombre del paquete de la aplicación y la versión (**package,** **versionCode** y **versionName**).

**Application components**:
- *Activity*: Define las actividades (pantallas) de la aplicación. Cada actividad se declara con el elemento `<activity>`.
- *Service*: Declara los servicios que la aplicación utiliza. Los servicios son componentes que pueden ejecutarse en segundo plano.
- *Broadcast Receiver*: Declara los receptores de difusión, que permiten a la aplicación responder a mensajes del sistema o de otras aplicaciones.
- *Content Provider*: Declara los proveedores de contenido, que gestionan el acceso a un  conjunto estructurado de datos. Si los proveedores de contenido son exportados, esto podría suponer un gran riesgo dado que podría exponer datos a cualquier usuario o aplicación en el dispositivo.

**Permissions**:
- Específica los permisos que la aplicación necesita para funcionar correctamente, como el acceso a la red, ubicación, cámara, etc, usando el elemenot `<uses-permissions>`.

**Hardware and Software features**:
- Declara los requsiitos de hardware y software de la aplicación mediante elementos como `<user-feature>` y `<uses-sdk>`.

**Intents and Filters**:
- Define las intenciones (`<intent-filters>`) que permiten que la aplicación responda a diferentes tipos de acciones y datos. Los filtros de intenciones se utilizan dentro de componentes como actividades y receptores de difusión.

**Metadata**:
- Proporciona información adicional sobre la aplicación que puede ser utilizada por el sisetma o por otras aplicaciones mediante el elemento `<meta-data>`.

*Ejemplo* básico de `AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"
    android:versionCode="1"
    android:versionName="1.0">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <service android:name=".MyService" />
        
        <receiver android:name=".MyBroadcastReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
```

En este ejemplo podemos visualizar que:

- La **Raíz** (`<manifest>`) define el paqeute y las versiones de la aplicación.
- Los **Permisos** (`<user-permission>`) decalra permisos para acceso a Internet y ubicación precisa.
- La **Aplicación** (`<application>`) contiene elementos como el icono, la etiqueta y el tema de la aplicación.
- La **Actividad** (`<activity>`) declara una actividad llamada `MainActivity` como un filtro de intención que la define como la actividad principal (*launcher*).
- El **Servicio** (`<service>`) declara un servicio llamado `MyService`.
- El **Receptor de difusión** (`<receiver>`) declara un receptor de difusión que responde a la acción `BOOT_COMPLETED`. 

Sin el archivo `AndroidManifest.xml`, el sistema operativo Android no sabría qué componentes existen en la aplicación no cóomo interactuar con ellos, a su vez, garantiza que la aplicación solicitará los permisos necesarios para funcionar correctamente, manteniendo la seguridad y privacidad del usuario, así como también definirá cómo deberá ejectuarse la aplicación, incluyendo confiraciones de temas, filtros de intenciones y metadatos específicos. Además especificará las versiones de SDK (Software Development Kit) comptaibles y las características de hardware/software necesarias, asegurando que la aplicación se ejecute en dispositivos compatibles.

----
# Common Application Strings

En el pentesting de aplicaciones móviles, las cadenas de texto comunes pueden sernos de gran ayuda para identificar vulnerabilidades y entender el comportamiento de la aplicación. Algunas veces podemos encontrar strings hardcodeadas en el recurso `resources/strings.xml` o también en el recurso `xml.xml`.
###### Tokens and Credentials
Buscar de manera recursiva en la estructura del APK por **contraseñas** y **API keys** con palabras claves como *password*, *passwd*, *pwd*, *api_key*, *api_secret*, *token*, *auth_token*, *creds*, *credentials*, etc.
Para buscar **tokens de sesión** podríamos buscar palabras como *session_id*, *sessión_token*, etc.

###### Environments and Configurations
Para buscar **URLs de desarrollo** y **producción** o **URLs de Firebase** : *dev_url*, *prod_url*, *staging_url*, *base_url*, *dev_uri*, *firebase*, etc.
Para buscar **Configuraciones de base de datos**: *db_user*, *db_pass*, *db_pwd*, *db_password*, *db_host*, *db_name*, etc.

###### Security Information
Para **Certificados** y **Claves Criptográficas** por palabras como *certificate*, *private_key*, *public_key*, *ca_cert*, *pem*, etc.
Para **Configuraciones de cifrado**: *encryption_key*, *cipher*, *crypto*, etc.

###### User Information and Personal Data
Para **Detalles de Usuario**: *username*, *email*, *user_id*, *phone*, *address*, etc.
Para **Datos personales**: *ssn*, *dob*, *credit_card*, *cc_number*, etc.

###### Errors and Logs
Para **Mensajes de Error** y **Depuración**: *error_message*, *debug*, *log*, *exception*, *stack_trace*, etc.
Para **Rutas de archivos** y **sistema**: *file_path*, *dir_path*, *tmp_path*, *temp_file*, etc.

###### API and Services
Para **Endpoints de API**: *api_endpiont*, *api_url*, *api_uri*, *service_url*, etc.
Para **Headers de Autenticación**: *Authorization*, *Bearer*, *Basic*, etc.

###### Network Configuration and Security
Para **Configuraciones de Proxy**: *proxy_host*, *proxy_port*, *proxy_user*, *proxy_pass*, etc.
Para **Configuraciones de Red**: *network_config*, *ip_address*, *port*, etc.

###### Application configuration
Para **Configuraciones Generales**: *config*, *settings*, *preferences*, etc.
Para **Opciones de Desarrollor**: *debug_mode*, *verbose*, *trace*, etc.

###### Autentication Flows
Para **OAuth y OpenID**: *oauth*, *openid*, *client_id*, *client_secret*, *redirect_uri*, etc.
Para **Tokens JWT**: *jwt*, *jwt_token*, *jwt_secret*, etc.

###### Others
Para la búsqueda de posibles **palabras claves sensibles** podríamos hacer uso de palabras como *secret*, *key*, *private*. *confidential*. *internal_use_only*, etc.

```bash
# Find for password or pwd or passwd or.... in recursive mode 
grep -rE "password|pwd|passwd|api|..." ./
# Find the string password in a strings of a file
strings {file} | grep "password"
# Find for IPv4 address using regex
grep -rE "((0-9){1,3}\.)(0-9){1,3}" ./
# Find for IPv6 address using regex
grep -rE "([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}" ./
# Find for URLs using regex
grep -rE "https?://[a-zA-Z0-9./?=_-]*" ./
# Find for EMAILS using regex
grep -rE "[a-zA-Z0-9_%+-]+@[a-z]+\.[a-zA-Z]{2,}" ./
# Find for credit card numbers using regex
grep -rE "([0-9]{4}[- ]?){3}[0-9]{4}" ./
# Find for MAC addresses using regex
grep -rE "([0-9a-zA-Z]{2}:){5}[0-9a-zA-Z]{2}" ./
``` 

Tener en cuenta ciertas funcionalidades de grep como las enumeradas abajo nos puede ayudar a personalizar mucho más nuestra búsqueda pudiendo visualizar conexto, líneas exactas del hallazgo, únicamente los archivos, etc:

- `-C {number}`: Mostrara {numbers} líneas de contexto antes y después de las coincidencias.
- `-n`: Numerar las líneas en las que se encuentra las coincidencias.
- `-i`: Ignorar mayúscualas y minúsculas.
- `-l`: Mostrar solo nombes de archivos con las coincidencias.