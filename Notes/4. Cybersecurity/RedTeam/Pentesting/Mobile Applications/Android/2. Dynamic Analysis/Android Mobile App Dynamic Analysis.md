# Dynamic Analysis

Como vimos en el apartado de [[Mobile Application Penetration Testing Process]], el análizis dinámico consiste en analizar la aplicación ejecutando la misma, interactuando con sus funcionalidades para poder entender que hace, cuando, como, etc.

---
# SSL Pinning

*SSL Pinning* es una metodología de seguridad utilizada para asegurar que el tráfico de la aplicación no esta siendo interceptado (MITM) asegurando que la aplicación solo se comunique con un servidor específico mediante certificados SSL conocidos. Al implementar SSL Pinning, la aplicación almacena de manera interna uno o más certificados de los servidores confiables y los compara con los certificados recibidos durante la conexión SSL/TLS. Si no coincide, la conexión se rechaza, mitigando el riesgo de interceptación y manipulación de datos por parte de atacantes que intentan usar certificados falsificados o comprometidos.

Ejemplo de implementación de SSL Pinning en Android haciendo uso de OkHttp:
```java
OkHttpClient client = new OkHttpClient.Builder()
    .certificatePinner(new CertificatePinner.Builder()
        .add("{yourdomain.com}", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
        .build())
    .build();
```

Como pentesters, conocer este método de seguridad nos es fundamental para saber a que problema nos estamos pudiendo enfrentar en caso de tener erorres así como a su vez, intentar sortear el msimo.

En muchos casos, podríamos intentar evadir o seactivar el SSL Pinning para poder así analizar el tráfico de la aplicación. Esto puede inlcuir téncicas como por ejemplo:
 - **Repackage the App**: Modificar el código de la aplicación para eliminar o deshabilitar el pinning.
 - **Dynamic Instrumentation**: Usar herramientas como *Frida* o *Xposed* para interceptar y modificar funciones en tiempo de ejecución.
```javascript
Java.perform(function() {
    var CertificatePinner = Java.use("okhttp3.CertificatePinner");
    CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function() {
        // Skip SSL Pinning
        console.log("Bypassing SSL Pinning");
    };
});
```
 - **MITM Proxies**: Hacer uso de proxies especializados como [[Burpsuite]] con plugins específicos que pueden deshabilitar el pinning en tiempo real.

----
# MobSF

Una vez más, como se menciono en la sección de [[Android Mobile App Static Analysis]], podemos hacer uso de la herramient [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF) la cual nos permite configurar y llevara a cabo de manera automatizada el análisis dinámico de una App. Para esto deberemos realizar alguans configuraciones las cuales están detalladas en esta [guií de configuración de análisis dinámico en MobSF](https://mobsf.github.io/docs/#/dynamic_analyzer?id=genymotion-android). 

----
# Using [[Burpsuite]]

*Burpsuite* sin duda será una herramienta la cual utilizaremos también en este tipo de pentesting a aplicaicones móviles, configuraremos un nuevo proxy abierto a todas las interfaces, descargaremos el certificado, lo subiremos e instalaremos en el apartado de *Security* del telefono móvil y posteriormente configuraremos el *Android Studio* con el proxy creado.

1. Crear el proxy en [[Burpsuite]]:

![[creating_a_new_proxy_burpsuite.png]]

2.  Una vez creado el proxy, la siguiente opción sería la de *Import / export CA certificate*, donde presionaremos la opción de exportar certificado en formato DER (*Certificate in DER format*) en el apartado de *Export*:

![[export_certificate_bupsuite.png]]

3. Una vez descargado el mismo, nos debemos asegurar en cambiar la extensión a **.cer**, una vez guardado, simplemente arrastramos con el mouse el certificado al emulador para subirlo al dispositivo. En caso de tener un dispositivo real conectado o desear hacerlo desde línea de comandos, podemos hacerlo con herramientas como `adb`:

```powershell
> adb push C:\Path\To\Downloaded\Certificate.cer /sdcard/
```

Para que esto funcione, además de lo mencionado en [[Android Lab configs and tips#Enabling Developer Options]], deberíamos subir/mover el certificado (Archivo **.cer**) a un directorio accesible por el usuario, en este caso `/sdcard/` es uno, pero podría ser `/sdcard/Documents`,`/sdcard/Downloads`, etc.

4. Tras la subida del certificado al dispositivo, estamos con la posibilidad de hacer uso de este para que las conexiones SSL con [[Burpsuite]] sean posibles. Según el modelo de dispositivo el camino para instalar certificados suele cambiar pero de igual manera suele ser bastante similar al que se demuestra  como ejemplo, ir a `Security > Encryption & credentials > Install a certificate > CA certificate`

![[encription_and_credentials_android.png|150]] ![[install_a_certificate_android.png|157]] ![[ca_certificate_android.png|150]] ![[sdcard_directory_from_import_cert_android.png|150]] 

5. Una vez subido e instalado el certificado en el dispositivo móvil, simplemente faltaría realizar la configuración, en este caso, en nuestra aplicación *Android Studio*:

![[android_studio_burpsuite_settings.png]]

Para otros sistemas operativos, como macOS, podríamos hacer uso de otras opciones ante Burpsuite, como por ejemplo [Proxyman](https://docs.proxyman.io/). 

---
# [Frida](https://frida.re/docs/android/)

**Frida** es una herramienta poderosa para la ingeniería inversa y la seguridad de aplicaicones que permite la inyección de scripts en aplicaciones en tiempo real. Es utilizaada princiaplmente por pentesters y desarrolladores de seugridad para realizar pruebas dinámicas y análisis en aplicaciones móviles y de escritorio. Permite inyectar scripts JavaScript en tiempo real para modificar el comportamiento de una app, inteceptar funciones y analizar datos.

----
# [Objection](https://github.com/sensepost/objection)

**Objection** es una herramienta que aprovecha Frida para realizar diversas tareas de análisis y manipulación de aplicaciones móviles sin necesidad de acceso al código fuente o recompilación. Es una herramienta que automatiza el proceso e incluye una variedad de comandos para realizar tareas comunes de pentesting como SSL Pinning Bypass, manipulación de preferencias de aplicaciones, intercepción de tráfico de red y más.

- Installation: 
```bash
# Install frida tools
pip3 install frida-tools
# Install objection
pip3 install objection
```

Una vez ejecutado los anteriores comandos ya tendríamos tanto la herramienta `frida` como `objection` disponibles para hacer uso desde línea de comandos, lo que nos permitiría intentar inyectar código para integrar Frida de manera automatica:

```bash
objection patchapk --source C:\Path\To\Application.apk
# Can't decode resource issue
objection patchapk --source C:\Path\To\Application.apk --use-aapt2
```

Tras la ejecución de este comando estaremos intentando descompilar el APK, posteriormente inyectar el código necesario para integrar Frida en la aplicación (Generalmente añadiendo la biblioteca Frida y modificando el código para cargar Frida al inico de la aplicación), para finalmente recompilar el APK y firmar el mismo, ya que la firma origianl del desarrollador pasa a no ser válida tras la recompilación, se utiliza una clave de firma de depuración proporcionada por Objection o una personalizada si se especifica, pero esto puede traer problemas por lo que nos puede llegar a ser de sumo interes poder realizar este proceso de manera manual.
#### Injecting Frida Manually

Como hemos visto anteriormente, con la herramienta `apktool` podemos decompilar nuestro *apk*.

```bash
apktool d -r /path/to/application.apk
```

Una vez hecho esto, basandonos en la guía de instalación de ["Using frida on Android without root"](https://koz.io/using-frida-on-android-without-root/), ejecutaremos la siguiente suseción de comandos para proseguir con la instalación:

```bash
# Download the frida gadget needed (In this examplel x86_64 architecture)
wget https://github.com/frida/frida/releases/download/16.2.5/frida-gadget-16.2.5-android-x86_64.so.xz
# Extract the compressed file
unxz frida-gadget-16.2.5-android-x86_64.so.xz
# Rename .so file to handle future errors
mv frida-gadget-16.2.5-android-x86_64.so libfrida-gadget.so
# Copy the .so file to needed lib directory (Becarefull with the architecture)
cp frida-gadget.so {decompiled_dir}/lib/{arquitecture_needed(e.g. x86_64)}/libfrida-gadget.so
```

Posteriormente deberemos agregar las líneas:

`const-string v0, "frida-gadget"`
`invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V`

Al *#direct method* con el nombre **constructor** antes del *return-void* en el archivo `{decompiled_dir}/smali/{name (e.g. b3nac)}/{appname (e.g. injuredAndroid)}/MainActivity.smali`. Una vez habiendo agregado la libreria Frida para la arquitectura necesaria y habiendo modifcado el código para la llamada del mismo, simplemente faltaría volver a crear el archivo *.apk*:

```bash
apktool b {decomiled_dir} -o {new_builded_app}.apk
```

**IMPORTANTE**: Si no tenemos acceso a internet en la APP, será necesario agregar este permiso para que Frida gadget pueda abrir un socket y funcionar correctamente.

Una vez re-empaquetada la aplicación, necesitamos firmar el apk, para esto haremos uso de `keytool` y `jarsigner`.

- Crear nuestras claves:
```bash
keytool -genkey -v -keystore {custom}.keystore -alias {mykeyaliasname} -keyalg RSA -keysize 2048 -validity 10000 
```

- Firmar el archivo *.apk*:
```bash
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore {custom}.keystore -storepass {password_used} {repackaged.apk} {mykeyaliasname}
```

- Verificar la firma:
```bash
jarsigner -verify {repackaged.apk}
```

- Reempaquetar la aplicación
```bash
zipalign 4 {repackaged.apk} {repackaged-final.apk}
```

Tras haber firmado y rempaquetado el APK, quedaría subir el apk e instalar el mismo al dispositivo móvil como se puede visualizar en [[Android Mobile App Static Analysis#Pushing an APK from our System]]. Una vez subida la aplicación e instalada en el dispositivo móvil, tras abrirla puede que veamos como si esta no cargará y se quedara en blanco, lo que indicaría probablemente de que logramos ejecutar exitosamente Frida, por lo que en un línea de comandos podríamos ejecutar el siguiente comando:

```bash
objection explore
```

Y en caso de haber funcionado veremos la respuesta del agante inyectado y que este responde ok, por lo que podríamos comenzar a ejecutar comandos como `android sslpinning disable` para deshabilitar el *SSL Pinning* y poder comenzar a ver el tráfico sin problema.

---
# Logcat

Como pentesters, revisar el *Logcat* es curcial dado que puede revelar una gran cantidad de información sobre la aplicación y su comportamiento en tiempo de ejecución, como por ejemplo:

- *Sensitive Infromation*: El Logcat puede ocntener información sensible como claves API, tokens de sesión, credenciales, etc.
- *Errors and Vulnerabilities*: Podemos encontrarnos con exceptciones, fallos o errores que indiquen vulnerabilidades en la aplicación.
- *Data Flow*: Ayuda a entender el flujo de datos dentro de la apclicación, idenficiando puntos de entrada y salida de datos sensibles.
- *Anomalous Behavior*: Puede mostrar comportamientos anómalos o no intencionados que podrían ser explotados.
- *Debugging and Analysis*: Facilita la depuración y el análisis de la aplicación, permitiéndote identificar y entender posibles vectores de ataque.

![[logcat_androidstudio_example.png]]

Para iniciar la captura de los logs o guardar los mismos, podemos hacer uso del comando:

```bash
# Start capturing logs
adb logcat
# Save the logs
adb logcat > /path/to/output_file.txt
```

----
# Using Frida Codershare & Startup Scripts

Adicionalmente, en la página de [Frida Codeshare](https://codeshare.frida.re/) podemos encontrar scripts creados por la comunidad para realizar distintas acciones, podemos descargarnos estos scripts. Para utilizar estos scripts podríamos hacer uso del comando:

```bash
# Execute javascript script in the beginning
objection explore --startup-script {script_downloaded.js}
# Execute objection commands in the beginning
objection explore -s "android root disable"
```
