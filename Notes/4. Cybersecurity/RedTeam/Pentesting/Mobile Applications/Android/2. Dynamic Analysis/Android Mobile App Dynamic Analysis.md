# Dynamic Analysis

Como vimos en el apartado de [[Mobile Application Penetration Testing Process]], el análizis dinámico consiste en analizar la aplicación ejecutando la misma, interactuando con sus funcionalidades para poder entender que hace, cuando, como, etc.

---
# SSL Pinning

*SSL Pinning* es una metodología de seguridad utilizada para asegurar que el tráfico de la aplicación no esta siendo interceptado (MITM) asegurando que la aplicación solo se comunique con un servidor específico mediante certificados SSL conocidos. Al implementar SSL Pinning, la aplicación almacena de manera interna uno o más certificados de los servidores confiables y los compara con los certificados recibidos durante la conexión SSL/TLS. Si no coincide, la conexión se rechaza, mitigando el riesgo de interceptación y manipulación de datos por parte de atacantes que intentan usar certificados falsificados o comprometidos.

Ejemplo de implementación de SSL Pinning en Android haciendo uso de OkHttp:
```java
OkHttpClient client = new OkHttpClient.Builder()
    .certificatePinner(new CertificatePinner.Builder()
        .add("{yourdomain.com}", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
        .build())
    .build();
```

Como pentesters, conocer este método de seguridad nos es fundamental para saber a que problema nos estamos pudiendo enfrentar en caso de tener erorres así como a su vez, intentar sortear el msimo.

En muchos casos, podríamos intentar evadir o seactivar el SSL Pinning para poder así analizar el tráfico de la aplicación. Esto puede inlcuir téncicas como por ejemplo:
 - **Repackage the App**: Modificar el código de la aplicación para eliminar o deshabilitar el pinning.
 - **Dynamic Instrumentation**: Usar herramientas como *Frida* o *Xposed* para interceptar y modificar funciones en tiempo de ejecución.
```javascript
Java.perform(function() {
    var CertificatePinner = Java.use("okhttp3.CertificatePinner");
    CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function() {
        // Skip SSL Pinning
        console.log("Bypassing SSL Pinning");
    };
});
```
 - **MITM Proxies**: Hacer uso de proxies especializados como [[Burpsuite]] con plugins específicos que pueden deshabilitar el pinning en tiempo real.

----
# MobSF

Una vez más, como se menciono en la sección de [[Android Mobile App Static Analysis]], podemos hacer uso de la herramient [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF) la cual nos permite configurar y llevara a cabo de manera automatizada el análisis dinámico de una App. Para esto deberemos realizar alguans configuraciones las cuales están detalladas en esta [guií de configuración de análisis dinámico en MobSF](https://mobsf.github.io/docs/#/dynamic_analyzer?id=genymotion-android). 

----
# Using [[Burpsuite]]

*Burpsuite* sin duda será una herramienta la cual utilizaremos también en este tipo de pentesting a aplicaicones móviles, configuraremos un nuevo proxy abierto a todas las interfaces, descargaremos el certificado, lo subiremos e instalaremos en el apartado de *Security* del telefono móvil y posteriormente configuraremos el *Android Studio* con el proxy creado.

1. Crear el proxy en [[Burpsuite]]:

![[creating_a_new_proxy_burpsuite.png]]

2.  Una vez creado el proxy, la siguiente opción sería la de *Import / export CA certificate*, donde presionaremos la opción de exportar certificado en formato DER (*Certificate in DER format*) en el apartado de *Export*:

![[export_certificate_bupsuite.png]]

3. Una vez descargado el mismo, nos debemos asegurar en cambiar la extensión a **.cer**, una vez guardado, simplemente arrastramos con el mouse el certificado al emulador para subirlo al dispositivo. En caso de tener un dispositivo real conectado o desear hacerlo desde línea de comandos, podemos hacerlo con herramientas como `adb`:

```powershell
> adb push C:\Path\To\Downloaded\Certificate.cer /sdcard/
```

Para que esto funcione, además de lo mencionado en [[Android Lab configs and tips#Enabling Developer Options]], deberíamos subir/mover el certificado (Archivo **.cer**) a un directorio accesible por el usuario, en este caso `/sdcard/` es uno, pero podría ser `/sdcard/Documents`,`/sdcard/Downloads`, etc.

4. Tras la subida del certificado al dispositivo, estamos con la posibilidad de hacer uso de este para que las conexiones SSL con [[Burpsuite]] sean posibles. Según el modelo de dispositivo el camino para instalar certificados suele cambiar pero de igual manera suele ser bastante similar al que se demuestra  como ejemplo, ir a `Security > Encryption & credentials > Install a certificate > CA certificate`

![[encription_and_credentials_android.png|150]] ![[install_a_certificate_android.png|157]] ![[ca_certificate_android.png|150]] ![[sdcard_directory_from_import_cert_android.png|150]] 

5. Una vez subido e instalado el certificado en el dispositivo móvil, simplemente faltaría realizar la configuración, en este caso, en nuestra aplicación *Android Studio*:

![[android_studio_burpsuite_settings.png]]

Para otros sistemas operativos, como macOS, podríamos hacer uso de otras opciones ante Burpsuite, como por ejemplo [Proxyman](https://docs.proxyman.io/). 

---
# [Frida](https://frida.re/docs/android/)

**Frida** es una herramienta poderosa para la ingeniería inversa y la seguridad de aplicaicones que permite la inyección de scripts en aplicaciones en tiempo real. Es utilizaada princiaplmente por pentesters y desarrolladores de seugridad para realizar pruebas dinámicas y análisis en aplicaciones móviles y de escritorio. Permite inyectar scripts JavaScript en tiempo real para modificar el comportamiento de una app, inteceptar funciones y analizar datos.

----
# [Objection](https://github.com/sensepost/objection)

**Objection** es una herramienta que aprovecha Frida para realizar diversas tareas de análisis y manipulación de aplicaciones móviles sin necesidad de acceso al código fuente o recompilación. Es una herramienta que automatiza el proceso e incluye una variedad de comandos para realizar tareas comunes de pentesting como SSL Pinning Bypass, manipulación de preferencias de aplicaciones, intercepción de tráfico de red y más.

- Installation: 
```bash
# Install frida tools
pip3 install frida-tools
# Install objection
pip3 install objection
```

Una vez ejecutado los anteriores comandos ya tendríamos tanto la herramienta `frida` como `objection` disponibles para hacer uso desde línea de comandos, lo que nos permitiría intentar inyectar código para integrar Frida de manera automatica:

```bash
objection patchapk --source C:\Path\To\Application.apk
```

Tras la ejecución de este comando estaremos intentando descompilar el APK, posteriormente inyectar el código necesario para integrar Frida en la aplicación (Generalmente añadiendo la biblioteca Frida y modificando el código para cargar Frida al inico de la aplicación), para finalmente recompilar el APK y firmar el mismo, ya que la firma origianl del desarrollador pasa a no ser válida tras la recompilación, se utiliza una clave de firma de depuración proporcionada por Objection o una personalizada si se especifica, pero esto puede traer problemas por lo que nos puede llegar a ser de sumo interes poder realizar este proceso de manera manual.
#### Injecting Frida Manually

Como hemos visto anteriormente, con la herramienta `apktool` podemos decompilar nuestro *apk*.

```bash
apktool d -r /path/to/application.apk
```

Una vez hecho esto, basandonos en la guía de instalación de ["Using frida on Android without root"](https://koz.io/using-frida-on-android-without-root/), ejecutaremos la siguiente suseción de comandos para proseguir con la instalación:

```bash
wget https://github.com/frida/frida/releases/download/16.2.5/frida-gadget-16.2.5-android-x86_64.so.xz

unxz frida-gadget-16.2.5-android-x86_64.so.xz

cp frida_libs/armeabi/frida-gadget-9.1.26-android-arm.so out_dir/lib/armeabi/libfrida-gadget.so

```
# SSL Pinning Bypass

