----
- Tags: #ataques #teoria #practica #basico 
---

# ¿ Que es **XPath** ?

**XPath** es un lenguaje de consultas utilizado en **XML** que permite buscar y recuperar información específica de **documentos XML**. Sin embargo, al igual que otros lenguajes de programación y consultas, XPath tmabién puede tener **vulnerabilidades** que los atacantes pueden aprovechar para comprometer la seguridad de una aplicación web. 

Las **vulnerabilidades XPath** son aquellas que se aprovechan de las debilidades en la implementación de consultas XPath en una aplicación web. A continuación, se describen algunos tipos de vulnerabilidades comunes en XPath: 

- ### **Inyección XPath:** Los atacantes pueden utilizar inyección de código malicioso en las consultas XPath para alterar el comportamiento de la aplicación. Por ejemplo, pueden agregar una consulta maliciosa que recupere toda la información del usuario, incluso información confidencial como contraseñas. 
- ### **Fuerza bruta de XPath:** Los atacantes pueden utilizar técnicas de fuerza bruta para adivinar las rutas de XPat y recuperar información confidencail. Esta técnica se basa en intentar diferentes rutas XPath hasta encontrar una que devuelva información confidencial. 
- ### **Recuperación de información del servidor:** Los atacantes pueden utilizar consultas XPath maliciosas para obtener información sobre el servidor, como el tipo de base de datos, la versió mde la aplicación, etc. Esta información puede ayudar a los atacantes a planear ataque smás sofisticados. 
- ### **Manipulación de respuestas XPath:** Los atacantes pueden manipular las respuestas XPath de la aplicación web para obtener información adicional o alterar el comportamiento de la aplicación. Por ejemplo, pueden modificar una respuesta XPath para crear una cuenta de usuario sin permiso. 

----

# Evitar estos ataques 

Para protegerse contra las vulnerabilidades XPath, es importante validar todas las entradas de usuario y evitar la construcción dinámica de consultas XPath. Además, se recomienda restringir los permisos de acceso a los recursos de la aplicación web y mantener actualizado el software y los sistemas operativos. Por último, se recomienda utilizar herramientas de análisis de seguridad y realizar pruebas de penetración regulares para identificar y corregir cualquie rvulnerabilidad en la aplicación web. 

----

# Explotación 

Como en las [[SQLI - (Inyecciones SQL)]] y en las [[NoSQLI - (NoSQL Injections)]], esto comienza por un campo que parece posiblemente vulnerable a alugna inyeccion de estas, por lo que de primeras provariamos tanto SQLI como NoSQLI, pero podría ser el caso de que la query **' or '1'='1** funcione aumentando aun más las sospechas de una posbile inyección, pero al continuar probando multiples querys maliciosas de SQLI y NoSQLI veriamos que no llegamos a nada.

En este punto, podríamos empezar a barajar la posiblidad de estar enfrente a una **XPath Injection**. Por lo que sabemos, XPath es un lenguaje de consultas dirigido hacia un archivo en formato XML, por lo cual la idea principal sería comenzar a tramitar inyecciones XPath para dumpear el archivo XML. 

Lo primero es intentar verificar cuantes etiquetas PRIMARIAS existen, es decir, en una estructura XML tal que así: 

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<data>
	<user>
	    <name>pepe</name>
	    <password>peponcio</password>
	    <account>admin</account>
	</user>
	<user>
	    <name>mark</name>
	    <password>m12345</password>
	    <account>regular</account>
	</user>
	<user>
	    <name>fino</name>
	    <password>fino2</password>
		<account>regular</account>
	</user>
</data>
```

Tendríamos una etiqueta primaría la cual sería DATA.  Por lo que para verificar esto, existe la query: 

`1' and count(/*)='1`

De esta manera, le indicamos que si la suma de todas las etiquetas raizes (PRIMARIAS), es igual a 1, la query se convierta a TRUE. Pudiendo así, verificar que las etiquetas primarias son (en este caso) 1. 

Una vez sabiendo la cantidad de etiquetas primarias, tocaria comenzar a descifrar el valor de esta misma. 

Con la query `1' and name(/*[1])='data` estariamos indicando que el valor de la primera etiqueta es data, de manera que donde pone [ 1 ] prodríamos cambiarlo por otros valores en caso de existir otra etiqueta, ahora bien, esto sirve para saber el nombre COMPLETO, pero si quisieramos dumpear este valor que de primer no conocemos, deberiamos hacer de una menera similar a las [[SQLI - (Inyecciones SQL)]], jugando con substring `1' and substring(name(/*[1]),1,1)='a` para que al igual que en las SQLI, podemos mediante fuerza bruta, extraer los valores correctos. 

Tambien podríamos extraer la longitud de la etiqueta en cuestion con la query `1' and string-length(name(/*[1]))>'2` .

Una vez que tengamos las etiquetas principales, podriamos verificar la cantidad de etiquetas dentro de cada una de estas etiquetas primarias (En este caso hay 1), con la query `1' and count(/*[1]/*)='1`. 

Y el mismo proceso, prodríamos ver el valor con `1' and name(/*[1]/*[1])='user` o con `1' and substring(name(/*[1]/*[1]),1,1)='u`.

Y de esta manera se vuelve constante, tanto para saber el la cantidad de etiquetas hijas que tiene una etiqueta padre, con *count*, como la longitud de una determinada etiqueta con *string-length*, como el nombre de una etiqueta con *name* o el primer, segundo, tercer, etc caracter con *substring*. Y para variar los niveles de las etiquetas `/*[1]/*[1]/*[1]`, en este caso estariamos referenciando a la etiqueta **\<name>**. 

Por ultimo, para que en base a determinada etiqueta podamos obtener los valores, usariamos la query `1' and substring(name,1,1)='n`, el primer 1 nos hace que las cosas sean un poco más faciles ya que apunta al primer producto. 


