# Unlocking Bootloader

El teléfono, al igual que los demas dispositivos, arrancan en el **bootloader**, también conocido como *gestor de arranque*. El bootloader es un programa que se ejecuta al encender un dispositivo y que se *encarga de cargar el sistema operativo* en la memoria RAM para que pueda empezar a funcionar.

Por lo que, al ejecutar el primer comando, `adb`dejará de reconocer a nuestro dispositivo, ya que veremos una pantalla tal que así: 

<html>
<center>
<img src="../../../0. Images/Pasted image 20250812173830.png" alt="Fastboot Mode"/>
</center>
</html>

- Reiniciar al modo bootloader:
```bash
 adb reboot bootloader
```

Por lo que en este punto, según lo mencionado, podríamos listar nuestro dispositivo de la siguiente manera:

```bash
fastboot devices
```

En este punto, como venimos haciendo, lo que nos interesa hacer es obtener información y almacenarla como **baseline** para en cualquier moment saber desde donde partimos y poder debuggear cualquier error, mismo al intentar querer restablecer todo como estaba originalmente.

- Listar información del bootloader:
```bash
fastboot getvar all
```

- Listar si el dispositivo es desbloqueable:
```bash
fastboot flashing get_unlock_ability
```

Esto confirmará:

- Si el bootloader está bloqueado/desbloqueado. (Visualizaremos un  *get_unlock_ability: 1* en caso de poder desbloquearse).
- Slot activo.
- Información de versión.

> [!info] Slot A and Slot B
> Desde Android 7, muchis dispositivos, incluidos el de mi personal interes el **Pixel 6** de Google, usan el esquema `A/B` o `seamless updates`. En lugar de un único conjunto de particiones de sistema, existen *dos copias completas* (**Slots**):
> 
> - **Slot A**.
> - **Slot B**.
>   
> Cada slot contiene sus propias particiones críticas (`boot`, `system`, `vendor`, etc.).
> 
> La idea de esto junto a la existencia nace del poder realizar *actualizaciones sin interrumpir el uso*:
> 
> - El sistema arranca desde un slot activo (Ej. A (Podemos listar estando en *fastboot* el slot activo con `fastboot getvar current-slot` y mismo cambiar de slot con `fastboot set_active a`)).
> - El otro slot está inactivo.
> - Cuando lleguna una actualización OTA (Over-The-Air), se instala en el slot inactivo.
> - En el siguiente reinicio, el bootloader cambia el slot activo al contrario en uso hasta ese entonces y arranca desde allí.
> - Si algo falla, puede volver a el slot dejado.

Finalmente procederemos a **desbloquear el bootloader** para *desactivar AVB* (*Android Verified Boot*), lo cual nos permitirá posteriormente parchear y volver a cargar la `boot.img`<.

> [!warning] Este paso **borrará todo el almacenamiento interno** y mostrará la advertencia de bootloader desbloqueado al inicio.

- Desbloquear bootloader
```bash
fastboot flashing unlock
```

Al ejecutar este comando deberíamos visualizar algo como:

<html>
<center>
<img src="../../../0. Images/Pasted image 20250812180759.png" alt="Unlock bootloader"/>
</center>
</html>

Presionamos la tecla de volumen para mutar entre opciones y seleccionamos **Unlock the bootloader**. Una vez realizado, deberíamos ver la pantalla de Fastboot Mode con la invormación de estado de dispositivo *Unlocked*.

<html>
<center>
<img src="../../../0. Images/Pasted image 20250812181228.png" alt="Bootloader Unlocked"/>
</center>
</html>


Una vez en este punto, deberemos configurar nuevamente el Android, volver a activar la *Depuración USB* y si nos aparece la opción *OEM Unlocking* (Para permitir relock si algún día quisieramos revertir).

En el proximo artículo de esta sección de **Hacking Swiss Army Knife** deberemos obtener la imagen `boot.img`de la versión exacta de nuestra dispositivo Android, parchearla con [Magisk](https://github.com/topjohnwu/Magisk) para *rootear el dispositivo*, flashear el boot parcheado usando `fastboot`y comenzar con la configuración del entorno ofensivo. 
