<# Baseline

El **Baseline** (**Linea de base**) es el punto de partida desde el que empezamos, entenderemos donde estamos parados y es muy recomendable *registrar detalladamente el estado actual del dispositivo*, antes de cualquier modificación.

Es un snapshot del dispositivo (A partir de hora generalizando el dispositivo como en mi caso particular **Pixel 6**) en su estado original, lo que nos sirve para:

- Comparar cambios después de cada modificación.
- Tener datos para revertir o restaurar (Ej. tabla de particiones, estado de bootloader, drivers activos, etc.).

En hardware hacking y sistemas embebidos esto suele ser *lo primero que se realiza* antes de alterar cualquier aspecto del dispositivo.

----
# Registry what?

En Android (Y cualquier sistema Linux embebido) hay varias fuentes clave de información:

- `/proc` -> Datos dinámicos del kernel y hardware (CPU, RAM, módulos).
- `getprop` -> Base de datos de propiedades de sistema mantenida por Android (`ro.*`, `persist.*`).
- Comandos del kernel (`mount` , `df`, `ps`) -> Estado de particiones, procesos y almacenamiento.
- Herramientas de red (`netstat`) -> Puertos y servicios abiertos.
- Logs (`logcat`, `dmesg`) -> Mensajes del sistema y del kernel.
- Fastboot info -> Estado del bootloader, AVB (Android Verified Boot), slots de arranque.

Esta información sale de *tres lugares*:

- Capa de usuario de Android (A través de `adb`).
- Kernel y sistema de ficheros virtual (`/proc`).
- Modo bootloaderl/fastboot.

-----
# Baseline documentation Hands-on

Para llevar a cabo este procedimiento necesitaremos:

- Una notebook o máquina para conectar nuestro dispositivo con las herramientas necesarias:
	- Paquetes `android-tools-adb` y `android-tools-fastboot`. 
- Un cable usb con la posibilidad de transferencia de datos.
- El celular (En mi caso **Google Pixel 6**) con *modo desarrollador*, *depuración USB* y *Desbloqueo OEM* (Opcional).
	- Para el Google Pixel 6 iremos a *Settings* -> *About phone* -> *Build number* (*Número de compilación*) y presionaremos 7 veces esta valor. A la septima vez presionado se activará el modo desarrollador.
	- Una vez activada la opción de desarrollador, volveremos a *Settings* -> *Advanced* -> *Developer Options* -> *USB Debugging* y lo ponemos en **ON**. Al igual que la opción *OEM Unlocking* para cuando más adelante tengamos que desbloquear el bootloader.
### Base line documentation:

En este punto ya deberíamos tener la opción de desarrollador habilitada, el telefono conectado mediante un cable usb y habiendo permitido la in teracción entre nuestra notebook y el celular, finalmente deberíamos tener, si estamos en arch, el paquete `android-tools` o el que corresponda instalado. Las herramientas que estaremos utilizando en esta primera instancia serán `adb` y `fastboot`. 

En otros artículos, como el de [[Android Lab]], hemos hablado acerca de la herramienta `adb`y explicado sus posibles usos dentro de la pata de *Mobile Application Hacking*, pero para resumir, **adb** (**A**ndroid **D**ebug **B**ridge) es una herramienta de línea de comandos versátil que nos permite la comuinicación entre un dispositivo android y una computadora. Facilita diversas acciones en el dispositivo, como la instalación y depuración de aplicaciones. En este caso, la estaremos utilizando para la ejecución de comandos dentro del dispositivo android y la captura de los outputs de estos para tener nuestra **baseline**.

- Validar si el dispositivo es reconocido por `adb`: 
```bash
adb devices
```

> [!warning] Multiples devices in `adb devices` output list
> En el caso de tener más de un dispositivo conectado por cual fuese el motivo o mismo emuladores instalados, deberemos identificar nuestro dispositivo target tomando en cuenta el **Serial Number**. Dado este caso, las alternativas son dos.
> - O bien ejecutar cada comando que se proveerá utilizando la flag `-s {device_serial_number}` .
> - O exportar la variable de entorno `ANDROID_SERIAL={device_serial_number}`.

Ahora si, habiendo hecho esta aclaración, en el lugar que sea de nuestra preferencia, podríamos crear una carpeta para almacenar todos los outputs.
###### Hardware and properties

- Captura de propiedades del sistema:
```bash
adb shell getprop > device_props.txt
```

- CPU Info:
```bash
adb shell cat /proc/cpuinfo > cpuinfo.txt
```

- RAM Info:
```bash
adb shell cat /proc/meminfo > meminfo.txt
```

- Kernel version info:
```bash
adb shell cat /proc/version > kernel_version.txt
```

###### SELinux

En Android, **SELinux** (**S**ecurity-**E**nhanced **L**inux) es un módulo de seguridad del kernel que implemente el *control de acceso obligatorio*  (*MAC* - *Mandatory Access Control*) para proteger el sistema contra accesos no autorizados. 

- Estado de SELinux:
```bash
adb shell getenforce > selinux_mode.txt
```

###### Storage and partitions

- Listar enlaces simbolicos a particiones del disco:
```bash
adb shell ls -l /dev/block/by-name > partitions.txt
```

- Listar espacio y uso del sistema:
```bash
adb shell df -h 
```

- Listar monturas del sistema:
```bash
adb shell mount > mounts.txt
```

######  Processes and Ports

- Listar todos los procesos activos del sistema:
```bash
 adb shell ps -A > processes.txt
```

- Listar puertostcp, udp asociados a su PID:
```bash
 adb shell netstat -tunlp > network_ports.txt
```

###### System logs and Kernel logs

- Mostrar los mensajes de registro:
```bash
 adb logcat -d > logcat_initial.txt
```

- Mensajes del kernel (Esto arrojará error, pero es interesante documentarlo):
```bash
adb shell dmesg &> dmesg_initial.txt
```


