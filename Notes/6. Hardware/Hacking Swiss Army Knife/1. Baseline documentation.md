<# Baseline

El **Baseline** (**Linea de base**) es el punto de partida desde el que empezamos, entenderemos donde estamos parados y es muy recomendable *registrar detalladamente el estado actual del dispositivo*, antes de cualquier modificación.

Es un snapshot del dispositivo (A partir de hora generalizando el dispositivo como en mi caso particular **Pixel 6**) en su estado original, lo que nos sirve para:

- Comparar cambios después de cada modificación.
- Tener datos para revertir o restaurar (Ej. tabla de particiones, estado de bootloader, drivers activos, etc.).

En hardware hacking y sistemas embebidos esto suele ser *lo primero que se realiza* antes de alterar cualquier aspecto del dispositivo.

----
# Registry what?

En Android (Y cualquier sistema Linux embebido) hay varias fuentes clave de información:

- `/proc` -> Datos dinámicos del kernel y hardware (CPU, RAM, módulos).
- `getproc` -> Base de datos de propiedades de sistema mantenida por Android (`ro.*`, `persist.*`).
- Comandos del kernel (`mount` , `df`, `ps`) -> Estado de particiones, procesos y almacenamiento.
- Herramientas de red (`netstat`) -> Puertos y servicios abiertos.
- Logs (`logcat`, `dmesg`) -> Mensajes del sistema y del kernel.
- Fastboot info -> Estado del bootloader, AVB (Android Verified Boot), slots de arranque.

Esta información sale de *tres lugares*:

- Capa de usuario de Android (A través de `adb`).
- Kernel y sistema de ficheros virtual (`/proc`).
- Modo bootloaderl/fastboot.

-----
# Baseline documentation Hands-on

Para llevar a cabo este procedimiento necesitaremos:

- Una notebook o máquina para conectar nuestro dispositivo con las herramientas necesarias:
	- Paquetes `android-tools-adb` y `android-tools-fastboot`. 
- Un cable usb con la posibilidad de transferencia de datos.
- El celular (En mi caso **Google Pixel 6**) con *modo desarrollador*, *depuración USB* y *Desbloqueo OEM* (Opcional).
	- Para el Google Pixel 6 iremos a *Settings* -> *About phone* -> *Build number* (*Número de compilación*) y presionaremos 7 veces esta valor. A la septima vez presionado se activará el modo desarrollador.
	- Una vez activada la opción de desarrollador, volveremos a *Settings* -> *Advanced* -> *Developer Options* -> *USB Debugging* y lo ponemos en **ON**. Al igual que la opción *OEM Unlocking* para cuando más adelante tengamos que desbloquear el bootloader.
### Base line documentation:

En este punto ya deberíamos tener la opción de desarrollador habilitada, el telefono conectado mediante un cable usb y habiendo permitido la in teracción entre nuestra notebook y el celular, finalmente deberíamos tener, si estamos en arch, el paquete `android-tools` o el que corresponda instalado. Las herramientas que estaremos utilizando en esta primera instancia serán `adb` y `fastboot`. 

En otros artículos, como el de [[Android Lab]], hemos hablado acerca de la herramienta `adb`y explicado sus posibles usos dentro de la pata de *Mobile Application Hacking*, pero para resumir, **adb** (**A**ndroid **D**ebug **B**ridge) es una herramienta de línea de comandos versátil que nos permite la comuinicación entre un dispositivo android y una computadora. Facilita diversas acciones en el dispositivo, como la instalación y depuración de aplicaciones. En este caso, la estaremos utilizando para la ejecución de comandos dentro del dispositivo android y la captura de los outputs de estos para tener nuestra **baseline**.

- Validar si el dispositivo es reconocido por `adb`: 
```bash
adb devices
```

> [!warning] Multiples devices in `adb devices` output list
> En el caso de tener más de un dispositivo conectado por cual fuese el motivo o mismo emuladores instalados, deberemos identificar nuestro dispositivo target tomando en cuenta el **Build Number**. Dado este caso, las alternativas son dos.
> - O bien ejecutar cada comando que se proveerá utilizando la flag `-s {device_serial_number}` .
> - O exportar la variable de entorno `ANDROID_SERIAL={device_serial_number}`.

Ahora si, habiendo hecho esta aclaración, en el lugar que sea de nuestra preferencia, podríamos crear una carpeta para almacenar todos los outputs.
###### Hardware and properties

- Captura de propiedades del sistema:
```bash
adb shell getprop > device_props.txt
```

- CPU Info:
```bash
adb shell cat /proc/cpuinfo > cpuinfo.txt
```

- RAM Info:
```bash
adb shell cat /proc/meminfo > meminfo.txt
```

- Kernel version info:
```bash
adb shell cat /proc/version > kernel_version.txt
```

###### SELinux

En Android, **SELinux** (**S**ecurity-**E**nhanced **L**inux) es un módulo de seguridad del kernel que implemente el *control de acceso obligatorio*  (*MAC* - *Mandatory Access Control*) para proteger el sistema contra accesos no autorizados. 

- Estado de SELinux:
```bash
adb shell getenforce > selinux_mode.txt
```

###### Storage and partitions

- Listar enlaces simbolicos a particiones del disco:
```bash
adb shell ls -l /dev/block/by-name > partitions.txt
```

- Listar espacio y uso del sistema:
```bash
adb shell df -h 
```

- Listar monturas del sistema:
```bash
adb shell mount > mounts.txt
```

######  Processes and Ports

- Listar todos los procesos activos del sistema:
```bash
 adb shell ps -A > processes.txt
```

- Listar puertostcp, udp asociados a su PID:
```bash
 adb shell netstat -tunlp > network_ports.txt
```

###### System logs and Kernel logs

- Mostrar los mensajes de registro:
```bash
 adb logcat -d > logcat_initial.txt
```

- Mensajes del kernel (Esto arrojará error, pero es interesante documentarlo):
```bash
adb shell dmesg &> dmesg_initial.txt
```

###### Bootloader state

El teléfono, al igual que los demas dispositivos, arrancan en el **bootloader**, también conocido como *gestor de arranque*. El bootloader es un programa que se ejecuta al encender un dispositivo y que se *encarga de cargar el sistema operativo* en la memoria RAM para que pueda empezar a funcionar.

Por lo que, al ejecutar el primer comando, `adb`dejará de reconocer a nuestro dispositivo, ya que veremos una pantalla tal que así: 

<html>
<center>
<img src="../../../0. Images/Pasted image 20250812173830.png" alt="Fastboot Mode"/>
</center>
</html>

- Reiniciar al modo bootloader:
```bash
 adb reboot bootloader
```

Por lo que en este punto, según lo mencionado, podríamos listar nuestro dispositivo de la siguiente manera:

```bash
fastboot devices
```

En este punto, como venimos haciendo, lo que nos interesa hacer es obtener información y almacenarla como **baseline** para en cualquier moment saber desde donde partimos y poder debuggear cualquier error, mismo al intentar querer restablecer todo como estaba originalmente.

- Listar información del bootloader:
```bash
fastboot getvar all
```

- Listar si el dispositivo es desbloqueable:
```bash
fastboot flashing get_unlock_ability
```

Esto confirmará:

- Si el bootloader está bloqueado/desbloqueado. (Visualizaremos un  *get_unlock_ability: 1* en caso de poder desbloquearse).
- Slot activo.
- Información de versión.

> [!info] Slot A and Slot B
> Desde Android 7, muchis dispositivos, incluidos el de mi personal interes el **Pixel 6** de Google, usan el esquema `A/B` o `seamless updates`. En lugar de un único conjunto de particiones de sistema, existen *dos copias completas* (**Slots**):
> 
> - **Slot A**.
> - **Slot B**.
>   
> Cada slot contiene sus propias particiones críticas (`boot`, `system`, `vendor`, etc.).
> 
> La idea de esto junto a la existencia nace del poder realizar *actualizaciones sin interrumpir el uso*:
> 
> - El sistema arranca desde un slot activo (Ej. A (Podemos listar estando en *fastboot* el slot activo con `fastboot getvar current-slot` y mismo cambiar de slot con `fastboot set_active a`)).
> - El otro slot está inactivo.
> - Cuando lleguna una actualización OTA (Over-The-Air), se instala en el slot inactivo.
> - En el siguiente reinicio, el bootloader cambia el slot activo al contrario en uso hasta ese entonces y arranca desde allí.
> - Si algo falla, puede volver a el slot dejado.

Finalmente procederemos a **desbloquear el bootloader**.

> [!warning] Este paso **borrará todo el almacenamiento interno** y mostrará la advertencia de bootloader desbloqueado al inicio.

- Desbloquear bootloader
```bash
fastboot flashing unlock
```

Al ejecutar este comando deberíamos visualizar algo como:

<html>
<center>
<img src="../../../0. Images/Pasted image 20250812180759.png" alt="Unlock bootloader"/>
</center>
</html>

Presionamos la tecla de volumen para mutar entre opciones y seleccionamos **Unlock the bootloader**. Una vez realizado, deberíamos ver la pantalla de Fastboot Mode con la invormación de estado de dispositivo *Unlocked*.

<html>
<center>
<img src="../../../0. Images/Pasted image 20250812181228.png" alt="Bootloader Unlocked"/>
</center>
</html>


Una vez en este punto, deberemos configurar nuevamente el Android, volver a activar la *Depuración USB* y si nos aparece la opción *OEM Unlocking* (Para permitir relock si algún día quisieramos revertir).

En el proximo artículo de esta sección de **Hacking Swiss Army Knife** deberemos obtener la imagen `boot.img`de la versión exacta de nuestra dispositivo Android, parchearla con [Magisk](https://github.com/topjohnwu/Magisk) para *rootear el dispositivo*, flashear el boot parcheado usando `fastboot`y comenzar con la configuración del entorno ofensivo. 
