----
- Tags: #teoria #practica #recon 
- -----
# Kerberos 

### Kerberos es un protocolo de autenticación de redes de ordenador creado por el MIT que permite a dos ordenadores en una red insegura demostrar su identidad mutuamente de manera segura. 

### Para terminar de entender como funcional el flujo de autenticación de kerberos, ver: [[KERBEROS_AUTHETICATION_FLOW]]
#00^BlackKnight
-----
# Reconocimiento 

### Kerberos suele ser una gran fuente de interes de cara a una auditoría desde el reconocimeitno que se puede aplicar hasta ataques a los que se puede deribar. 

### Herramientas como [kerbrute](https://github.com/ropnop/kerbrute) nos puede ser de gran ayuda de cara a la enumeración así como de cara a posibles ataques de fuerza bruta a realizar. (Diccionario recomendable a usar en ataques de fuerza bruta: **seclists/Usernames/xato-net-10-million-usernames.txt** )

### Una vez que dispongamos de un diccionario (Propio o no) de usuarios, podríamos haciendo uso de kerbrute realizar fuerza burta:

```shell
kerbrute userenum --dc {target_ip} -d {domain_name} {users.txt}
# Fuerza bruta al dominio de nuestra maquina victima intentando enumerar usuarios validos del dominio en base a una wordlists de usuarios
impacket-GetNPUsers {domain_name}/ -no-pass -usersfile {users.txt}
# Esta herramienta tambien podria ser usado para fuerza bruta ya que devolveria en caso de conseguir un usuario existente un output diferente.
# Si el usuario no exsite [-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database), si el usuario existe [-] User hsmith doesn't have UF_DONT_REQUIRE_PREAUTH set
```
### Una vez que tuvieramos usuarios tambien podriamos pensar en un [[AS-REP Roast Attack]] pero como kerbrute ya lo hace de manera interna, si no vemos en el output un hash quiere decir que el usuario no tiene configurado el *UF_DONT_REQUIRE_PREAUTH*, por lo que no podemos obtener el hash NetNTLMv2.

### En caso de tener un hash, podriamos usar la herramienta "hashcat" para intentar romper el hash, para esto es importante saber el modo del hash al que nos enfrentamos, por ejemplo, si el hash que capturaramos fuese `$krb5asrep$23$user@domain.com:378sh129fsdf8sdf7...`  podriamos buscar con el comando hashcat --example-hashes y filtradon por el "krb5asrep" (`hashcat --example-hashes | grep -B 11 "krb5asrep"`) para poder conseguir asi el modo que sera utilizado posteriormente con la herramienta "hashcat"
##### `hashcat -m {hash_mode} -a {attack_mode} hash rockyou.txt`
### Para obtener el hash mode, `hashcat --example-hashes` 

### En caso de lograr crackear el hash NetNTLMv2, indicaria que podriamos tener credenciales validas, esto lo podemos corroborar con la herramienta "crackmapexec": 
##### (`crackmapexec smb {target_ip} -u {username} -p {password}`)
### De esta manera, en caso de obtener un "**\[+\]**" indicaria de que las mismas son validas, aunque para poder obtener una shell interactiva buscamos que al usuario le aparezca un "**Pwn3d!**" para poder usar **psexec** y intentar ganar acceso al sistema, en caso de que no, podriamos en caso de tener el puerto 5985 ( SSDP / UPnP) (Servicio de administración remota de windows)
### De manera que podriamos verificar si el usuario en cuestion pertenece al grupo "Remote Managment Users" los cuales pueden conectarse de manera remota:
##### (`crackmapexec winrm {target_ip} -u {username} -p {password}`)
### En caso de obtener el glorioso "Pwn3d!", podriamos con herramientas como "evil-winrm",  entablar una consola remota.
##### `evil-winrm -i {target_ip} -u {username} -p {password}`