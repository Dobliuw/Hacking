----
- Tags: #teoria #practica #avanzado #bof 
----

# Shellcodes 

Los **shellcodes** son programas pequeños y altamente optimizados que se utilizan para explotar vulnerabilidades de seguridad y ejecutar código malicioso en un máquina objetivo. Los shellcodes suele ser escritos en lenguaje **ensamblador** para garantizar una ejecución rápida y eficiente. 

Para escribir shellcodes propios primero hay que entender múltiples cosas, por ejemplo, usando la herramienta **msfvenom** vamos a crear un binario compilado básico para linux

```bash
# La extensión de archivo ELF, es un acrónimo de Formato ejecutable y vinculable para sistemas Unix
msfvenom -p linux/x86/exec CMD="echo 'Hola mundo'" -f elf -o binary 
```

En este caso estamos creando un binario con *output* llamado binario el cual ejecute en sistemas linux de 32 bits el comando `echo 'Hola mundo'`. 

Ahora, en lugar de compilar el binario, vamos a indicarle a la herramienta que nos lo muestre en formato *raw*. 

```bash
msfvenom -p linux/x86/exec CMD="echo 'Hola mundo'" -f raw
# [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
# [-] No arch selected, selecting arch: x86 from the payload
# No encoder specified, outputting raw payload
# Payload size: 53 bytes
# j
#  XRfh-ch/shh/binRecho 'Hola mundo'WS̀

```

Esto es un payload de 32 bytes, si lo vemos en hexadecimal: 

```bash
msfvenom -p linux/x86/exec CMD="echo 'Hola mundo'" -f raw | xxd
# [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
# [-] No arch selected, selecting arch: x86 from the payload
# No encoder specified, outputting raw payload
# Payload size: 53 bytes

# 00000000: 6a0b 5899 5266 682d 6389 e768 2f73 6800  j.X.Rfh-c..h/sh.
# 00000010: 682f 6269 6e89 e352 e812 0000 0065 6368  h/bin..R.....ech
# 00000020: 6f20 2748 6f6c 6120 6d75 6e64 6f27 0057  o 'Hola mundo'.W
# 00000030: 5389 e1cd 80                             S....
```

En este caso se ve que algunas cosas como el *bin/sh* están el little endian (Por la arquitectura de los 32 bits). Es como si hiciera `/bin/sh -c "echo 'Hola mundo'"`. 

En este caso mayormente solemos usar lenguajes de alto nivel para crear script, entre otras, como python, javascript, etc. Pero por ejemplo, python tiene el modulo *sys* el cual nos permite ejecutar código desde la consola y esto por detrás se encarga de realizar cosas.

El lenguaje ensamblador expresa las instrucciones de una forma más natural al hombre a la vez que muy cercana al microcontrolador, ya que cada una de esas instrucciones se corresponde con otra en código máquina. Este payload en lenguaje ensamblador se vería así: 

```bash
msfvenom -p linux/x86/exec CMD="echo 'Hola Mundo'" -f raw | ndisasm -b32 -

# 00000000  6A0B              push byte +0xb
# 00000002  58                pop eax
# 00000003  99                cdq
# 00000004  52                push edx
# 00000005  66682D63          push word 0x632d
# 00000009  89E7              mov edi,esp
# 0000000B  682F736800        push dword 0x68732f
# 00000010  682F62696E        push dword 0x6e69622f
# 00000015  89E3              mov ebx,esp
# 00000017  52                push edx
# 00000018  E812000000        call 0x2f
# 0000001D  6563686F          arpl [gs:eax+0x6f],bp
# 00000021  2027              and [edi],ah
# 00000023  48                dec eax
# 00000024  6F                outsd
# 00000025  6C                insb
# 00000026  61                popa
# 00000027  204D75            and [ebp+0x75],cl
# 0000002A  6E                outsb
# 0000002B  646F              fs outsd
# 0000002D  27                daa
# 0000002E  005753            add [edi+0x53],dl
# 00000031  89E1              mov ecx,esp
# 00000033  CD80              int 0x80
``` 

Esto a bajo nivel, en la ultima línea el '*int 0x80*' conlleva a una *interrupción del sistema* para posteriormente realizar ciertos llamados de funciones a los cuales se le pasará ciertos argumentos (En base a lo que la función espere) .

Para ver y entender mejor esto, debemos seguir analizando el binario para poder llegar a esta conclusión e incluso realizar esto mismo de manera manual. 

```bash
msfvenom -p linux/x86/exec CMD="echo 'Hola mundo'" -f elf -o binary
# Una vez el binario con permisos de ejecución, podemos hacer uso de ST RACE (apt install strace) para ver a bajo nivel lo que hace el binario. 
strace ./binary 
# ............ more code ...................
# rt_sigaction(SIGTERM, NULL, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
# rt_sigaction(SIGTERM, {sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f9c6b3eaf90}, NULL, 8) = 0
# write(1, "Hola Mundo\n", 11Hola Mundo
# )            = 11
# exit_group(0)                           = ?
# +++ exited with 0 +++
```

Vemos que el binario a jo nivel esta haciendo *write, 1, "Hola mundo" y 11*, para entender mejor esto podemos ejecutar `man 2 write` para ver la estructura de la función :

```bash
man 2 write 
# write(2)                                                                           System Calls Manual                                                                          write(2)
#
# NAME
#      write - write to a file descriptor
#
# LIBRARY
#       Standard C library (libc, -lc)
#
# SYNOPSIS
#       #include <unistd.h>
#
#       ssize_t write(int fd, const void buf[.count], size_t count);
#
# DESCRIPTION 
# .............
```

Por lo que podemos ver que la función write recibe 3 argumentos, el primero **int fd** (Un número de salida del sistema), el segundo **const void \*buf** (Dirección donde esta contenida la cadena a mostrar en consola) y el tercer y último argumento **size_t count** (Un número que hace alución al tamaño de la cadena).

Ahora, para realizar estas acciones, por ejemplo un write a bajo nivel, podemos usar la ruta **/usr/include/asm/unistd_32.h** o **/usr/include/x86_64-linux-gnu/asm/unistd_32.h**, las cuales son rutas que indican el valor numérico que hace referencia a funciones a nivel de sistema como *write, read*, etc.

Por lo que ahora, con esta ruta y entendiendo que es necesario ver como se componen las funciones a bajo nivel, que argumentos recibe, etc. podemos realizar nuestros shellcodes (BásicosPasted image 20230612140522) de manera manual: 

#### code.asm
```asm 
section .text 
	gobal _start

_start:
```

En este caso *.asm* es la extención de archivos escritos en lenguaje ensamblador, y en el script se define una sección en donde declaramos una variable global para indicar por donde comenzara el flujo del sistema...
Algo importante a tener en cuenta es que existen ciertos registros **eax, abx, ecx, edx**, etc. los cuales son "argumentos" que se van a leer, es decir que si quiero ejecutar una función la cual se encargue de realizar un "Hola mundo" a nivel de sistema, una vez realizada la interrupción del mismo (*int 0x80*) se leerá el registro *eax* para saber que operatoria se debe realizar, este registro es el que debería pasar el valor *4* sacado de la ruta **/usr/include/x86_64-linux-gnu/asm/unistd_32.h** ya que en esta nos indican que para realizar a nivel de sistema un write se utiliza el valor 4, a su vez esta función recibe 3 argumentos los cuales serán pasados con el registro *ebx, ecx* y *edx*, y así  sucesivamente. 

![[hola_mundo_ensamblador.png]]

Este código en lenguaje ensamblador tiene la intención de ser un binario que realiza un simple **"echo "Hola mundo\\n"**. Pero para que lo sea debemos compilarlo para que tenga formato **.o** y posteriormente convertirlo en un binario: 

```bash 
nasm -f elf code.asm 
# Esto genera el archivo code.o 
ld -m elf_i386 -o {nombre_del_binario_final} code.o 
# Esto genera el binario final con el nombre indicado 
```

Ahora para obtener el shellcode en base a un script generado por lenguaje ensamblador, podemos hacer uso de **objdump**: 

```bash
objdump -d {nombre_del_binario_final} 
# final:     file format elf32-i386
# Disassembly of section .text:

# 08049000 <_start>:
# 8049000:	b8 04 00 00 00       	mov    $0x4,%eax
# 8049005:	bb 01 00 00 00       	mov    $0x1,%ebx
# 804900a:	68 64 6f 0a 00       	push   $0xa6f64
# 804900f:	68 20 6d 75 6e       	push   $0x6e756d20
# 8049014:	68 48 6f 6c 61       	push   $0x616c6f48
# 8049019:	89 e1                	mov    %esp,%ecx
# 804901b:	ba 0b 00 00 00       	mov    $0xb,%edx
# 8049020:	cd 80                	int    $0x80
# 8049022:	b8 01 00 00 00       	mov    $0x1,%eax
# 8049027:	31 db                	xor    %ebx,%ebx
# 8049029:	cd 80                	int    $0x80

printf '\\x' && objdump -d {nombre_del_binario_final} | grep "^ " | cut -f2 | tr -d  ' ' | tr -d '\n' | sed 's/.\{2\}/&\\x /g' | head -c-3 | tr -d ' '; echo
# \xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\x68\x64\x6f\x0a\x00\x68\x20\x6d\x75\x6e\x68\x48\x6f\x6c\x61\x89\xe1\xba\x0b\x00\x00\x00\xcd\x80\xb8\x01\x00\x00\x00\x31\xdb\xcd\x80
# Este oneliner se queda con los valores necesarios, para agregar el \x al principio entre valores de 2 en 2. Es decir, nuestro shellcode (Con ciertos badchars)
```

Por ejemplo si quisiéramos crear un shellcode que se encargase de espawnear una bash: 

#### respawn_bash.asm 
![[respawn_bash_ensamblador.png]]

```bash
nasm -t elf respawn_bash.asm 

ld -m elf_i386 -o respawn_bash respawn_bash.o 

printf '\\x' && objdump -d respawn_bash | grep "^ " | cut -f2 | tr -d  ' ' | tr -d '\n' | sed 's/.\{2\}/&\\x /g' | head -c-3 | tr -d ' '; echo
# \xb8\x0b\x00\x00\x00\x6a\x00\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xcd\x80
```