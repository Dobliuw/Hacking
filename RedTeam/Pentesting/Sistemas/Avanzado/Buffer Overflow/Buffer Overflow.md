-----
- Tags: #teoria #practica #avanzado 
----

# ¿ Que es el **Buffer Overflow** ? 

El **buffer overflow** (**Desbordamiento de búfer**) es una vulnerabilidad común en software que puede permitir a un atacante ejecutar código maliciosos o tomar control de un sistema comprometido. 

Esta vulnerabilidad se produce cuando un programa intentan almacenar **más datos** en un **búfer** (zona de memoria temporal para almacenamiento de datos) de lo que se había previsto, y al exceder la capacidad del búfer, los datos adicionales se escriben en otras zonas de memoria adyacentes. 

Esto puede permitir que un atacante escriba código maliciosos en estas zonas de memoria y sobrescriba otros datos críticos del sistema, como la dirección de retorno de una función o la dirección de memoria donde se almacena una variable, permitiendo al atacante tomar el control del flujo del programa. 

Los impacto de un buffer overflow pueden ser graves, ya que un atacante puede aprovechar esta vulnerabilidad para obtener información confidencial, robar datos o incluso tomar el control completo sistema. Si los atacantes disponen del conocimiento necesario, pueden incluso conseguir ejecutar comandos maliciosos en el sistema comprometido.

------

# Explotación 

- # Fase de fuzzing

Cuando hablamos de la fase de fuzzing hacemos referencia a la fase inicial de la explotación de un buffer overflow, una de las primeras tareas la cual es averiguar los límites del programa objetivo. Esto se hace probando a introducir más caracteres de los debidos en diferentes campos de entrada del programa, como una cadena de texto o un archivo, hasta que se detecte que la aplicación se corrompe o falla. 

- # Averiguar el offset

Una vez que se encuentra el límite del campo de entrada, el siguiente paso es averiguar el **offset**, que corresponde al número exacto de caracteres que se deben introducir para provocar una corrupción en el programa y, por lo tanto, para sobrescribir el valor del registro EIP. 

El registro **EIP (Extended Instruction Pointer)** es un registro de la CPU que apunta a la dirección de memoria donde se encuentra la siguiente instrucción que se va a ejecutar. En un buffer overflow exitoso, el valor del registro EIP se sobrescribe con **una dirección controlada por el atacante**, lo que permite ejecutar código malicioso en lugar del código original del programa. 

Por lo tanto, uno de los objetivos iniciales es averiguar el **offset** para determinar el número exacto de caracteres que se deben introducir en el campo de entrada para sobrescribir el valor del registro EIP y apuntar a la dirección de memoria controlada por el atacante. Una vez que se conoce el offset, el atacante puede diseñar un exploit personalizado para el programa objetivo que permita tomar control del registro EIP y ejecutar código malicioso. 

- # Asignación de espacio para Shellcode

Una vez que se ha encontrado el **offset** y se ha sobrescrito el valor del registro **EIP** en un buffer overflow, el siguiente paso es identificar en qué parte de la memoria se están representando los caracteres introducidos en el campo de entrada. 

Después de sobrescribir el valor del registro EIP, cualquier carácter adicional que introduzcamos en el campo de entrada, veremos desde el **immunity debugger** que (En este caso en particular) se estarán representando al comienzo de la **pila (stack)** en el registro **ESP (Extended Stack Pointer)**. El **ESP** es un registro de la CPU que se utiliza para manejar la pila (Stack) en un programa. La pila es una zona de memoria temporal que se utiliza para almacenar valores y **direcciones de retorno** de las funciones a medida que se van llamando en el programa.

Una vez que se ha identificado la ubicación de los caracteres en la memoria, la idea principal en este punto es introducir un **shellcode** en esa ubicación, que son instrucciones de bajo nivel las cuales en este caso corresponderán a una instrucción maliciosa. 

El shellcode se introduce en la pila y se coloca en la misma dirección de memoria donde se colocaron los caracteres sobrescritos. En otras palabras, se aprovecha el desbordamiento del búfer para ejecutar el shellcode malicioso y tomar el control del sistema. 

Es importante tener en cuenta que el shellcode debe ser diseñado cuidadosamente para evitar que se detecte como un programa malicioso, y debe ser compatible con la arquitectura de la CPU y el sistema operativo que se está atacando. 

(En resumen, la asignación de espacio para el shellcode implica identificar la ubicación en la memoria donde se colocarlos los caracteres sobrescritos en el buffer overflow y colocar allí el shellcode malicioso. Sin embarco, no todos los caracteres del shellcode pueden ser interpretados. Aquí es donde entran en juego los **badchars** 
- # Detección de badchars y generación de Bytearrays 

En la generación de nuestro shellcode malicioso para la explotación del buffer overflow, es posible que algunos caracteres no sean interpretados correctamente por el programa objetivo. estos caracteres se conocen como **badchars** y pueden causar que el shellcode falle o que el programa objetivo se cierre inesperadamente. 

Para evitar esto, es importante identificar y eliminar los badchars del shellcode. Podremos hacer esto con las funcionalidades que ofrece **mona** en el **Immunity Debugger** para generar diferentes bytearrays con casi todos los caracteres representados, y luego identificar los caracteres que el programa objetivo no logra interpretar.

Una vez identificados los *badchars*, se pueden descartar del shellcode final y genera un nuevo shellcode que no contenga estos caracteres. Para identificar los badchars se pueden utilizar diferentes técnicas, como la introducción de diferentes bytearrays con caracteres hexadecimales consecutivos, que permiten identificar los caracteres que el programa objetivo no logra interpreatar. 

Estos caracteres irán representados en la pila (**ESP**), que será donde veremos qué caracteres son los que no están siendo representados, identificando así los badchars.

- # Búsqueda de OpCodes para entrar al ESP y cargar shellcode 

Una vez que se ha generado el shellcode malicioso y se han detectado los badchars, el siguiente paso es hacer que el flujo del programa entre en el shellcode para que sea interpretado. La idea es hacer que el registro EIP apunte a una dirección de memoria donde se aplique un **opcode** que realice un salto al registro **ESP (JMP ESP)**, que es donde se encuentra el shellcode. Esto es así dado que de primeras no podemos hacer que el EIP apunte directamente a nuestro shellcode. 

Para encontrar el opcode **JMP ESP**, se pueden utilizar diferentes herramientas, como **mona.py**, que permite buscar opcodes en módulos específicos de la memoria del programa objetivo. Una vez que se ha encontrado el opcode **JMP ESP**, se puede sobrescribir el valor del registro EIP con la dirección de memoria donde se encuentra el opcode, lo que permitirá saltar al registro ESP y ejecutar el shellcode malicioso.

La búsqueda de opcodes para entrar al registro ESP y cargar el shellcode es una técnica utilizada para hacer que el flujo del programa entre en el shellcode para que sea interpretado. Se utiliza el opcode **JMP ESP** para saltar a la dirección de memoria del registro ESP, donde se encuentra el shellcode. 

- # Uso de NOPs o desplazamientos en pila 

Una vez que se ha encontrado la dirección del opcode que aplica el salto al registro **ESP**, es posible que el shellcode no sea interpretado correctamente debido a que su ejecución puede requerir más tiempo del que el procesador tiene disponible antes de continuar con la siguiente instrucción del programa.

Para solucionar este problema, se suele utilizar técnicas como la introducción de **NOPs (Instrucciones de no operación)** antes del shellcode en la pila. Los NOPs no realizan ninguna operación, pero permiten que el procesador tenga tiempo adicional para interpretar el shellcode antes de continuar con la siguiente instrucción del programa.

Otra técnica que se suele utilizar es el desplazamiento en la pila, que implica modificar el registro ESP para reservar espacio adicional para el shellcode y permitir que se ejecutar sin problemas. por ejemplo, se puede utilizar la instrucción **sub esp,0x10** para desplazar el registro ESP **16 bytes** hacia abajo en la pila y reservar espacio adicional para el shellcode.


