-----
- Tags: #teoria #practica #redes #ataques 
----

# Tarjetas de Red 

### Para poder llevar a cabo un ataque de **WiFi** es importante contar con una tarjeta de red. Una **tarjeta de red** es un componente de **hardware** que conecta un ordenador a una red y que posibilita compartir recorsos en una red de computadoras. 

- ### La computadora suele traer una y si estamos en una distribución de **linux** y con la misma en un Sistema Operativo base, podriamos utilizar dichar tarjeta de red siempre y cuando acepte el **modo monitor**

- ### En caso de que dicha tarjeta no acepte modo monitor necesitaremos una **tajeta de red** o **adaptador WiFi** con la funcionalidad de **modo monitor**. 

### El **modo monitor** es un modo que permite hacer uso de la **Tarjeta WiFi** en modo de escucho o modo promiscuo de **datos**. En este modo la tarjeta es capaz de capturar todos los tipos de paquetes tramitados en una red WiFi.

### Al conectar una **tarjeta de red** se creara una nueva **interfaz**, mediante la cual nos podriamos comunicar con la misma

----

# Interfacez de Red

### Una interfaz de red es el software que se comunica con el dispositivo que nos brinda internet y la capa **IP** a fin de proporcionar a la capa IP una interfaz coherente con todos los adaptadores de red que puedan estar presentes.

```shell
# Listar interfacez de red 
ifconfig
# Listar interfacez de red que no esten activas, que esten dadas de bajas, etc.
iwconfig
```

----

# Direcciones IP 

### Como vimos en [[Conceptos Basicos]], las direcciones **IP** son identificadores númericos para **identificar** dispositivos en una **red**.  Es importante agregar que dichas **IP** pueden ser bien **PRIVADAS** o **PUBLICAS**.

- ## IP Privada
### La ip privada es la ip que se asigna dentro del entorno de **red local**, por lo que si alguien por ejemplo nos lanzase una traza icmp, nuestra maquina no responderia ya que es la ip que utiliza para el segmento de red privada.

- ## IP Pública
### En cambio la ip publica es con la ip que **salimos** a **internet**, la cual debemos cuidar para que no sea obtenida por nadie.

```shell
# Ver mis ips privadas
hostname -I 
# Ver mi ip publica 
curl https://ipinfo.io 
```

----

# Direcciones MAC 

### Concepto tambien explicado en [[Conceptos Basicos]], pero en este caso, entrando con lo que es la explotación es importante saber cambiar la dirección **MAC** ya que es el identificador, por lo que todo tráfico en la red registrara esta dirección **MAC** nuestra, por lo que es el primer paso necesario para llevar acabo cualquier tipo de ataque. 

```shell
# Ver la dirección mac de mi tarjeta de red 
macchanger -s {interfaz}
# Ver los OUI's (Explicado en Conceptos Basicos)
macchanger -l 
# Una vez seleccionado un OUI, solo queda cambiar la MAC haciendo uso de uno y pudiendo modificar el NIC a gusto tambien 
macchanger --mac=FF:FF:FF:FF:FF:FF {interfaz}
```

----

# Handshake 

### Cuando un dispositivo se conecta a una red WIFi es produce lo que se conoce como **handshake** entre el **AP** (Access Point) y el **dispositivo**. Esto se hacer para verificar que las **credenciales** que se proporcionan en este momento coincidan entre si, tanto las del **AP** con las del **dispositivo**, por lo que las **credenciales viajan cifradas** por los paquetes en este momento. 

----

# Pre-Explotación 

- ## Inicializar el modo monitor 

### Como vamos a manipular el modo en el que opera actualmente nuestra interfaz, es necesario suspender la interfaz para realizar los cambios y configuraciones necesarias, en este punto lo quen os intereza es realizar el cambio a **modo monitor** así tambien como realizar el **cambio de la MAC**. 

### Para realizar la mayoria de los ataques que más adelante vamos a ver, utilizaremos una **Suite de software**, que es un paquete de archivos y aplicaciones, llamada **Aircrack** la cual consiste en un conjunto de herramientas que sirven para hacer funcionar a esta como un analizador de paquetes de redes y auditoria inalámbrica. 

```shell
# Suspender una interfaz / Reactivar la interfaz 
ifconfig {interfaz} down / ifconfig {interfaz} up 
# Volver a ver el estado de nuestra interfaz 
iwconfig
# Inicializar el modo monitor con la suite de aircrack / suspender modo monitor
airmon-ng start {interfaz} / airmon-ng stop {interfaz}
```

### Algo importante a remarcar, es que a la hora de inicializar el **modo monitor** hay que tener en cuenta que ciertos **procesos** quedan **corriendo** los cuales podrian traer ciertos **problemas** en ataques a realizar, por lo que se deben matar dichos procesos (A la hora de inicializar el modo monitor estos procesos salen en el **stdout** y se recomienda matarlos )

```shell
# Cualquiera de las tres maneras sirven para matar estos procesos (dhclient y wpa_supplicant)
pkill {name_process} && pkill {name_process}
killall {name_process} {name_process}
airmon-ng check kill 
```

### Y algo a recordar es que cuando **paremos** el **modo monitor** se recomienda **reiniciar** el servicio de **networking**. Este servicio es un software que permite que el sistema operativo pueda comunicarse con diferentes redes, ya sean cableadas o inalámbricas. Este servicio es responsable de administrar los recursos de red del sistema, como la configuración IP, la configuración de la interfaz de red, el enrutamiento y la resolución de nombres. 

```shell
# Opciones de restartear el servicio de networking
/etc/init.d/networking restart 
service networking restart 
```

- ## Dumpeo del tráfico de red 

### Para poder iniciar un ataque de red se debe tener un objetivo, pero previo a esto debemos saber ciertas cuestiones como el **canal**, la **essid** o el **bssid**, entre otras cosas de la red para poder dirigir el ataque hacia una sola red. 

### A continuación se listan los valores que seran representados a la hora de dumpear el tráfico de una o varias redes.:

- #### **BSSID**:  MAC del AP (Access Point) o Router. 
- #### **PWR**: Power de la red. 
- #### **\#Data**: Data de la red. 
- #### **\#/s**: Por segundo. 
- #### **CH**: Canal en el que escucha la red. 
- #### **MB**: MegaBytes. 
- #### **ENC**: Encriptado. 
- #### **CIPHER**: Parte del cífrado. 
- #### **AUTH**: Clave de autorización. 
- #### **ESSID**: Nombre de la red 

### Ejemplo de un dumpeo de red: 

![[dumpeo_de_trafico.png]]

### Otra cosa importante, es la parte inferior donde se muestra **STATION**, hace referencia a los **dispositivos** que se logran analizar junto a la red que estan conectados (**BSSID**). 

### Ahora si, toca dumpear el tráfico de la red y posteriormente comenzar a filtrar por canales, bssid, essid, etc. y para realizar dichas acciones tenemos varios comandos: 

```shell 
# Dumpear todo el tráfico de red.
airodump-ng {interfaz}
# Dumpear todo el tráfico de red para un canal. 
airodump-ng -c {channel} {interfaz}
# Dumpear todo el tráfico de red para una red en particular
airodump-ng -c {channel} --essid {essid} {interfaz}
airodump-ng -c {channel} --bssid {bssid} {interfaz}
```

### Ahora bien, para hackear una red inalambrica, necesitamos ir guardando todo el tráfico en un archivo para poder capturar la contraseña ya que esta no va a estar en texto claro, si no, cifrada con el **CIPHER** que tenga, posteriormente necesitariamos extraer el hash de la clave cifrada para aplicar fuerza bruta, por lo tanto,  para capturar dicho tráfico en un archivo se utiliza el sig. comando: 

```shell 
# Escaneando una red en particular haciendo uso del essi o bssid, necesitamos agregar el -w para dumpear todo el trafico en un arhcivo.
ariodump-ng -c {channel} --essid/--bssid {essid/bssid} -w {file_name} {interfaz}
```

----

# Explotación 

### Es importante entender, que el objetivo de todos los ataques termian siendo conseguir el **handshake**, para realizar esto existen varios tipos de ataques. 

## Flujo de conexión habitual [[ConexionesWiFi_draw]].

----

- ## NO Attack 

### Esto **no** es un ataque como tal, pero se puede realizar para conseguir el **handshake** y es perfectamente válido, consiste en esperar y dejar que los usuarios de la red a atacar se **alejen** o **desconecten** y **vuelvan a conectar** de manera natural y diaria para que con el solo hecho de estar dumpeando el tráfico de dicha red, cuando el usuario se desconecte y vuelva a conectar viaje la **PSK** ( Pre-Shared Key ), es decir, el **handshake** y de esta  manera poder **capturarlo** sin realizar **ningun ataque**. 

----

- ## Ataque de DEAUTENTICACIÓN

### Representación visual de este ataque [[DEAUTHENTICATION_ATTACK_draw]]. 

### En este ataque el atacante se encuentra interceptando todo el tráfico de la red victima para al mismo tiempo envíar paquetes de deautenticación a los usuarios conectados a la red para denegarles el servicio (DOS), para posteriormente frenar el envío de estos y que los usuarios victimas envíen al **PSK** (Pre-Shared Key) y asi finalmente capturar las credenciales. 

### En criptografía, una clave previamente compartida, **clave precompartida** o *PSK*, es una clave secreta compartida con anterioridad entre las dos partes usando algún canal seguro antes de que se utilice. Es decir, los usuarios al ser justamente usuarios de esta red, en caso de que hayan puesto la opción de "**recordar red**" generaron esta **PSK** que se **envía** de manera **automatica** al volver a estar en rango o disponibilidad de conexión con el AP.

### Enviar paquetes de deautenticación al AP vitima: 

```shell 
# Envíar x paquetes de deautenticación a un cliente en especifico conectado al AP victima
aireplay-ng -0 {nro_paquetes} -e {name_essid} -c {mac_cliente} {interfaz}
# Enviar x paquetes de deautenticación a todos los clientes conectados al AP víctima 
aireplay-ng -0 {nro_paquetes} -e {name_essid} -c FF:FF:FF:FF:FF:FF {interfaz}
aireplay-ng -0 {nro_paquetes} -e {name_essid} {interfaz}
# El -0 hace referecia al modo --deauth, asi como el 0 en nro de paquetes hace referencia a infinitos, con el comando --help como siempre se puede ver todo. 
aireplay-ng --help 
```

----

- ## Ataque de FALSA AUTENTICACIÓN 

### Este ataque se puede realizar en caso de que nuestra red  NO tuviese clientes, podriamos hacer este ataque de **fakeauth**. Consta de introducir una "**STATION** (Cliente)" en el AP, pero esto no quiere decir que este este conectado, ni que tenga una dirección IP asignada. Simplemente engañamos al AP para hacerle creer que tiene un nuevo cliente.

```shell
aireplay-ng -1 0 -e {name_essid} -a {bssid} -h {fake_mac_direction} {interfaz}
```

----

- ## Ataque de SECUESTRO DE ANCHO DE BANDA

### Este ataque consiste en que el atacante consume gran parte del ancho de banda disponible en la red, limitando la cantidad de ancho de banda que está disponible para los usuarios légitimos.

### Existen dos mecanismos de control de acceso al medio que se utilizan en redes inálambricas para evitar colisiones de datos y mejorar el rendimiento de la red. 

> [!info]
> ### **RTS** (Requests to send): 
> 
> ### Es una señal que se envía desde un nodo inalámbrico al nodo destinatario para solicitar el derecho de transmitir datos. Al enviar una señal **RTS**, el nodo emisor informa al nodo destinatario que desea transmitir datos y solicita la autorización para hacerlo. 
> ### Este mecanismo se utiliza para evitar la transmisión de datos de nodos inálambricos que están demasiado lejos para escuchar las señales de nodos de otros nodos inálambricos. Al enviar una señal **RTS**, el nodo emisor se asegura que el nodo destinatario esté disponible para recibir los datos antes de transmitirlos. Esto ayuda a reducir la pérdida de datos y mejora el rendimiento de la red. 
> 
> #### Paquete RTS: 
> ![[RTS.png]]


>[!info]
>### **CTS** (Clear to send):
>### Es una señal que se envía desde un nodo inalámbrico a otro para solicitar el derecho de transmitir datos. Cuando un nodo inalámbrico desea transmitir  datos, primero envía una señal **RTS** al nodo destinatario. Si el nodo destinatario está libre para recibir datos, responde con una señal **CTS** para informar al nodo emisor que puede transmitir los datos. ### El mecanismo **CTS** se utiliza para evitar colisiones entre nodos que intentan transmitir datos al mismo tiempo. Si dos nodos transmiten al mismo tiempo, se produce una colisión que puede causar la pérdida de datos. Al solicitar la autorización para transmitir mediante una señal **CTS**, se  reduce la probabilidad de colisiones yse mejora el rendimiento de la red inalámbrica. 
>
>#### Paquete CTS: 
>
>![[CTS.png]]

### Este ataque consiste en modificar un paquete **CTS** para generar un tráfico elevado, generar colisiones de datos y saturación en el ancho de banda. 

### Para realizar esto, primero necesitamos capturar brevemente el tráfico de la red para conseguir un paquete **CTS** y posteriormente editarlo. 

```shell
airodump-ng --essid {essid} -c {channel} -w {file.cap} {interfaz}
```

### Una vez que dejemos correr unos segundos, podemos terminar la intercepción del tráfico de red, y podemos comenzar a ver los paquetes **CTS** y analizar todo el tráfico obtenido con [[⚒ Herramientas ⚒]] como **tshark** o **wireshark** 

```shell 
# -Y para filtrar 
# -Tjson para ver en formato json
# -Tfields -e wlan.duration para filtrar por parametros
tshark -r {file.cap} -Y "wlan.fc.type_subtype" 
# Si utilizamos wireshark en el apartado de "Apply a display filter" introducimos "wlan.fc.type_subtype"
wireshark {file.cap} &>/dev/null & disown
```

### La diferencia entre estas herramientas es que **tshark** es de consola y **wireshark** cuenta con GUI. 
### Una vez filtrado por dichos paquetes, apareceran varios, buscamos por aquellos que tengan la string **Clear-to-send** en la sección de info, una vez seleccionado dicho paqute tocamos **file** > **Export specified packets** > **Select packets only** > **guardar**. 

### Una vez que tengamos el arhivo **CTS.cap** el cual sera  un paquete CTS, podremos ver de manera previa que dicho paquete cuenta con una "duración", la cual tenemos que modificar como objetivo. 

#### Ejemplo **wireshark**: 

![[CTS_time_ws.png]]


#### Ejemplo **tshark**:

```shell
tshark -r CTS.cap -Tjson
```

![[CTS_time_ts.png]]

### Ahora solo queda editar la duración en la que los paquetes **CTS** comunican que la conexión esta "libre", intentaremos modificar dicho falor del paquete tramitido por el valor de **30000** para si intentar lograr saturar la red. 

### Para esto utilizaremos una [[⚒ Herramientas ⚒]] llamada **ghex** para editar los valores de esta captura. 

```shell
ghex CTS.cap &>/dev/null & disown
```

![[ghex_cts.png]]

### Nos fijamos que valores exadecimales pertenecián al "**duration time**" en wireshark, para eso abrimos el paquete **CTS**, hacemos doble click, y en la pestaña que se nos abre, tocamos  **....Duration: ......** y veremos su valor hexadecimal: 

![[CTS_ws_time.png]]

### En este caso **88 00**, entendiendo que estos valores tendran que ser remplazados con la herramienta de **ghex**. 
### Como queremos remplazar estos **136 microseconds** por **30000**, es necesario ver el valor hexadecimal de esto, y esto lo podemos hacer con python3 

```python
hex(30000)
```

### Dando como valor **0x7530** teniendo que modificarlo en **ghex** como **30 75**, quitando el 0x e invirtiendo los valores...

![[ghex_edit_time.png]]

### De esta manera si lo volvieramos a ver con **tshark** o **wireshark** veriamos que tendriamos una duración de **30000**, por lo que solo falta **replicar** el paquete **CTS editado**. 

```shell
tcpreplay --intf1={interfaz} --topspeed --loop=2000 {CTS_edited.pcap} 2>/dev/null
```

### De esta manera estariamos utilizando nuestra **tarjeta de red** para tramitar 2000 paquetes **CTS** de duración de **30000**. Incluso podriamos interceptar el tráfico de red y filtrar por paquetes **CTS** para corroborar el envío de estos paquetes. 

----

- ## Ataque BECAON FLOOD 

### Este ataque consiste en "**invadir**" el "**espacio aereo**" con paquetes **becaon** (Que son emitidos por los puntos de acceso para verificar dispositivos). Estos paquetes contienen información, tipo de cifrado, ssid, canal del AP, etc. La idea es **emitir muchos paquetes beacon con falsa información referente**. De esta manera **saturamos** el espectro onda de la red.

```shell
# man mdk3 para leer los parametros
mdk3 {interfaz} b -f {file_name} -a -s 2000 -c {channel}
```

### Al ejecutar este comando se verian muchos AP's con el nombre de cada una de las líneas del "file_name" introducido. 

```shell
for n in $(seq 1 10); do echo "Network$n" >> {file_name}; done
```

---

- ## Ataque DISASSOCIATION AMOK MODE

### Este ataque se aprovecha de una **vulnerabilidad** en el protocolo de **autenticación** y **asociación** del AP. Cuando un cliente se conecta a una red Wi-Fi, este envía un paquete de asociación al punto de acceso (AP) para solicitar una conexión. El AP responde con un paquete de confirmación de asociación. El ataque de **DISASSOCIATION AMOK MODE** aprovecha una vulnerabilidad en este proceso, en la que el atacante **envía paquetes de desasociación falsificados al cliente**, engañándolo para que se desconecte de la red Wi-Fi. 

### En este ataque, el atacante **envía grande cantidad de paquetes de desasociación al cliente**, generando un **gran cantidad de tráfico en la red**. Esto puede **sobrecargar al cliente y al AP**, provocando que se **desconecten** los clientes legítimos de la red. 

### Para explotar este ataque podemos hacerlo de manera manual, capturando con las [[⚒ Herramientas ⚒]] **tshark** o **wireshark** paquetes de **desasociación** para posteriormente como en el ataque de **Secuestro de ancho de banda**, hacer uso de **tcpreplay** y emitir estos paquetes modificados, pero tambíen, como en el ataque de **Beacon flood attack**, podemos hacer uso de la herramienta **mdk3**

### Por lo que podemos hacer uso de una *blacklist* o *whitelist* para indicar las direcciones mac a desasociar y las direcciones mac permitidas

```shell
# Con un archivo con direcciones mac dentro
mdk3 {interfaz} d -w {blacklist} -c {channel}
```

-----

# Crackeo de HandShake 

### Una vez capturado el **handshake** tendriamos el archivo de captura.cap con muchos datos, dentro, la contraseña del AP encriptada, por lo que ahora tocaria crackear dicho contraseña. 

- ## Manual

### Una vez que tengamos el archivo de captura .cap, tendriamos que volver dicho archivo .cap a .hccap, ya que este archivo es compatible con **john** (Herramienta de fuerza bruta)

```shell 
aircrack-ng -J {name_file.hccap} {file.cap}
```

### De esta manera tendriamos un nuevo archivo .hccap el cual haciendo uso de la herramienta **hccap2john** (Herramienta que convierte archivo .hccap compatible con la herramienta **john**)

```shell
hccap2john {name_file.hccap} > {file_to_john}
```

### Ahora, solo quedaria hacer uso de **john** para realizar un ataque de fuerza bruta al archivo creado. 

```shell
john --wordlist={wordlist} {file_to_john}
```

- ## Automática

### Una vez que tengamos el archivo de captura .cap, podriamos realizar un ataque de fuerza bruta a la contraseña encriptada del AP que se encuentra en todo el archivo .cap. 

```shell
aircrack-ng -w {wordlist} {file.cap} 
```

----

# Espionaje 

### Una vez conseguida la contraseña de la red, podriamos conectarnos a la misma para proceder con intentar vulnerar dispositivos con habilidades de Red Team, o bien podriamos comenzar a capturar todo el trafico de la red, desencriptarlo para asi poder ver todo el trafico entero, es decir, páginas visitadas, metodos http, direcciones IP, etc. 

## Desencriptar el tráfico: 

```shell 
airdecap-ng -p {password} -e {essid} {file.cap}
```

### Una vez hecho esto, en caso de que la contraseña sea correcta, se desencriptaran los paquetes que se han capturado pudiendo asi con [[⚒ Herramientas ⚒]] como **tshark** o **wireshark**, filtrar por metodos post, peticiones http, etc.

```shell
tshark -r {file-dec.cap} -Y "dns"
tshark -r {file-dec.cap} -Y "http" 
tshark -r {file-dec.cap} -Y "http.request.method==POST" -Tjson 
tshark -r {file-dec.cap} -Y "http.request.method==POST" -Tfields -e http.file_data 
```



----

# Filtros de paquetes 

- ### **RTS**: Paquetes que se tramitan para verificar si el nodo esta apto para recibir datos. 
- ### **CTS**: Paquetes que se tramitan para confirmarle al nodo emisor que el nodo receptor esta  apto para recibir datos, es la respuesta del **RTS**. 
- ### **PROBE REQUEST**: Paquetes que se tramitan para intentar volver a conectar a la red un dispositivo que fue desconectado y ver si el AP contesta. 
- ### **PROBE RESPONSE**: Paquetes que se tramitan desde el AP en contestación del **probe response**.
- ### **ASSOCIATION REQUEST**: Paquetes que se tramitan para intentar asociarse al AP.
- ### **ASSOCIATON APROBE**: Paquetes que se tramitan en respuesta del intento de asociamiento, es decir del **association request**. 
- ### **BEACON**: Paquetes que se tramitan indicando el canal y la información del AP. 
- ### **AUTENTICATION**: Paquetes que se tramitan posteriormente a la asociación (**association aprobe**), por lo que se intenta la autenticación. 
- ### **DEAUTENTICATION**: Paquetes que se tramitan para deautenticarse. 
- ### **DESASOCITION**: Paquetes que se tramian una vez que la deautenticación es exitosa (**deautentication**) para desasociar el dispositivo. 

> [!info]
> - ### Filtrar por paquetes **RTS** 
> 	 #### wlan.fc.type_subtype==27
> 	 
> - ### Filtrar por paquetes **CTS** 
> 	 #### wlan.fc.type_subtype==28
> 	 
> - ### Filtrar por paquetes **PROBE REQUEST** 
> 	 #### wlan.fc.type_subtype==4
> 	 
> - ### Filtrar por paquetes **PROBE RESPONSE** 
> 	 #### wlan.fc.type_subtype==5
> 	 
> - ### Filtrar por paquetes **ASSOCIATION REQUEST** 
> 	 #### wlan.fc.type_subtype==0
> 	 
> - ### Filtrar por paquetes **AASOCIATION RESPONSE** 
> 	 #### wlan.fc.type_subtype==1
> 	 
> - ### Filtrar por paquetes **BEACON** 
> 	 #### wlan.fc.type_subtype==8
> 	 
> - ### Filtrar por paquetes **AUTENTICATION** 
> 	 #### wlan.fc.type_subtype==11
> 	 
> - ### Filtrar por paquetes **DEAUTENTICATION** 
> 	 #### wlan.fc.type_subtype==12
> 	 
> - ### Filtrar por paquetes **DESASOCIATION** 
> 	 #### wlan.fc.type_subtype==10

