-----
- Tags: #escalada #teoria #practica
-----


# PATH Hijacking

### **PATH Hijacking** es una técnica utilizada por los atacantes para **secuestrar comandos** de un sistema Unix/Linux mediante la manipulación del **PATH**. El PATH es una variables de entorno que define las rutas de búsqueda para los archivos ejecutables en el sistema.

### En algunos binarios compilados, algunos de los comandos definidos internamente pueden ser indicados con una ruta relativa en lugar de una ruta absoluta. Esto significa que el binario busca los archivos ejecutables en las rutas especificadas en el PATH, en lugar de utilizar la ruta absoluta del archivo ejecutable.

### Si un atacante es capaz de alterar el PATH y crear un nuevo archivo con el mismo nombre de uno de los comandos definidos internamente en el binario, puede lograr que el binario ejecuta la versión maliciosa del comando en lugar de la versión legítima.

### Por ejemplo, si un binario compilado utiliza el comando "*ls*" sin su ruta absoluta en su código y el atacante crea un archivo maliciosos llamado "*ls*" en una de las rutas especificadas en el PATH, el binario ejecutará el archivo malicioso en lugar del comando legítimo "**ls**" cuando sea llamado.

# Prevenir el PATH Hijacking

### Para prevenir el **PATH Hijacking**, se recomienda utilizar **rutas absolutas** en lugar de rutas relativas en los comandos definidos internamente en los binarios compilados. Además, es importante asegurarse de que las rutas en el PATH sean controladas y limitadas a las rutas necesarias para el sistema. También se recomienda utilizar la opción de permisos de ejecución para los archivos ejecutables solo para los usuarios y grupos autorizados. 

# Escalada

### Para escalar los privilegios del usuario actual mediante el empleo de un **PATH Hijacking** lo que deberíamos hacer es intentar abusar de un binario mal programado el cual debería ejecutar algún comando a nivel de sistema pero **SIN hacerlo de forma absoluta**, es decir, en lugar de indicar por ejemplo **/usr/bin/whoami** lo hace como **whoami**. 

### Por ejemplo, si tuviéramos un script en **Go** el cual se ve de la siguiente manera: 

```go
#include <stdio.h>

int main(){
	setuid(0);
	printf("Este programa sirve para indicarnos que usuario somos"); 
	printf("\n\n\t[!] Actualmente somos el usuario: "); 
	system("whoami")
	return 0; 
}
```

### El cual es compilado `gcc {file.c} -o {binario}` y se le dan permisos SUID `chmod u+s {binario}`. 

### Si bien **no sabríamos** de primeras que se esta ejecutando un comando **sin su ruta absoluta** y a la vez no disponemos del archivo inicial **.c** que compila posteriormente el binario para ver que hace por detrás el binario ni podemos ver el contenido del mismo con **cat** por ser un precisamente un binario, podemos hacer uso de **strings** para ver si (Intuyendo que se ejecuta un **whoami** debido a que el programa parece indicarnos con que usuario estamos ) existe alguna string relacionado al comando **whoami**, ya sea la ruta absoluta o el mismo **whoami**

### Si al hacer `strings {bibario} | grep "whoami"` vemos la cadena "whoami", quiere decir que se podría estar ejecutando el comando whoami sin su ruta absoluta, lo que podría derivar en un **PATH Hijacking**. 

### Para hacer esto, simplemente deberíamos crear un binario llamado como el comando que se ejecuta sin su ruta absoluta (En este caso **whoami**) en un directorio con permisos de escritura, para posteriormente modificar la variable de entorno PATH para indicar que la primera ruta de búsqueda de los binarios es en dicho directorio donde depositamos nuestro comando maliciosos

```bash 
cd /tmp 

touch whoami 

echo "bash -p" > whoami 

export PATH=/tmp/:$PATH
```

### Una vez modificado el path, deberíamos volver a ejecutar el binario inicial para que a la hora de llegar a la línea en donde ejecuta el comando *"whoami"* al tener el path modificado indicando que se tiene que buscar todo binario indicado sin su ruta absoluta en primer lugar en el path "**/tmp"**, al dirigirse a esta en busca del binario **whoami** el mismo sea hallado y ejecutado, dando como resultado el lanzamiento de una bash con privilegios (Ya que el binario tenía permisos SUID)
