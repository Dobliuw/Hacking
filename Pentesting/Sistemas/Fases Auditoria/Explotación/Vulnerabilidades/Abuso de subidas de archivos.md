-----
- Tags: #ataques #teoria #practica #basico 
---

# ¿ Que es el **abuso de subidas de archivos** ? 

### El abuso de subidas de archivos es un tipo de ataque que se produce cuando un atacante aprovecha las vulnerabilidades en las aplicaciones web que permiten a los usuarios **cargar archivos** en el servidor. Este tipo de ataque se conoce comúnmente como un ataque de "**subida de archivos malicioso**". 

### En una ataque de subida de archivos maliciosos, un atacante carga un archivo malicioso en una aplicación web, que luego se almacena en el servidor. Si por ejemplo el atacante consigue subir un archivo PHP y el servidor web lo almacena, podría conseguir ejecución remota de comandos y tomar el control del servidor. 

### También se puede utilizar técnicas de "**falsificación de tipos de archivos**" para engañar a una aplicación web con el objetivo de que acepte un archivo malicioso como si fuera un archivo legítimo. 

----

# Explotación 

### Para esta vulnerabilidad existen infinidad de casos, con más o menos validaciones, del lado del servidor, del cliente, etc. Por lo que es importante aclarar que a continuación se mostraran varios casos pero existen más.

### Es importante aclarar que el hecho de que los casos esten enumerados y sean distintos simplemente habla de diversos casos que podrian pasar.

- # Caso NO VALIDATION: 

### Obviamente este caso es el caso más basico y facil, en  donde a pesar de que la web puede aclararnos (o no) que solo subamos archivos de una o unas exteción/extenciones en particular, no existe ningun tipo de validación ni del lado del servidor ni del lado del cliente, por lo que bastaria con subir un archivo .php (En caso de que veamos que la web lo acepta) malioso tipico para ejecutar comandos. 

```php 
<?php 
	system($_GET['cmd']);
?>
```

- # Caso CLIENT CONTROL: 

### En este caso, existe una validación, pero unicamente del lado del cliente, por lo que podriamos inspeccionar la página para ver si esto es así, una vez corroborado este caso, podriamos simplemente eliminar la validación del lado del servidor que podría estar ocurriendo a la hora de ejecutar una función "onSubmit".

### Al inspeccionar archivos podriamos ver que se realiza una acción on submit, la cual simplemente podriamos **eliminar**.
![[eliminar_validación_fileupload.png]]

- # Caso PHP VALIDATION: 

### También podría ocurrir que exista una validación del lado del servidor pero unicamente que matchee con la palabra *.php*, es decir, que si el archivo termina con php no se permita subir, pero es que existen múltiples extensiones interpretables del lado del servidor para PHP, como **_.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._phps_, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_**, por lo que simplemente consta en verificar si algunas de estas extensiones son permitidas para vurlar la verificación. 

## Caso HTACCESS:

### Supongamos que no deja (o si) subir archivos con varias de las extensiones antes mencionadas, pero no hay caso de que logremos ejecutar codigo, ya que pareciese que, en caso de que se logren subir, se suben como texto plano y no se interpretan, o directamente no permite subir estas extensiones, bueno, esto podria ser motivo de que se esta blacklistando todas las extensiones anteriores, pero podría ser el caso de que **.htaccess** no este blacklisteada, por lo que podriamos intentar hacer un **Bypass file upload con .htaccess**. 

### ¿ Que es **.htaccess** ? htaccess también conocido como archivo de configuración distribuida, es un fichero especial, popularizado por el Servidor HTTP Apache que permite definir diferentes directivas de configuración para cada directorio sin necesidad de editar el archivo de configuración principal de Apache.

### Por lo que mediante la extención **.htaccess** podriamos definir una nueva regla para que extensiones que quisieramos, como por ejemplo **.dobliuw** se ejecuten como extensiones **.php**. 

### Una vez subido el archivo con nombre **.htaccess**, y el payload, es decir, la regla que hace que se agrege una nueva regla al servidor apache ( **AddType application/x-httpd-php .dobliuw** ), podriamos simplemente subir un archivo con terminación **.dobliuw** con un código PHP malicioso el cual sera interpretado.

#### El Bypass explicado en este caso puede ser encontrado con una simple busqueda de google: [Bypass](https://thibaud-robin.fr/articles/bypass-filter-upload/).


- # Caso SIZE: 

### Existen casos de validaciones de archivos pero por el size, es decir, muchas veces la realizar payloads, estos son muy largos por lo que la web limita el size de los archivos de subida, muchas veces podríamos llegar a editar nosotros el size el cual la web admite o, también, realizar one liners más cortos, mutando así del típico payload de php a un oneliner que ahorre más espacio.

```php
# Típico payload
<?php
	system($_GET['cmd']);
?>
# One liner
<?php system($_GET[0]);?>
# One liner más corto
<?=`$_GET[0]`?>
```

###  Existen otras variaciones de **system()**, los cuales son **shell_exec**, **echo exec**, entre otros. 

- # Caso CONTENT-TYPE: 

### Así como se puede validar que el archivo NO sea PHP, se puede validar el **Content-Type**, por ejemplo, esperando que este sea un image/jpeg, image/png, etc. por lo que podríamos simplemente modificar el Content-Type: **application/x-php** por **image/jpeg**. 

- # Caso MAGIC NUMBERS:

### Los **magic numbers** son los primeros números de un archivo que definen que tipo de archivo es este, por ejemplo, si tenemos un archivo **.php**, para saber los magic numbers de este, podríamos hacer los siguiente:

```shell
# Para ver el tipo de archivo 
file {file_name}
# Para ver el archivo en decimal 
xxd image.php
# OutPut
# 00000000: 3c3f 7068 7020 0a09 7379 7374 656d 2824  <?php ..system($
# 00000010: 5f47 4554 5b27 636d 6427 5d29 3b20 0a3f  _GET['cmd']); .?
# 00000020: 3e0a 

# Otro ejemplo: 
zip {new_file.zip} {file_to_zip}
# Ver magic numbers
xxd {file.zip}
```

### De esta manera, haciendo uso de una de las [[⚒ Herramientas ⚒]], la cual es **xxd**, podemos ver el archivo en cuestion en hexadecimal y a raiz de los primeros 4 pares de números, por ejemplo en el caso de php **3c 3f 70 68** o en el caso de un comprimido **50 4b 03 04**, podríamos buscar estos en diversas [páginas](https://en.wikipedia.org/wiki/List_of_file_signatures).

### En base a esto, podemos entender, que muchas veces las webs utilizan múltiples sanitizaciones, entre ellas la lectura de los magic numbers, por lo que podriamos intentar vurlar las mismas engañando estos magic numbers.

```php
GIF8;

<?=`$_GET[0]`?>
```

### De esta manera, estaríamos engañando a los magic numbers, ya que los archivos **.gif** suelen tener la cadena **GIF8;** lo que da siempre un magic number de GIF para la subida de archivos. (Esto se puede aplicar con diversas extenciones, como html, etc.)

- # Caso HASHEO: 

### En este caso, independientemente de si existen o no sanitizaciones, los desarrolladores aplican hasheos a los nombres de los recursos que subimos para evitar que, en un repositorio dado, independientemente de si contamos con **directory listing** o no, no podamos acceder al contenido subido, por ejemplo, si en la ruta **/uploads** sabemos que se almacenan nuestros archivos subidos, pero no tenemos capacidad de directory listing, por lo que no podemos ver lo que subimos, tal vez, a la hora de subir nuestro archivo se este aplicando un hasheo con **md5** u otros, para intentar evitar un acceso al recurso subido. 

```shell 
echo -n "{file_name}" | md5sum
```

### De esta manera si hubiéramos subido un archivo "cmd.php", si nos dirigimos a **/uploads/cmd.php** no veríamos nada, mientras que si, realizamos un hasheo md5 al string **cmd**, para al resultante hash (dfff0a7fa1a55c8c1a4966c19f6da452) agregarle un php **/uploads/dfff0a7fa1a55c8c1a4966c19f6da452.php**, podríamos ver el resultado. (Esto es aplicable con diversos hasheos ya sea a modo de prueba por una existente posibilidad o por que la web nos filtre dicho y string, como **cmd**, **cmd.**, **cmd.php**, etc.  ).

### Por lo que el hash podría ser de todo el contenido, variantes del nombre y entre diversos hasheos, md5sum, sha1sum, etc. 

- # Caso MATCH STRING: 

### Algunas veces los desarrolladores comprueban de que los archivos que se suben contengan un string en particular, como en la subida de imágenes se podría esperar que el archivo que subimos contenga la cadena **.jpg**, podríamos hacer un ataque de doble extención, es decir, por ejemplo, si queremos subir el típico archivo malicioso **cmd.php**, podríamos subir el archivo **cmd.jpg.php** para burlar dicha validación. 

- # Caso META DATOS: 

### Podríamos intentar inyectar un comentario en los meta datos de un gif por ejemplo, con la herramienta **exiftool**: `exiftool -Comment='<?php system("whoami"); ?>'` para que al subir la imagen, si el servidor en donde esta se mostrase estuviera realizado con php, ver el output de la ejecución de este comentario realizado. 
 




