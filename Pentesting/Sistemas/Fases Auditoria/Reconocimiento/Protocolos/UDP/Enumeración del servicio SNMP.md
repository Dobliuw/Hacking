-----
- Tags: #teoria #practica #basico 
- -----

# Servicio SNMP 

### El **Protocolo Simpe de Administración de Red** o SNMP (**Simple Network Management Protocolo**) es un porotocolo de capa de aplicación para el intercambio de información de gestión entre dispositivos de red. Este protocolo es uno de los protocolos ampliamente aceptados para gestionar y monitorear los elementos de la red. La mayoría de los elementos de la red de grado profesional vienen con el paquete de agente del SNMP. Esto agentes deben ser habilitados y configurados para cominucarse con el sistema de gestión de la red. 

### Los componentes básicvos de SNMP son:
- #### Administrador de SNMP
- #### Dispositivos gestionados 
- #### Agente SNMP
- #### Base de datos de información de gestión también llamada base de información de gestion (MIB)

------

# Administrador de SNMP

### Un administrador o sistema de gestipón es una entidad separada que se encarga de comunicarse con los dispositivos de red implementados por el agante del SNMP. Por lo general, se trata de una computadora que se utiliza para ejecutar uno o mś sistemas de gestión de redes. 

### Funciones claves: 
- #### Consultar a los agentes
- #### Recibir respuestas de los agentes 
- #### Establecer variables en los agentes 
- #### Reconocer los eventos asincrónicos de los agentes 

-----

# Dispositivos gestionados 

### Un dispositvio gestionado o el elemento de red es una parte de la red que requiera algún tipo de monitorizacion y gestión, por ejemplo, routres, switches, servidores, estaciones de trabajo, impresoras, UPS, etc. 

-----

# Agente SNMP

### El agente es un programa que está empaquetado dentro del elemento de la red. La habilitación del agente le permite recopilar la base de datos de información de gestión del dispositivo localmente y la pone a disposición del administrador de SNMP, cuando éste la solicita.

### Funciones clave del agente del SNMP: 
- #### Recopila información de gestión sobre su entorno local.
- #### Almacena y recupera la información de gestión según se define en el MIB.
- #### Señala un evento al administrador. 
- #### Actúa como un proxy para algṕun nodo de la red no gestionable de SNMP. 

-----

# MIB - Base de datos de información de gestión

### Cada agente de SNMP mantiene una base de datos de información que describe los parámetros del dispositivo gestionado. El administrador de SNMP utiliza esta base de datos para solicitar al agente información específica y además traduce la información según sea necesario para el sistema de gestión de la red. 

-----

# Enumeración 

### Algo a tener en cuenta para la enumeración de el servicio **SNMP** son las famosas **Community Strings**, las cuales son una forma de atutenticación y control de acceso básico utilizada en este protocolo para acceder y gestionar dispositivos de red. Una community string en SNMP es esencialmente una contraseña o clave compartida que permite a uns sistema de gestión de red comunicarse con dispositvios administrados.

### Para descubrir la **Community string** usada, podríamos hacer uso del archivo **/usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt** para realizar fuerza bruta con una herramienta llamada **onesixtyone** para posteriormente intentar enumerar información del servicio SNMP con otra herramienta llamada **snmpwalk**. 

```bash
onesixtyone {target_ip} -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt
```

### Una vez obtenida la **Community string** podríamos intentar enumerar información del equipo. 

```bash
snmpwalk -v2c -c {community_string} {target_ip}
```

### A tener en cuenta que para que el output de esto se vea de una manera más legible, podríamos retocar el archivo **/etc/snmp/snmp.conf** e instalar el paquete **snmp-mibs-downloader**. 

```bash
sudo apt install snmp-mibs-downloader

nano /etc/snmp/snmp.conf
# Comentar la línea 4 que dice 
mibs : 
```

-----

# Enumerar procesos 

### De cara a auditorias, algo que nos podría interesar sería el leer procesos que podrían estar corriendo. 

```bash
snmpwalk -v2c -c {community_string} {target_ip} hrSWRunName 
# Output: 
# HOST-RESOURCES-MIB::hrSWRunName.711 = STRING: "python"
```

### Una vez obtenido procesos, podríamos intentar listar más información de dichos procesos, usando de ejemplo el caso anterior, deberíamos hacer uso del PID 711. 

```bash
snmpwalk -v2c -c {community_string} {target_ip} hrSWRunTable | grep "711"
```

### De esta manera  podríamos abusar de información que podría llegar a listarse de esta manera, por ejemplo si detectamos un puerto abierto con (Python BaseHTTPServer) podría ser el caso de que este server se este levantado desde un oneliner haciendo uso de la terminal, lo que supondría un riesgo ya que en caso de estar expuesto el servicio SNMP podríamos llegar a obtener información sensible.

```bash
snpwalk -v2c -c {community_string} {target_ip} hrSWRunTable  | grep "711"
#HOST-RESOURCES-MIB::hrSWRunIndex.711 = INTEGER: 711
#HOST-RESOURCES-MIB::hrSWRunName.711 = STRING: "python"
#HOST-RESOURCES-MIB::hrSWRunID.711 = OID: SNMPv2-SMI::zeroDotZero
#HOST-RESOURCES-MIB::hrSWRunPath.711 = STRING: "python"
#HOST-RESOURCES-MIB::hrSWRunParameters.711 = STRING: "-m SimpleHTTPAuthServer 3366 loki:godofmischiefisloki --dir /home/loki/hosted/"
#HOST-RESOURCES-MIB::hrSWRunType.711 = INTEGER: application(4)
#HOST-RESOURCES-MIB::hrSWRunStatus.711 = INTEGER: runnable(2)
```

### En este ejemplo podemos ver que al estar ejecutandose el proceso desde consola se nos lista información sensible como usuario y contraseña, asi como un directorio de trabajo, etc. 

-----

# Obtener IPv6 para escaneos

### En casos que nos enfrentemos a un escenario en donde tengamos una máquina la cual no tenga muchos puertos abiertos, no sepamos que hacer y tenga el **SNMP** abierto, podríamos intentar conseguir la IPv6 de la máquina para analizar los puertos a travéz de IPv6 ya que internamente podrían existir reglas de firewall que bloqueen puertos de cara a la IPv4. 

```bash
# Enumerar IPv6 de la máquina victima
snmpwalk -v2c -c {community_string} {target_ip} ipAddresstype

# Outpu:
# IP-MIB::ipAddressType.ipv6."de:ad:be:ef:00:00:00:00:02:50:56:ff:fe:b9:97:ef" = INTEGER: unicast(1)

```

### Una vez obtenida una IPv6 (**de:ad:be:ef:00:00:00:00:02:50:56:ff:fe:b9:97:ef**) podríamos retocar esta de manera correcta: 

## dead:beef:0000:0000:0250:56ff:feb9:97ef

### Y una vez tengamos el formato correcto de la IPv6 es importante tener en cuenta que los '0' se pueden eliminar:

## dead:beef::250:56ff:feb9:97ef

### Una vez tengamos la IPv6 podríamos hacer uso de herramientas como **ping6** para ver si existe traza con dicha IP. 

```bash
ping6 -c 1 dead:beef::250:56ff:feb9:97ef
```

### De esta manera podríamos realizar un escaneo con [[Nmap]] por IPv6 y ver si los puertos son distintos. 

```bash
sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn -6 dead:beef::250:56ff:feb9:97ef -oG allPortsv6
```

#### Para acceder a recursos hosteados desde el navegador desde ipv6, deberíamos hacer uso de los corchetes: \[ dead:beef::250:56ff:feb9:97ef \] 

